[
  {
    "Under_test_method": {
      "Method_body": "@GwtIncompatible(\"incompatible method\")\npublic static boolean isValidAnnotationMemberType(Class<?> type) {\n    if (type == null) {\n        return false;\n    }\n    if (type.isArray()) {\n        type = type.getComponentType();\n    }\n    return type.isPrimitive() || type.isEnum() || type.isAnnotation() || String.class.equals(type) || Class.class.equals(type);\n}",
      "all_field_declaration": "/**\n * A style that prints annotations as recommended.\n */\nprivate static final ToStringStyle TO_STRING_STYLE = new ToStringStyle() {\n\n    /**\n     * Serialization version\n     */\n    private static final long serialVersionUID = 1L;\n\n    {\n        setDefaultFullDetail(true);\n        setArrayContentDetail(true);\n        setUseClassName(true);\n        setUseShortClassName(true);\n        setUseIdentityHashCode(false);\n        setContentStart(\"(\");\n        setContentEnd(\")\");\n        setFieldSeparator(\", \");\n        setArrayStart(\"[\");\n        setArrayEnd(\"]\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    @GwtIncompatible(\"incompatible method\")\n    protected String getShortClassName(final java.lang.Class<?> cls) {\n        Class<? extends Annotation> annotationType = null;\n        for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {\n            if (Annotation.class.isAssignableFrom(iface)) {\n                // OK because we just checked the assignability\n                @SuppressWarnings(\"unchecked\")\n                final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;\n                annotationType = found;\n                break;\n            }\n        }\n        return new StringBuilder(annotationType == null ? StringUtils.EMPTY : annotationType.getName()).insert(0, '@').toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    @GwtIncompatible(\"incompatible method\")\n    protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {\n        if (value instanceof Annotation) {\n            value = AnnotationUtils.toString((Annotation) value);\n        }\n        super.appendDetail(buffer, fieldName, value);\n    }\n};",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "3",
      "Filed": "",
      "Parameter_type": "Class<?>",
      "Import_statements": "import java.lang.annotation.Annotation;\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "public_method_signature": "public AnnotationUtils();\npublic static boolean equals(final Annotation a1, final Annotation a2);\npublic static int hashCode(final Annotation a);\npublic static String toString(final Annotation a);\npublic static boolean isValidAnnotationMemberType(Class<?> type);",
      "public_field": "",
      "Method_statement": "isValidAnnotationMemberType(Class<?> type)",
      "Method_name": "isValidAnnotationMemberType",
      "Class_declaration": "public class AnnotationUtils {\n",
      "constructors": "public AnnotationUtils() {\n}",
      "all_method_signature": "public AnnotationUtils();\npublic static boolean equals(final Annotation a1, final Annotation a2);\npublic static int hashCode(final Annotation a);\npublic static String toString(final Annotation a);\npublic static boolean isValidAnnotationMemberType(Class<?> type);\nprivate static int hashMember(final String name, final Object value);\nprivate static boolean memberEquals(final Class<?> type, final Object o1, final Object o2);\nprivate static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2);\nprivate static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2);\nprivate static int arrayMemberHash(final Class<?> componentType, final Object o);",
      "Class_name": "AnnotationUtils",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/AnnotationUtils###isValidAnnotationMemberType",
      "Parameter_num": "1",
      "all_Import_statements": "import java.lang.annotation.Annotation;\n\nimport java.lang.reflect.InvocationTargetException;\n\nimport java.lang.reflect.Method;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.lang3.builder.ToStringBuilder;\n\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>Checks if the specified type is permitted as an annotation member.</p>\n     *\n     * <p>The Java language specification only permits certain types to be used\n     * in annotations. These include {@link String}, {@link Class}, primitive\n     * types, {@link Annotation}, {@link Enum}, and single-dimensional arrays of\n     * these types.</p>\n     *\n     * @param type the type to check, {@code null}\n     * @return {@code true} if the type is a valid type to use in an annotation\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static boolean isValidAnnotationMemberType(Class<?> type);",
      "Junit_version": "4",
      "returnType": "boolean"
    },
    "Test_method": {
      "Method_body": "for (final Class<?> type : new Class[] { byte.class, short.class, int.class, char.class, long.class, float.class, double.class, boolean.class, String.class, Class.class, NestAnnotation.class, TestAnnotation.class, Stooge.class, ElementType.class }) {\n    assertTrue(AnnotationUtils.isValidAnnotationMemberType(type));\n    assertTrue(AnnotationUtils.isValidAnnotationMemberType(Array.newInstance(type, 0).getClass()));\n}\n\rfor (final Class<?> type : new Class[] { Object.class, Map.class, Collection.class }) {\n    assertFalse(AnnotationUtils.isValidAnnotationMemberType(type));\n    assertFalse(AnnotationUtils.isValidAnnotationMemberType(Array.newInstance(type, 0).getClass()));\n}",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "2",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport java.lang.annotation.ElementType;\nimport java.lang.reflect.Array;\nimport java.util.Collection;\nimport java.util.Map;\nimport org.junit.Test;\n",
      "allMethod_info": "@Test\npublic void testIsValidAnnotationMemberType() {\n    for (final Class<?> type : new Class[] { byte.class, short.class, int.class, char.class, long.class, float.class, double.class, boolean.class, String.class, Class.class, NestAnnotation.class, TestAnnotation.class, Stooge.class, ElementType.class }) {\n        assertTrue(AnnotationUtils.isValidAnnotationMemberType(type));\n        assertTrue(AnnotationUtils.isValidAnnotationMemberType(Array.newInstance(type, 0).getClass()));\n    }\n    for (final Class<?> type : new Class[] { Object.class, Map.class, Collection.class }) {\n        assertFalse(AnnotationUtils.isValidAnnotationMemberType(type));\n        assertFalse(AnnotationUtils.isValidAnnotationMemberType(Array.newInstance(type, 0).getClass()));\n    }\n}",
      "Method_name": "testIsValidAnnotationMemberType",
      "Class_declaration": "public class AnnotationUtilsTest {\n",
      "constructors": "",
      "Class_name": "AnnotationUtilsTest",
      "methodName_paraNum": "[isValidAnnotationMemberType(1), isValidAnnotationMemberType(1), getClass(0), newInstance(2), isValidAnnotationMemberType(1), isValidAnnotationMemberType(1), getClass(0), newInstance(2)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/AnnotationUtilsTest###testIsValidAnnotationMemberType",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/AnnotationUtilsTest.java",
      "Signature": "public void testIsValidAnnotationMemberType() {\n",
      "all_Import_statements": "import static java.lang.annotation.ElementType.FIELD;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.lang.annotation.ElementType;\n\nimport java.lang.annotation.Retention;\n\nimport java.lang.annotation.Target;\n\nimport java.lang.reflect.Array;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.InvocationHandler;\n\nimport java.lang.reflect.Method;\n\nimport java.lang.reflect.Proxy;\n\nimport java.util.Collection;\n\nimport java.util.Map;\n\nimport org.junit.Before;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@GwtIncompatible(\"incompatible method\")\npublic static String toString(final Annotation a) {\n    final ToStringBuilder builder = new ToStringBuilder(a, TO_STRING_STYLE);\n    for (final Method m : a.annotationType().getDeclaredMethods()) {\n        if (m.getParameterTypes().length > 0) {\n            continue;\n        }\n        try {\n            builder.append(m.getName(), m.invoke(a));\n        } catch (final RuntimeException ex) {\n            throw ex;\n        } catch (final Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n    return builder.build();\n}",
      "all_field_declaration": "/**\n * A style that prints annotations as recommended.\n */\nprivate static final ToStringStyle TO_STRING_STYLE = new ToStringStyle() {\n\n    /**\n     * Serialization version\n     */\n    private static final long serialVersionUID = 1L;\n\n    {\n        setDefaultFullDetail(true);\n        setArrayContentDetail(true);\n        setUseClassName(true);\n        setUseShortClassName(true);\n        setUseIdentityHashCode(false);\n        setContentStart(\"(\");\n        setContentEnd(\")\");\n        setFieldSeparator(\", \");\n        setArrayStart(\"[\");\n        setArrayEnd(\"]\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    @GwtIncompatible(\"incompatible method\")\n    protected String getShortClassName(final java.lang.Class<?> cls) {\n        Class<? extends Annotation> annotationType = null;\n        for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {\n            if (Annotation.class.isAssignableFrom(iface)) {\n                // OK because we just checked the assignability\n                @SuppressWarnings(\"unchecked\")\n                final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;\n                annotationType = found;\n                break;\n            }\n        }\n        return new StringBuilder(annotationType == null ? StringUtils.EMPTY : annotationType.getName()).insert(0, '@').toString();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    @GwtIncompatible(\"incompatible method\")\n    protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {\n        if (value instanceof Annotation) {\n            value = AnnotationUtils.toString((Annotation) value);\n        }\n        super.appendDetail(buffer, fieldName, value);\n    }\n};",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "3",
      "Filed": "private static final ToStringStyle TO_STRING_STYLE = new ToStringStyle() {\n\n    private static final long serialVersionUID = 1L;\n\n    {\n        setDefaultFullDetail(true);\n        setArrayContentDetail(true);\n        setUseClassName(true);\n        setUseShortClassName(true);\n        setUseIdentityHashCode(false);\n        setContentStart(\"(\");\n        setContentEnd(\")\");\n        setFieldSeparator(\", \");\n        setArrayStart(\"[\");\n        setArrayEnd(\"]\");\n    }\n\n    @Override\n    @GwtIncompatible(\"incompatible method\")\n    protected String getShortClassName(final java.lang.Class<?> cls) {\n        Class<? extends Annotation> annotationType = null;\n        for (final Class<?> iface : ClassUtils.getAllInterfaces(cls)) {\n            if (Annotation.class.isAssignableFrom(iface)) {\n                @SuppressWarnings(\"unchecked\")\n                final Class<? extends Annotation> found = (Class<? extends Annotation>) iface;\n                annotationType = found;\n                break;\n            }\n        }\n        return new StringBuilder(annotationType == null ? StringUtils.EMPTY : annotationType.getName()).insert(0, '@').toString();\n    }\n\n    @Override\n    @GwtIncompatible(\"incompatible method\")\n    protected void appendDetail(final StringBuffer buffer, final String fieldName, Object value) {\n        if (value instanceof Annotation) {\n            value = AnnotationUtils.toString((Annotation) value);\n        }\n        super.appendDetail(buffer, fieldName, value);\n    }\n};",
      "Parameter_type": "Annotation",
      "Import_statements": "import java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "public_method_signature": "public AnnotationUtils();\npublic static boolean equals(final Annotation a1, final Annotation a2);\npublic static int hashCode(final Annotation a);\npublic static String toString(final Annotation a);\npublic static boolean isValidAnnotationMemberType(Class<?> type);",
      "public_field": "",
      "Method_statement": "toString(final Annotation a)",
      "Method_name": "toString",
      "Class_declaration": "public class AnnotationUtils {\n",
      "constructors": "public AnnotationUtils() {\n}",
      "all_method_signature": "public AnnotationUtils();\npublic static boolean equals(final Annotation a1, final Annotation a2);\npublic static int hashCode(final Annotation a);\npublic static String toString(final Annotation a);\npublic static boolean isValidAnnotationMemberType(Class<?> type);\nprivate static int hashMember(final String name, final Object value);\nprivate static boolean memberEquals(final Class<?> type, final Object o1, final Object o2);\nprivate static boolean arrayMemberEquals(final Class<?> componentType, final Object o1, final Object o2);\nprivate static boolean annotationArrayMemberEquals(final Annotation[] a1, final Annotation[] a2);\nprivate static int arrayMemberHash(final Class<?> componentType, final Object o);",
      "Class_name": "AnnotationUtils",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/AnnotationUtils###toString",
      "Parameter_num": "1",
      "all_Import_statements": "import java.lang.annotation.Annotation;\n\nimport java.lang.reflect.InvocationTargetException;\n\nimport java.lang.reflect.Method;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.lang3.builder.ToStringBuilder;\n\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>Generate a string representation of an Annotation, as suggested by\n     * {@link Annotation#toString()}.</p>\n     *\n     * @param a the annotation of which a string representation is desired\n     * @return the standard string representation of an annotation, not\n     * {@code null}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static String toString(final Annotation a);",
      "Junit_version": "4",
      "returnType": "String"
    },
    "Test_method": {
      "Method_body": "final Test testAnnotation = getClass().getDeclaredMethod(\"testToString\").getAnnotation(Test.class);\n\rfinal String annotationString = AnnotationUtils.toString(testAnnotation);\n\rassertTrue(annotationString.startsWith(\"@org.junit.Test(\"));\n\rassertTrue(annotationString.endsWith(\")\"));\n\rassertTrue(annotationString.contains(\"expected=class org.junit.Test$None\"));\n\rassertTrue(annotationString.contains(\"timeout=666000\"));\n\rassertTrue(annotationString.contains(\", \"));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "7",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertTrue;\nimport java.lang.reflect.Method;\nimport org.junit.Test;\n",
      "allMethod_info": "@Test(timeout = 666000)\npublic void testToString() throws Exception {\n    final Test testAnnotation = getClass().getDeclaredMethod(\"testToString\").getAnnotation(Test.class);\n    final String annotationString = AnnotationUtils.toString(testAnnotation);\n    assertTrue(annotationString.startsWith(\"@org.junit.Test(\"));\n    assertTrue(annotationString.endsWith(\")\"));\n    assertTrue(annotationString.contains(\"expected=class org.junit.Test$None\"));\n    assertTrue(annotationString.contains(\"timeout=666000\"));\n    assertTrue(annotationString.contains(\", \"));\n}",
      "Method_name": "testToString",
      "Class_declaration": "public class AnnotationUtilsTest {\n",
      "constructors": "",
      "Class_name": "AnnotationUtilsTest",
      "methodName_paraNum": "[getAnnotation(1), getDeclaredMethod(1), getClass(0), toString(1), startsWith(1), endsWith(1), contains(1), contains(1), contains(1)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/AnnotationUtilsTest###testToString",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/AnnotationUtilsTest.java",
      "Signature": "public void testToString() {\n",
      "all_Import_statements": "import static java.lang.annotation.ElementType.FIELD;\n\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.lang.annotation.ElementType;\n\nimport java.lang.annotation.Retention;\n\nimport java.lang.annotation.Target;\n\nimport java.lang.reflect.Array;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.InvocationHandler;\n\nimport java.lang.reflect.Method;\n\nimport java.lang.reflect.Proxy;\n\nimport java.util.Collection;\n\nimport java.util.Map;\n\nimport org.junit.Before;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static boolean[] clone(final boolean[] array) {\n    if (array == null) {\n        return null;\n    }\n    final boolean[] arrayClone = new boolean[array.length];\n    System.arraycopy(array, 0, arrayClone, 0, array.length);\n    return arrayClone;\n}",
      "all_field_declaration": "/**\n * An empty immutable {@code Object} array.\n */\npublic static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n * An empty immutable {@code Class} array.\n */\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n * An empty immutable {@code String} array.\n */\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n * An empty immutable {@code long} array.\n */\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n * An empty immutable {@code Long} array.\n */\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n * An empty immutable {@code int} array.\n */\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n * An empty immutable {@code Integer} array.\n */\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n * An empty immutable {@code short} array.\n */\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n * An empty immutable {@code Short} array.\n */\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n * An empty immutable {@code byte} array.\n */\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n * An empty immutable {@code Byte} array.\n */\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n * An empty immutable {@code double} array.\n */\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n * An empty immutable {@code Double} array.\n */\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n * An empty immutable {@code float} array.\n */\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n * An empty immutable {@code Float} array.\n */\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n * An empty immutable {@code boolean} array.\n */\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n * An empty immutable {@code Boolean} array.\n */\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n * An empty immutable {@code char} array.\n */\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n * An empty immutable {@code Character} array.\n */\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n/**\n * The index value when an element is not found in a list or array: {@code -1}.\n * This value is returned by methods in this class and can also be used in comparisons with values returned by\n * various method from {@link java.util.List}.\n */\npublic static final int INDEX_NOT_FOUND = -1;",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "boolean[]",
      "Import_statements": "",
      "public_method_signature": "public ArrayUtils();\npublic static String toString(final Object array);\npublic static String toString(final Object array, final String stringIfNull);\npublic static int hashCode(final Object array);\npublic static boolean isEquals(final Object array1, final Object array2);\npublic static Map<Object, Object> toMap(final Object[] array);\npublic static T[] toArray(final T... items);\npublic static T[] clone(final T[] array);\npublic static long[] clone(final long[] array);\npublic static int[] clone(final int[] array);\npublic static short[] clone(final short[] array);\npublic static char[] clone(final char[] array);\npublic static byte[] clone(final byte[] array);\npublic static double[] clone(final double[] array);\npublic static float[] clone(final float[] array);\npublic static boolean[] clone(final boolean[] array);\npublic static T[] nullToEmpty(final T[] array, final Class<T[]> type);\npublic static Object[] nullToEmpty(final Object[] array);\npublic static Class<?>[] nullToEmpty(final Class<?>[] array);\npublic static String[] nullToEmpty(final String[] array);\npublic static long[] nullToEmpty(final long[] array);\npublic static int[] nullToEmpty(final int[] array);\npublic static short[] nullToEmpty(final short[] array);\npublic static char[] nullToEmpty(final char[] array);\npublic static byte[] nullToEmpty(final byte[] array);\npublic static double[] nullToEmpty(final double[] array);\npublic static float[] nullToEmpty(final float[] array);\npublic static boolean[] nullToEmpty(final boolean[] array);\npublic static Long[] nullToEmpty(final Long[] array);\npublic static Integer[] nullToEmpty(final Integer[] array);\npublic static Short[] nullToEmpty(final Short[] array);\npublic static Character[] nullToEmpty(final Character[] array);\npublic static Byte[] nullToEmpty(final Byte[] array);\npublic static Double[] nullToEmpty(final Double[] array);\npublic static Float[] nullToEmpty(final Float[] array);\npublic static Boolean[] nullToEmpty(final Boolean[] array);\npublic static T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive);\npublic static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive);\npublic static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive);\npublic static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive);\npublic static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive);\npublic static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive);\npublic static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive);\npublic static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive);\npublic static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive);\npublic static boolean isSameLength(final Object[] array1, final Object[] array2);\npublic static boolean isSameLength(final long[] array1, final long[] array2);\npublic static boolean isSameLength(final int[] array1, final int[] array2);\npublic static boolean isSameLength(final short[] array1, final short[] array2);\npublic static boolean isSameLength(final char[] array1, final char[] array2);\npublic static boolean isSameLength(final byte[] array1, final byte[] array2);\npublic static boolean isSameLength(final double[] array1, final double[] array2);\npublic static boolean isSameLength(final float[] array1, final float[] array2);\npublic static boolean isSameLength(final boolean[] array1, final boolean[] array2);\npublic static int getLength(final Object array);\npublic static boolean isSameType(final Object array1, final Object array2);\npublic static void reverse(final Object[] array);\npublic static void reverse(final long[] array);\npublic static void reverse(final int[] array);\npublic static void reverse(final short[] array);\npublic static void reverse(final char[] array);\npublic static void reverse(final byte[] array);\npublic static void reverse(final double[] array);\npublic static void reverse(final float[] array);\npublic static void reverse(final boolean[] array);\npublic static void reverse(final boolean[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final byte[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final char[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final double[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final float[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final int[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final long[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final Object[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final short[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void swap(final Object[] array, final int offset1, final int offset2);\npublic static void swap(final long[] array, final int offset1, final int offset2);\npublic static void swap(final int[] array, final int offset1, final int offset2);\npublic static void swap(final short[] array, final int offset1, final int offset2);\npublic static void swap(final char[] array, final int offset1, final int offset2);\npublic static void swap(final byte[] array, final int offset1, final int offset2);\npublic static void swap(final double[] array, final int offset1, final int offset2);\npublic static void swap(final float[] array, final int offset1, final int offset2);\npublic static void swap(final boolean[] array, final int offset1, final int offset2);\npublic static void swap(final boolean[] array, int offset1, int offset2, int len);\npublic static void swap(final byte[] array, int offset1, int offset2, int len);\npublic static void swap(final char[] array, int offset1, int offset2, int len);\npublic static void swap(final double[] array, int offset1, int offset2, int len);\npublic static void swap(final float[] array, int offset1, int offset2, int len);\npublic static void swap(final int[] array, int offset1, int offset2, int len);\npublic static void swap(final long[] array, int offset1, int offset2, int len);\npublic static void swap(final Object[] array, int offset1, int offset2, int len);\npublic static void swap(final short[] array, int offset1, int offset2, int len);\npublic static void shift(final Object[] array, final int offset);\npublic static void shift(final long[] array, final int offset);\npublic static void shift(final int[] array, final int offset);\npublic static void shift(final short[] array, final int offset);\npublic static void shift(final char[] array, final int offset);\npublic static void shift(final byte[] array, final int offset);\npublic static void shift(final double[] array, final int offset);\npublic static void shift(final float[] array, final int offset);\npublic static void shift(final boolean[] array, final int offset);\npublic static void shift(final boolean[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final byte[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final char[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final double[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final float[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final int[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final long[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final Object[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final short[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static int indexOf(final Object[] array, final Object objectToFind);\npublic static int indexOf(final Object[] array, final Object objectToFind, int startIndex);\npublic static int lastIndexOf(final Object[] array, final Object objectToFind);\npublic static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex);\npublic static boolean contains(final Object[] array, final Object objectToFind);\npublic static int indexOf(final long[] array, final long valueToFind);\npublic static int indexOf(final long[] array, final long valueToFind, int startIndex);\npublic static int lastIndexOf(final long[] array, final long valueToFind);\npublic static int lastIndexOf(final long[] array, final long valueToFind, int startIndex);\npublic static boolean contains(final long[] array, final long valueToFind);\npublic static int indexOf(final int[] array, final int valueToFind);\npublic static int indexOf(final int[] array, final int valueToFind, int startIndex);\npublic static int lastIndexOf(final int[] array, final int valueToFind);\npublic static int lastIndexOf(final int[] array, final int valueToFind, int startIndex);\npublic static boolean contains(final int[] array, final int valueToFind);\npublic static int indexOf(final short[] array, final short valueToFind);\npublic static int indexOf(final short[] array, final short valueToFind, int startIndex);\npublic static int lastIndexOf(final short[] array, final short valueToFind);\npublic static int lastIndexOf(final short[] array, final short valueToFind, int startIndex);\npublic static boolean contains(final short[] array, final short valueToFind);\npublic static int indexOf(final char[] array, final char valueToFind);\npublic static int indexOf(final char[] array, final char valueToFind, int startIndex);\npublic static int lastIndexOf(final char[] array, final char valueToFind);\npublic static int lastIndexOf(final char[] array, final char valueToFind, int startIndex);\npublic static boolean contains(final char[] array, final char valueToFind);\npublic static int indexOf(final byte[] array, final byte valueToFind);\npublic static int indexOf(final byte[] array, final byte valueToFind, int startIndex);\npublic static int lastIndexOf(final byte[] array, final byte valueToFind);\npublic static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex);\npublic static boolean contains(final byte[] array, final byte valueToFind);\npublic static int indexOf(final double[] array, final double valueToFind);\npublic static int indexOf(final double[] array, final double valueToFind, final double tolerance);\npublic static int indexOf(final double[] array, final double valueToFind, int startIndex);\npublic static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance);\npublic static int lastIndexOf(final double[] array, final double valueToFind);\npublic static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance);\npublic static int lastIndexOf(final double[] array, final double valueToFind, int startIndex);\npublic static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance);\npublic static boolean contains(final double[] array, final double valueToFind);\npublic static boolean contains(final double[] array, final double valueToFind, final double tolerance);\npublic static int indexOf(final float[] array, final float valueToFind);\npublic static int indexOf(final float[] array, final float valueToFind, int startIndex);\npublic static int lastIndexOf(final float[] array, final float valueToFind);\npublic static int lastIndexOf(final float[] array, final float valueToFind, int startIndex);\npublic static boolean contains(final float[] array, final float valueToFind);\npublic static int indexOf(final boolean[] array, final boolean valueToFind);\npublic static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex);\npublic static int lastIndexOf(final boolean[] array, final boolean valueToFind);\npublic static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex);\npublic static boolean contains(final boolean[] array, final boolean valueToFind);\npublic static char[] toPrimitive(final Character[] array);\npublic static char[] toPrimitive(final Character[] array, final char valueForNull);\npublic static Character[] toObject(final char[] array);\npublic static long[] toPrimitive(final Long[] array);\npublic static long[] toPrimitive(final Long[] array, final long valueForNull);\npublic static Long[] toObject(final long[] array);\npublic static int[] toPrimitive(final Integer[] array);\npublic static int[] toPrimitive(final Integer[] array, final int valueForNull);\npublic static Integer[] toObject(final int[] array);\npublic static short[] toPrimitive(final Short[] array);\npublic static short[] toPrimitive(final Short[] array, final short valueForNull);\npublic static Short[] toObject(final short[] array);\npublic static byte[] toPrimitive(final Byte[] array);\npublic static byte[] toPrimitive(final Byte[] array, final byte valueForNull);\npublic static Byte[] toObject(final byte[] array);\npublic static double[] toPrimitive(final Double[] array);\npublic static double[] toPrimitive(final Double[] array, final double valueForNull);\npublic static Double[] toObject(final double[] array);\npublic static float[] toPrimitive(final Float[] array);\npublic static float[] toPrimitive(final Float[] array, final float valueForNull);\npublic static Float[] toObject(final float[] array);\npublic static Object toPrimitive(final Object array);\npublic static boolean[] toPrimitive(final Boolean[] array);\npublic static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull);\npublic static Boolean[] toObject(final boolean[] array);\npublic static boolean isEmpty(final Object[] array);\npublic static boolean isEmpty(final long[] array);\npublic static boolean isEmpty(final int[] array);\npublic static boolean isEmpty(final short[] array);\npublic static boolean isEmpty(final char[] array);\npublic static boolean isEmpty(final byte[] array);\npublic static boolean isEmpty(final double[] array);\npublic static boolean isEmpty(final float[] array);\npublic static boolean isEmpty(final boolean[] array);\npublic static boolean isNotEmpty(final T[] array);\npublic static boolean isNotEmpty(final long[] array);\npublic static boolean isNotEmpty(final int[] array);\npublic static boolean isNotEmpty(final short[] array);\npublic static boolean isNotEmpty(final char[] array);\npublic static boolean isNotEmpty(final byte[] array);\npublic static boolean isNotEmpty(final double[] array);\npublic static boolean isNotEmpty(final float[] array);\npublic static boolean isNotEmpty(final boolean[] array);\npublic static T[] addAll(final T[] array1, final T... array2);\npublic static boolean[] addAll(final boolean[] array1, final boolean... array2);\npublic static char[] addAll(final char[] array1, final char... array2);\npublic static byte[] addAll(final byte[] array1, final byte... array2);\npublic static short[] addAll(final short[] array1, final short... array2);\npublic static int[] addAll(final int[] array1, final int... array2);\npublic static long[] addAll(final long[] array1, final long... array2);\npublic static float[] addAll(final float[] array1, final float... array2);\npublic static double[] addAll(final double[] array1, final double... array2);\npublic static T[] add(final T[] array, final T element);\npublic static boolean[] add(final boolean[] array, final boolean element);\npublic static byte[] add(final byte[] array, final byte element);\npublic static char[] add(final char[] array, final char element);\npublic static double[] add(final double[] array, final double element);\npublic static float[] add(final float[] array, final float element);\npublic static int[] add(final int[] array, final int element);\npublic static long[] add(final long[] array, final long element);\npublic static short[] add(final short[] array, final short element);\npublic static T[] add(final T[] array, final int index, final T element);\npublic static boolean[] add(final boolean[] array, final int index, final boolean element);\npublic static char[] add(final char[] array, final int index, final char element);\npublic static byte[] add(final byte[] array, final int index, final byte element);\npublic static short[] add(final short[] array, final int index, final short element);\npublic static int[] add(final int[] array, final int index, final int element);\npublic static long[] add(final long[] array, final int index, final long element);\npublic static float[] add(final float[] array, final int index, final float element);\npublic static double[] add(final double[] array, final int index, final double element);\npublic static T[] remove(final T[] array, final int index);\npublic static T[] removeElement(final T[] array, final Object element);\npublic static boolean[] remove(final boolean[] array, final int index);\npublic static boolean[] removeElement(final boolean[] array, final boolean element);\npublic static byte[] remove(final byte[] array, final int index);\npublic static byte[] removeElement(final byte[] array, final byte element);\npublic static char[] remove(final char[] array, final int index);\npublic static char[] removeElement(final char[] array, final char element);\npublic static double[] remove(final double[] array, final int index);\npublic static double[] removeElement(final double[] array, final double element);\npublic static float[] remove(final float[] array, final int index);\npublic static float[] removeElement(final float[] array, final float element);\npublic static int[] remove(final int[] array, final int index);\npublic static int[] removeElement(final int[] array, final int element);\npublic static long[] remove(final long[] array, final int index);\npublic static long[] removeElement(final long[] array, final long element);\npublic static short[] remove(final short[] array, final int index);\npublic static short[] removeElement(final short[] array, final short element);\npublic static T[] removeAll(final T[] array, final int... indices);\npublic static T[] removeElements(final T[] array, final T... values);\npublic static byte[] removeAll(final byte[] array, final int... indices);\npublic static byte[] removeElements(final byte[] array, final byte... values);\npublic static short[] removeAll(final short[] array, final int... indices);\npublic static short[] removeElements(final short[] array, final short... values);\npublic static int[] removeAll(final int[] array, final int... indices);\npublic static int[] removeElements(final int[] array, final int... values);\npublic static char[] removeAll(final char[] array, final int... indices);\npublic static char[] removeElements(final char[] array, final char... values);\npublic static long[] removeAll(final long[] array, final int... indices);\npublic static long[] removeElements(final long[] array, final long... values);\npublic static float[] removeAll(final float[] array, final int... indices);\npublic static float[] removeElements(final float[] array, final float... values);\npublic static double[] removeAll(final double[] array, final int... indices);\npublic static double[] removeElements(final double[] array, final double... values);\npublic static boolean[] removeAll(final boolean[] array, final int... indices);\npublic static boolean[] removeElements(final boolean[] array, final boolean... values);\npublic static boolean isSorted(final T[] array);\npublic static boolean isSorted(final T[] array, final Comparator<T> comparator);\npublic static boolean isSorted(final int[] array);\npublic static boolean isSorted(final long[] array);\npublic static boolean isSorted(final short[] array);\npublic static boolean isSorted(final double[] array);\npublic static boolean isSorted(final float[] array);\npublic static boolean isSorted(final byte[] array);\npublic static boolean isSorted(final char[] array);\npublic static boolean isSorted(final boolean[] array);\npublic static boolean[] removeAllOccurences(final boolean[] array, final boolean element);\npublic static char[] removeAllOccurences(final char[] array, final char element);\npublic static byte[] removeAllOccurences(final byte[] array, final byte element);\npublic static short[] removeAllOccurences(final short[] array, final short element);\npublic static int[] removeAllOccurences(final int[] array, final int element);\npublic static long[] removeAllOccurences(final long[] array, final long element);\npublic static float[] removeAllOccurences(final float[] array, final float element);\npublic static double[] removeAllOccurences(final double[] array, final double element);\npublic static T[] removeAllOccurences(final T[] array, final T element);\npublic static String[] toStringArray(final Object[] array);\npublic static String[] toStringArray(final Object[] array, final String valueForNullElements);\npublic static boolean[] insert(final int index, final boolean[] array, final boolean... values);\npublic static byte[] insert(final int index, final byte[] array, final byte... values);\npublic static char[] insert(final int index, final char[] array, final char... values);\npublic static double[] insert(final int index, final double[] array, final double... values);\npublic static float[] insert(final int index, final float[] array, final float... values);\npublic static int[] insert(final int index, final int[] array, final int... values);\npublic static long[] insert(final int index, final long[] array, final long... values);\npublic static short[] insert(final int index, final short[] array, final short... values);\npublic static T[] insert(final int index, final T[] array, final T... values);\npublic static void shuffle(final Object[] array);\npublic static void shuffle(final Object[] array, final Random random);\npublic static void shuffle(final boolean[] array);\npublic static void shuffle(final boolean[] array, final Random random);\npublic static void shuffle(final byte[] array);\npublic static void shuffle(final byte[] array, final Random random);\npublic static void shuffle(final char[] array);\npublic static void shuffle(final char[] array, final Random random);\npublic static void shuffle(final short[] array);\npublic static void shuffle(final short[] array, final Random random);\npublic static void shuffle(final int[] array);\npublic static void shuffle(final int[] array, final Random random);\npublic static void shuffle(final long[] array);\npublic static void shuffle(final long[] array, final Random random);\npublic static void shuffle(final float[] array);\npublic static void shuffle(final float[] array, final Random random);\npublic static void shuffle(final double[] array);\npublic static void shuffle(final double[] array, final Random random);",
      "public_field": "/**\n * An empty immutable {@code Object} array.\n */\npublic static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n * An empty immutable {@code Class} array.\n */\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n * An empty immutable {@code String} array.\n */\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n * An empty immutable {@code long} array.\n */\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n * An empty immutable {@code Long} array.\n */\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n * An empty immutable {@code int} array.\n */\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n * An empty immutable {@code Integer} array.\n */\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n * An empty immutable {@code short} array.\n */\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n * An empty immutable {@code Short} array.\n */\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n * An empty immutable {@code byte} array.\n */\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n * An empty immutable {@code Byte} array.\n */\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n * An empty immutable {@code double} array.\n */\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n * An empty immutable {@code Double} array.\n */\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n * An empty immutable {@code float} array.\n */\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n * An empty immutable {@code Float} array.\n */\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n * An empty immutable {@code boolean} array.\n */\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n * An empty immutable {@code Boolean} array.\n */\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n * An empty immutable {@code char} array.\n */\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n * An empty immutable {@code Character} array.\n */\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n/**\n * The index value when an element is not found in a list or array: {@code -1}.\n * This value is returned by methods in this class and can also be used in comparisons with values returned by\n * various method from {@link java.util.List}.\n */\npublic static final int INDEX_NOT_FOUND = -1;",
      "Method_statement": "clone(final boolean() array)",
      "Method_name": "clone",
      "Class_declaration": "public class ArrayUtils {\n",
      "constructors": "public ArrayUtils() {\n    super();\n}",
      "all_method_signature": "public ArrayUtils();\npublic static String toString(final Object array);\npublic static String toString(final Object array, final String stringIfNull);\npublic static int hashCode(final Object array);\npublic static boolean isEquals(final Object array1, final Object array2);\npublic static Map<Object, Object> toMap(final Object[] array);\npublic static T[] toArray(final T... items);\npublic static T[] clone(final T[] array);\npublic static long[] clone(final long[] array);\npublic static int[] clone(final int[] array);\npublic static short[] clone(final short[] array);\npublic static char[] clone(final char[] array);\npublic static byte[] clone(final byte[] array);\npublic static double[] clone(final double[] array);\npublic static float[] clone(final float[] array);\npublic static boolean[] clone(final boolean[] array);\npublic static T[] nullToEmpty(final T[] array, final Class<T[]> type);\npublic static Object[] nullToEmpty(final Object[] array);\npublic static Class<?>[] nullToEmpty(final Class<?>[] array);\npublic static String[] nullToEmpty(final String[] array);\npublic static long[] nullToEmpty(final long[] array);\npublic static int[] nullToEmpty(final int[] array);\npublic static short[] nullToEmpty(final short[] array);\npublic static char[] nullToEmpty(final char[] array);\npublic static byte[] nullToEmpty(final byte[] array);\npublic static double[] nullToEmpty(final double[] array);\npublic static float[] nullToEmpty(final float[] array);\npublic static boolean[] nullToEmpty(final boolean[] array);\npublic static Long[] nullToEmpty(final Long[] array);\npublic static Integer[] nullToEmpty(final Integer[] array);\npublic static Short[] nullToEmpty(final Short[] array);\npublic static Character[] nullToEmpty(final Character[] array);\npublic static Byte[] nullToEmpty(final Byte[] array);\npublic static Double[] nullToEmpty(final Double[] array);\npublic static Float[] nullToEmpty(final Float[] array);\npublic static Boolean[] nullToEmpty(final Boolean[] array);\npublic static T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive);\npublic static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive);\npublic static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive);\npublic static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive);\npublic static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive);\npublic static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive);\npublic static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive);\npublic static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive);\npublic static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive);\npublic static boolean isSameLength(final Object[] array1, final Object[] array2);\npublic static boolean isSameLength(final long[] array1, final long[] array2);\npublic static boolean isSameLength(final int[] array1, final int[] array2);\npublic static boolean isSameLength(final short[] array1, final short[] array2);\npublic static boolean isSameLength(final char[] array1, final char[] array2);\npublic static boolean isSameLength(final byte[] array1, final byte[] array2);\npublic static boolean isSameLength(final double[] array1, final double[] array2);\npublic static boolean isSameLength(final float[] array1, final float[] array2);\npublic static boolean isSameLength(final boolean[] array1, final boolean[] array2);\npublic static int getLength(final Object array);\npublic static boolean isSameType(final Object array1, final Object array2);\npublic static void reverse(final Object[] array);\npublic static void reverse(final long[] array);\npublic static void reverse(final int[] array);\npublic static void reverse(final short[] array);\npublic static void reverse(final char[] array);\npublic static void reverse(final byte[] array);\npublic static void reverse(final double[] array);\npublic static void reverse(final float[] array);\npublic static void reverse(final boolean[] array);\npublic static void reverse(final boolean[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final byte[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final char[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final double[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final float[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final int[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final long[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final Object[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final short[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void swap(final Object[] array, final int offset1, final int offset2);\npublic static void swap(final long[] array, final int offset1, final int offset2);\npublic static void swap(final int[] array, final int offset1, final int offset2);\npublic static void swap(final short[] array, final int offset1, final int offset2);\npublic static void swap(final char[] array, final int offset1, final int offset2);\npublic static void swap(final byte[] array, final int offset1, final int offset2);\npublic static void swap(final double[] array, final int offset1, final int offset2);\npublic static void swap(final float[] array, final int offset1, final int offset2);\npublic static void swap(final boolean[] array, final int offset1, final int offset2);\npublic static void swap(final boolean[] array, int offset1, int offset2, int len);\npublic static void swap(final byte[] array, int offset1, int offset2, int len);\npublic static void swap(final char[] array, int offset1, int offset2, int len);\npublic static void swap(final double[] array, int offset1, int offset2, int len);\npublic static void swap(final float[] array, int offset1, int offset2, int len);\npublic static void swap(final int[] array, int offset1, int offset2, int len);\npublic static void swap(final long[] array, int offset1, int offset2, int len);\npublic static void swap(final Object[] array, int offset1, int offset2, int len);\npublic static void swap(final short[] array, int offset1, int offset2, int len);\npublic static void shift(final Object[] array, final int offset);\npublic static void shift(final long[] array, final int offset);\npublic static void shift(final int[] array, final int offset);\npublic static void shift(final short[] array, final int offset);\npublic static void shift(final char[] array, final int offset);\npublic static void shift(final byte[] array, final int offset);\npublic static void shift(final double[] array, final int offset);\npublic static void shift(final float[] array, final int offset);\npublic static void shift(final boolean[] array, final int offset);\npublic static void shift(final boolean[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final byte[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final char[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final double[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final float[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final int[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final long[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final Object[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final short[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static int indexOf(final Object[] array, final Object objectToFind);\npublic static int indexOf(final Object[] array, final Object objectToFind, int startIndex);\npublic static int lastIndexOf(final Object[] array, final Object objectToFind);\npublic static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex);\npublic static boolean contains(final Object[] array, final Object objectToFind);\npublic static int indexOf(final long[] array, final long valueToFind);\npublic static int indexOf(final long[] array, final long valueToFind, int startIndex);\npublic static int lastIndexOf(final long[] array, final long valueToFind);\npublic static int lastIndexOf(final long[] array, final long valueToFind, int startIndex);\npublic static boolean contains(final long[] array, final long valueToFind);\npublic static int indexOf(final int[] array, final int valueToFind);\npublic static int indexOf(final int[] array, final int valueToFind, int startIndex);\npublic static int lastIndexOf(final int[] array, final int valueToFind);\npublic static int lastIndexOf(final int[] array, final int valueToFind, int startIndex);\npublic static boolean contains(final int[] array, final int valueToFind);\npublic static int indexOf(final short[] array, final short valueToFind);\npublic static int indexOf(final short[] array, final short valueToFind, int startIndex);\npublic static int lastIndexOf(final short[] array, final short valueToFind);\npublic static int lastIndexOf(final short[] array, final short valueToFind, int startIndex);\npublic static boolean contains(final short[] array, final short valueToFind);\npublic static int indexOf(final char[] array, final char valueToFind);\npublic static int indexOf(final char[] array, final char valueToFind, int startIndex);\npublic static int lastIndexOf(final char[] array, final char valueToFind);\npublic static int lastIndexOf(final char[] array, final char valueToFind, int startIndex);\npublic static boolean contains(final char[] array, final char valueToFind);\npublic static int indexOf(final byte[] array, final byte valueToFind);\npublic static int indexOf(final byte[] array, final byte valueToFind, int startIndex);\npublic static int lastIndexOf(final byte[] array, final byte valueToFind);\npublic static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex);\npublic static boolean contains(final byte[] array, final byte valueToFind);\npublic static int indexOf(final double[] array, final double valueToFind);\npublic static int indexOf(final double[] array, final double valueToFind, final double tolerance);\npublic static int indexOf(final double[] array, final double valueToFind, int startIndex);\npublic static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance);\npublic static int lastIndexOf(final double[] array, final double valueToFind);\npublic static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance);\npublic static int lastIndexOf(final double[] array, final double valueToFind, int startIndex);\npublic static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance);\npublic static boolean contains(final double[] array, final double valueToFind);\npublic static boolean contains(final double[] array, final double valueToFind, final double tolerance);\npublic static int indexOf(final float[] array, final float valueToFind);\npublic static int indexOf(final float[] array, final float valueToFind, int startIndex);\npublic static int lastIndexOf(final float[] array, final float valueToFind);\npublic static int lastIndexOf(final float[] array, final float valueToFind, int startIndex);\npublic static boolean contains(final float[] array, final float valueToFind);\npublic static int indexOf(final boolean[] array, final boolean valueToFind);\npublic static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex);\npublic static int lastIndexOf(final boolean[] array, final boolean valueToFind);\npublic static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex);\npublic static boolean contains(final boolean[] array, final boolean valueToFind);\npublic static char[] toPrimitive(final Character[] array);\npublic static char[] toPrimitive(final Character[] array, final char valueForNull);\npublic static Character[] toObject(final char[] array);\npublic static long[] toPrimitive(final Long[] array);\npublic static long[] toPrimitive(final Long[] array, final long valueForNull);\npublic static Long[] toObject(final long[] array);\npublic static int[] toPrimitive(final Integer[] array);\npublic static int[] toPrimitive(final Integer[] array, final int valueForNull);\npublic static Integer[] toObject(final int[] array);\npublic static short[] toPrimitive(final Short[] array);\npublic static short[] toPrimitive(final Short[] array, final short valueForNull);\npublic static Short[] toObject(final short[] array);\npublic static byte[] toPrimitive(final Byte[] array);\npublic static byte[] toPrimitive(final Byte[] array, final byte valueForNull);\npublic static Byte[] toObject(final byte[] array);\npublic static double[] toPrimitive(final Double[] array);\npublic static double[] toPrimitive(final Double[] array, final double valueForNull);\npublic static Double[] toObject(final double[] array);\npublic static float[] toPrimitive(final Float[] array);\npublic static float[] toPrimitive(final Float[] array, final float valueForNull);\npublic static Float[] toObject(final float[] array);\npublic static Object toPrimitive(final Object array);\npublic static boolean[] toPrimitive(final Boolean[] array);\npublic static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull);\npublic static Boolean[] toObject(final boolean[] array);\npublic static boolean isEmpty(final Object[] array);\npublic static boolean isEmpty(final long[] array);\npublic static boolean isEmpty(final int[] array);\npublic static boolean isEmpty(final short[] array);\npublic static boolean isEmpty(final char[] array);\npublic static boolean isEmpty(final byte[] array);\npublic static boolean isEmpty(final double[] array);\npublic static boolean isEmpty(final float[] array);\npublic static boolean isEmpty(final boolean[] array);\npublic static boolean isNotEmpty(final T[] array);\npublic static boolean isNotEmpty(final long[] array);\npublic static boolean isNotEmpty(final int[] array);\npublic static boolean isNotEmpty(final short[] array);\npublic static boolean isNotEmpty(final char[] array);\npublic static boolean isNotEmpty(final byte[] array);\npublic static boolean isNotEmpty(final double[] array);\npublic static boolean isNotEmpty(final float[] array);\npublic static boolean isNotEmpty(final boolean[] array);\npublic static T[] addAll(final T[] array1, final T... array2);\npublic static boolean[] addAll(final boolean[] array1, final boolean... array2);\npublic static char[] addAll(final char[] array1, final char... array2);\npublic static byte[] addAll(final byte[] array1, final byte... array2);\npublic static short[] addAll(final short[] array1, final short... array2);\npublic static int[] addAll(final int[] array1, final int... array2);\npublic static long[] addAll(final long[] array1, final long... array2);\npublic static float[] addAll(final float[] array1, final float... array2);\npublic static double[] addAll(final double[] array1, final double... array2);\npublic static T[] add(final T[] array, final T element);\npublic static boolean[] add(final boolean[] array, final boolean element);\npublic static byte[] add(final byte[] array, final byte element);\npublic static char[] add(final char[] array, final char element);\npublic static double[] add(final double[] array, final double element);\npublic static float[] add(final float[] array, final float element);\npublic static int[] add(final int[] array, final int element);\npublic static long[] add(final long[] array, final long element);\npublic static short[] add(final short[] array, final short element);\nprivate static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType);\npublic static T[] add(final T[] array, final int index, final T element);\npublic static boolean[] add(final boolean[] array, final int index, final boolean element);\npublic static char[] add(final char[] array, final int index, final char element);\npublic static byte[] add(final byte[] array, final int index, final byte element);\npublic static short[] add(final short[] array, final int index, final short element);\npublic static int[] add(final int[] array, final int index, final int element);\npublic static long[] add(final long[] array, final int index, final long element);\npublic static float[] add(final float[] array, final int index, final float element);\npublic static double[] add(final double[] array, final int index, final double element);\nprivate static Object add(final Object array, final int index, final Object element, final Class<?> clss);\npublic static T[] remove(final T[] array, final int index);\npublic static T[] removeElement(final T[] array, final Object element);\npublic static boolean[] remove(final boolean[] array, final int index);\npublic static boolean[] removeElement(final boolean[] array, final boolean element);\npublic static byte[] remove(final byte[] array, final int index);\npublic static byte[] removeElement(final byte[] array, final byte element);\npublic static char[] remove(final char[] array, final int index);\npublic static char[] removeElement(final char[] array, final char element);\npublic static double[] remove(final double[] array, final int index);\npublic static double[] removeElement(final double[] array, final double element);\npublic static float[] remove(final float[] array, final int index);\npublic static float[] removeElement(final float[] array, final float element);\npublic static int[] remove(final int[] array, final int index);\npublic static int[] removeElement(final int[] array, final int element);\npublic static long[] remove(final long[] array, final int index);\npublic static long[] removeElement(final long[] array, final long element);\npublic static short[] remove(final short[] array, final int index);\npublic static short[] removeElement(final short[] array, final short element);\nprivate static Object remove(final Object array, final int index);\npublic static T[] removeAll(final T[] array, final int... indices);\npublic static T[] removeElements(final T[] array, final T... values);\npublic static byte[] removeAll(final byte[] array, final int... indices);\npublic static byte[] removeElements(final byte[] array, final byte... values);\npublic static short[] removeAll(final short[] array, final int... indices);\npublic static short[] removeElements(final short[] array, final short... values);\npublic static int[] removeAll(final int[] array, final int... indices);\npublic static int[] removeElements(final int[] array, final int... values);\npublic static char[] removeAll(final char[] array, final int... indices);\npublic static char[] removeElements(final char[] array, final char... values);\npublic static long[] removeAll(final long[] array, final int... indices);\npublic static long[] removeElements(final long[] array, final long... values);\npublic static float[] removeAll(final float[] array, final int... indices);\npublic static float[] removeElements(final float[] array, final float... values);\npublic static double[] removeAll(final double[] array, final int... indices);\npublic static double[] removeElements(final double[] array, final double... values);\npublic static boolean[] removeAll(final boolean[] array, final int... indices);\npublic static boolean[] removeElements(final boolean[] array, final boolean... values);\n static Object removeAll(final Object array, final int... indices);\n static Object removeAll(final Object array, final BitSet indices);\npublic static boolean isSorted(final T[] array);\npublic static boolean isSorted(final T[] array, final Comparator<T> comparator);\npublic static boolean isSorted(final int[] array);\npublic static boolean isSorted(final long[] array);\npublic static boolean isSorted(final short[] array);\npublic static boolean isSorted(final double[] array);\npublic static boolean isSorted(final float[] array);\npublic static boolean isSorted(final byte[] array);\npublic static boolean isSorted(final char[] array);\npublic static boolean isSorted(final boolean[] array);\npublic static boolean[] removeAllOccurences(final boolean[] array, final boolean element);\npublic static char[] removeAllOccurences(final char[] array, final char element);\npublic static byte[] removeAllOccurences(final byte[] array, final byte element);\npublic static short[] removeAllOccurences(final short[] array, final short element);\npublic static int[] removeAllOccurences(final int[] array, final int element);\npublic static long[] removeAllOccurences(final long[] array, final long element);\npublic static float[] removeAllOccurences(final float[] array, final float element);\npublic static double[] removeAllOccurences(final double[] array, final double element);\npublic static T[] removeAllOccurences(final T[] array, final T element);\npublic static String[] toStringArray(final Object[] array);\npublic static String[] toStringArray(final Object[] array, final String valueForNullElements);\npublic static boolean[] insert(final int index, final boolean[] array, final boolean... values);\npublic static byte[] insert(final int index, final byte[] array, final byte... values);\npublic static char[] insert(final int index, final char[] array, final char... values);\npublic static double[] insert(final int index, final double[] array, final double... values);\npublic static float[] insert(final int index, final float[] array, final float... values);\npublic static int[] insert(final int index, final int[] array, final int... values);\npublic static long[] insert(final int index, final long[] array, final long... values);\npublic static short[] insert(final int index, final short[] array, final short... values);\npublic static T[] insert(final int index, final T[] array, final T... values);\npublic static void shuffle(final Object[] array);\npublic static void shuffle(final Object[] array, final Random random);\npublic static void shuffle(final boolean[] array);\npublic static void shuffle(final boolean[] array, final Random random);\npublic static void shuffle(final byte[] array);\npublic static void shuffle(final byte[] array, final Random random);\npublic static void shuffle(final char[] array);\npublic static void shuffle(final char[] array, final Random random);\npublic static void shuffle(final short[] array);\npublic static void shuffle(final short[] array, final Random random);\npublic static void shuffle(final int[] array);\npublic static void shuffle(final int[] array, final Random random);\npublic static void shuffle(final long[] array);\npublic static void shuffle(final long[] array, final Random random);\npublic static void shuffle(final float[] array);\npublic static void shuffle(final float[] array, final Random random);\npublic static void shuffle(final double[] array);\npublic static void shuffle(final double[] array, final Random random);",
      "Class_name": "ArrayUtils",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/ArrayUtils###clone",
      "Parameter_num": "1",
      "all_Import_statements": "import java.lang.reflect.Array;\n\nimport java.util.Arrays;\n\nimport java.util.BitSet;\n\nimport java.util.Comparator;\n\nimport java.util.HashMap;\n\nimport java.util.Map;\n\nimport java.util.Random;\n\nimport org.apache.commons.lang3.builder.EqualsBuilder;\n\nimport org.apache.commons.lang3.builder.HashCodeBuilder;\n\nimport org.apache.commons.lang3.builder.ToStringBuilder;\n\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport org.apache.commons.lang3.math.NumberUtils;\n\nimport org.apache.commons.lang3.mutable.MutableInt;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>Clones an array returning a typecast result and handling\n     * {@code null}.\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.\n     *\n     * @param array  the array to clone, may be {@code null}\n     * @return the cloned array, {@code null} if {@code null} input\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static boolean[] clone(final boolean[] array);",
      "Junit_version": "4",
      "returnType": "boolean[]"
    },
    "Test_method": {
      "Method_body": "assertArrayEquals(null, ArrayUtils.clone((Object[]) null));\n\rObject[] original1 = new Object[0];\n\rObject[] cloned1 = ArrayUtils.clone(original1);\n\rassertTrue(Arrays.equals(original1, cloned1));\n\rassertTrue(original1 != cloned1);\n\rfinal StringBuilder builder = new StringBuilder(\"pick\");\n\roriginal1 = new Object[] { builder, \"a\", new String[] { \"stick\" } };\n\rcloned1 = ArrayUtils.clone(original1);\n\rassertTrue(Arrays.equals(original1, cloned1));\n\rassertTrue(original1 != cloned1);\n\rassertSame(original1[0], cloned1[0]);\n\rassertSame(original1[1], cloned1[1]);\n\rassertSame(original1[2], cloned1[2]);",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "13",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertSame;\nimport static org.junit.Assert.assertTrue;\nimport java.util.Arrays;\n",
      "allMethod_info": "// -----------------------------------------------------------------------\n@Test\npublic void testClone() {\n    assertArrayEquals(null, ArrayUtils.clone((Object[]) null));\n    Object[] original1 = new Object[0];\n    Object[] cloned1 = ArrayUtils.clone(original1);\n    assertTrue(Arrays.equals(original1, cloned1));\n    assertTrue(original1 != cloned1);\n    final StringBuilder builder = new StringBuilder(\"pick\");\n    original1 = new Object[] { builder, \"a\", new String[] { \"stick\" } };\n    cloned1 = ArrayUtils.clone(original1);\n    assertTrue(Arrays.equals(original1, cloned1));\n    assertTrue(original1 != cloned1);\n    assertSame(original1[0], cloned1[0]);\n    assertSame(original1[1], cloned1[1]);\n    assertSame(original1[2], cloned1[2]);\n}",
      "Method_name": "testClone",
      "Class_declaration": "public class ArrayUtilsTest {\n",
      "constructors": "",
      "Class_name": "ArrayUtilsTest",
      "methodName_paraNum": "[clone(1), clone(1), equals(2), clone(1), equals(2)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ArrayUtilsTest###testClone",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java",
      "Signature": "public void testClone() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertNotSame;\n\nimport static org.junit.Assert.assertNull;\n\nimport static org.junit.Assert.assertSame;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.junit.Assert.fail;\n\nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Modifier;\n\nimport java.util.Arrays;\n\nimport java.util.Comparator;\n\nimport java.util.Date;\n\nimport java.util.Map;\n\nimport org.junit.Test;\n",
      "comment": "-----------------------------------------------------------------------",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static <T extends Comparable<T>> int compare(T[] a, T[] b) {\n    if (a.length != b.length) {\n        throw new IllegalArgumentException(\"Can't compare different length arrays\");\n    }\n    for (int i = 0; i < a.length; i++) {\n        int compare = a[i].compareTo(b[i]);\n        if (compare == 0) {\n            continue;\n        } else {\n            return compare;\n        }\n    }\n    return 0;\n}",
      "all_field_declaration": "",
      "sub_project_name": "XDean_Java-EX",
      "lineNumbers": "3",
      "Filed": "",
      "Parameter_type": "T[],T[]",
      "Import_statements": "",
      "public_method_signature": "public static void forEach(T[] array, Consumer<? super T> action);\npublic static void forEach(Object array, Consumer<Object> action);\npublic static Object deepClone(Object array);\npublic static int[][] transpose(int[][] origin);\npublic static long[][] transpose(long[][] origin);\npublic static T[][] transpose(T[][] origin);\npublic static int compare(int[] a, int[] b);\npublic static int compare(T[] a, T[] b);",
      "public_field": "",
      "Method_statement": "compare(T() a, T() b)",
      "Method_name": "compare",
      "Class_declaration": "public class ArrayUtil {\n",
      "constructors": "",
      "all_method_signature": "public static void forEach(T[] array, Consumer<? super T> action);\npublic static void forEach(Object array, Consumer<Object> action);\npublic static Object deepClone(Object array);\npublic static int[][] transpose(int[][] origin);\npublic static long[][] transpose(long[][] origin);\npublic static T[][] transpose(T[][] origin);\npublic static int compare(int[] a, int[] b);\npublic static int compare(T[] a, T[] b);",
      "Class_name": "ArrayUtil",
      "project_path": "XDean_Java-EX###XDean_Java-EX/src/main/java/cn/xdean/jex/lang/collection/ArrayUtil###compare",
      "Parameter_num": "2",
      "all_Import_statements": "import java.lang.reflect.Array;\n\nimport java.util.Arrays;\n\nimport java.util.function.Consumer;\n\nimport static cn.xdean.jex.reflect.PrimitiveTypeUtil.toPrimitiveArray;\n\nimport static cn.xdean.jex.reflect.PrimitiveTypeUtil.toWrapperArray;\n",
      "comment": "",
      "packageName": "cn.xdean.jex.lang.collection",
      "method_signature": "public static int compare(T[] a, T[] b);",
      "Junit_version": "4",
      "returnType": "int"
    },
    "Test_method": {
      "Method_body": "assertTrue(compare(new Integer[] { 1, 2, 3 }, new Integer[] { 1, 2, 3 }) == 0);\n\rassertTrue(compare(new Integer[] { 1, 2, 3 }, new Integer[] { 1, 2, 5 }) < 0);\n\rassertTrue(compare(new Integer[] { 1, 3, 3 }, new Integer[] { 1, 2, 5 }) > 0);",
      "sub_project_name": "XDean_Java-EX",
      "lineNumbers": "3",
      "Filed": "",
      "Import_statements": "",
      "allMethod_info": "@Test\npublic void testCompare() throws Exception {\n    assertTrue(compare(new Integer[] { 1, 2, 3 }, new Integer[] { 1, 2, 3 }) == 0);\n    assertTrue(compare(new Integer[] { 1, 2, 3 }, new Integer[] { 1, 2, 5 }) < 0);\n    assertTrue(compare(new Integer[] { 1, 3, 3 }, new Integer[] { 1, 2, 5 }) > 0);\n}",
      "Method_name": "testCompare",
      "Class_declaration": "public class ArrayUtilTest {\n",
      "constructors": "",
      "Class_name": "ArrayUtilTest",
      "methodName_paraNum": "[compare(2), compare(2), compare(2)]",
      "project_path": "XDean_Java-EX###XDean_Java-EX/src/test/java/cn/xdean/jex/lang/ArrayUtilTest###testCompare",
      "relativePath": "XDean_Java-EX/src/test/java/cn/xdean/jex/lang/ArrayUtilTest.java",
      "Signature": "public void testCompare() {\n",
      "all_Import_statements": "import org.junit.Test;\n\nimport static cn.xdean.jex.lang.collection.ArrayUtil.*;\n\nimport static org.junit.Assert.*;\n",
      "comment": "",
      "packageName": "cn.xdean.jex.lang",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static Object deepClone(Object array) {\n    if (array == null || array.getClass().isArray() == false) {\n        return array;\n    }\n    int len = Array.getLength(array);\n    Object newArray = Array.newInstance(array.getClass().getComponentType(), len);\n    for (int i = 0; i < len; i++) {\n        Array.set(newArray, i, deepClone(Array.get(array, i)));\n    }\n    return newArray;\n}",
      "all_field_declaration": "",
      "sub_project_name": "XDean_Java-EX",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "Object",
      "Import_statements": "import java.lang.reflect.Array;\n",
      "public_method_signature": "public static void forEach(T[] array, Consumer<? super T> action);\npublic static void forEach(Object array, Consumer<Object> action);\npublic static Object deepClone(Object array);\npublic static int[][] transpose(int[][] origin);\npublic static long[][] transpose(long[][] origin);\npublic static T[][] transpose(T[][] origin);\npublic static int compare(int[] a, int[] b);\npublic static int compare(T[] a, T[] b);",
      "public_field": "",
      "Method_statement": "deepClone(Object array)",
      "Method_name": "deepClone",
      "Class_declaration": "public class ArrayUtil {\n",
      "constructors": "",
      "all_method_signature": "public static void forEach(T[] array, Consumer<? super T> action);\npublic static void forEach(Object array, Consumer<Object> action);\npublic static Object deepClone(Object array);\npublic static int[][] transpose(int[][] origin);\npublic static long[][] transpose(long[][] origin);\npublic static T[][] transpose(T[][] origin);\npublic static int compare(int[] a, int[] b);\npublic static int compare(T[] a, T[] b);",
      "Class_name": "ArrayUtil",
      "project_path": "XDean_Java-EX###XDean_Java-EX/src/main/java/cn/xdean/jex/lang/collection/ArrayUtil###deepClone",
      "Parameter_num": "1",
      "all_Import_statements": "import java.lang.reflect.Array;\n\nimport java.util.Arrays;\n\nimport java.util.function.Consumer;\n\nimport static cn.xdean.jex.reflect.PrimitiveTypeUtil.toPrimitiveArray;\n\nimport static cn.xdean.jex.reflect.PrimitiveTypeUtil.toWrapperArray;\n",
      "comment": "",
      "packageName": "cn.xdean.jex.lang.collection",
      "method_signature": "public static Object deepClone(Object array);",
      "Junit_version": "4",
      "returnType": "Object"
    },
    "Test_method": {
      "Method_body": "int[][] origin = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };\n\rint[][] clone = (int[][]) deepClone(origin);\n\rassertArrayEquals(origin, clone);\n\rorigin[2][2] = 100;\n\rassertEquals(9, clone[2][2]);",
      "sub_project_name": "XDean_Java-EX",
      "lineNumbers": "5",
      "Filed": "",
      "Import_statements": "",
      "allMethod_info": "@Test\npublic void testDeepClone() throws Exception {\n    int[][] origin = { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };\n    int[][] clone = (int[][]) deepClone(origin);\n    assertArrayEquals(origin, clone);\n    origin[2][2] = 100;\n    assertEquals(9, clone[2][2]);\n}",
      "Method_name": "testDeepClone",
      "Class_declaration": "public class ArrayUtilTest {\n",
      "constructors": "",
      "Class_name": "ArrayUtilTest",
      "methodName_paraNum": "[deepClone(1)]",
      "project_path": "XDean_Java-EX###XDean_Java-EX/src/test/java/cn/xdean/jex/lang/ArrayUtilTest###testDeepClone",
      "relativePath": "XDean_Java-EX/src/test/java/cn/xdean/jex/lang/ArrayUtilTest.java",
      "Signature": "public void testDeepClone() {\n",
      "all_Import_statements": "import org.junit.Test;\n\nimport static cn.xdean.jex.lang.collection.ArrayUtil.*;\n\nimport static org.junit.Assert.*;\n",
      "comment": "",
      "packageName": "cn.xdean.jex.lang",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools) {\n    if (src.length == 0 && srcPos == 0 || 0 == nBools) {\n        return dstInit;\n    }\n    if (nBools - 1 + dstPos >= 8) {\n        throw new IllegalArgumentException(\"nBools-1+dstPos is greater or equal to than 8\");\n    }\n    byte out = dstInit;\n    for (int i = 0; i < nBools; i++) {\n        final int shift = i + dstPos;\n        final int bits = (src[i + srcPos] ? 1 : 0) << shift;\n        final int mask = 0x1 << shift;\n        out = (byte) ((out & ~mask) | bits);\n    }\n    return out;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "boolean[],int,byte,int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "binaryToByte(final boolean() src, final int srcPos, final byte dstInit, final int dstPos, final int nBools)",
      "Method_name": "binaryToByte",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###binaryToByte",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts binary (represented as boolean array) into a byte using the default (little\n     * endian, Lsb0) byte and bit ordering.\n     * </p>\n     *\n     * @param src the binary to convert\n     * @param srcPos the position in {@code src}, in boolean unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination byte\n     * @param dstPos the position of the lsb, in bits, in the result byte\n     * @param nBools the number of booleans to convert\n     * @return a byte containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 8}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBools > src.length}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);",
      "Junit_version": "4",
      "returnType": "byte"
    },
    "Test_method": {
      "Method_body": "final boolean[] src = new boolean[] { false, false, true, true, true, false, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, true, false, false, true, true, false, false, false, false, true, false, true, false, true, false, false, true, true, false, true, true, true, false, false, false, false, true };\n\r// conversion of \"CDF1F0C10F12345678\" by HexToBinary\nassertEquals((byte) 0x00, Conversion.binaryToByte(src, 0 * 4, (byte) 0, 0, 0 * 4));\n\rassertEquals((byte) 0x0C, Conversion.binaryToByte(src, 0 * 4, (byte) 0, 0, 1 * 4));\n\rassertEquals((byte) 0xDC, Conversion.binaryToByte(src, 0 * 4, (byte) 0, 0, 2 * 4));\n\rassertEquals((byte) 0xFD, Conversion.binaryToByte(src, 1 * 4, (byte) 0, 0, 2 * 4));\n\rassertEquals((byte) 0x34, Conversion.binaryToByte(src, 0 * 4, (byte) 0x34, 0, 0 * 4));\n\rassertEquals((byte) 0x84, Conversion.binaryToByte(src, 17 * 4, (byte) 0x34, 4, 1 * 4));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "7",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#binaryToByte(boolean[], int, byte, int, int)}.\n */\n@Test\npublic void testBinaryToByte() {\n    final boolean[] src = new boolean[] { false, false, true, true, true, false, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, true, false, false, true, true, false, false, false, false, true, false, true, false, true, false, false, true, true, false, true, true, true, false, false, false, false, true };\n    // conversion of \"CDF1F0C10F12345678\" by HexToBinary\n    assertEquals((byte) 0x00, Conversion.binaryToByte(src, 0 * 4, (byte) 0, 0, 0 * 4));\n    assertEquals((byte) 0x0C, Conversion.binaryToByte(src, 0 * 4, (byte) 0, 0, 1 * 4));\n    assertEquals((byte) 0xDC, Conversion.binaryToByte(src, 0 * 4, (byte) 0, 0, 2 * 4));\n    assertEquals((byte) 0xFD, Conversion.binaryToByte(src, 1 * 4, (byte) 0, 0, 2 * 4));\n    assertEquals((byte) 0x34, Conversion.binaryToByte(src, 0 * 4, (byte) 0x34, 0, 0 * 4));\n    assertEquals((byte) 0x84, Conversion.binaryToByte(src, 17 * 4, (byte) 0x34, 4, 1 * 4));\n}",
      "Method_name": "testBinaryToByte",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[binaryToByte(5), binaryToByte(5), binaryToByte(5), binaryToByte(5), binaryToByte(5), binaryToByte(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testBinaryToByte",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testBinaryToByte() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#binaryToByte(boolean[], int, byte, int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools) {\n    if (src.length == 0 && srcPos == 0 || 0 == nBools) {\n        return dstInit;\n    }\n    if (nBools - 1 + dstPos >= 32) {\n        throw new IllegalArgumentException(\"nBools-1+dstPos is greater or equal to than 32\");\n    }\n    int out = dstInit;\n    for (int i = 0; i < nBools; i++) {\n        final int shift = i + dstPos;\n        final int bits = (src[i + srcPos] ? 1 : 0) << shift;\n        final int mask = 0x1 << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "boolean[],int,int,int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "binaryToInt(final boolean() src, final int srcPos, final int dstInit, final int dstPos, final int nBools)",
      "Method_name": "binaryToInt",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###binaryToInt",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts binary (represented as boolean array) into an int using the default (little\n     * endian, Lsb0) byte and bit ordering.\n     * </p>\n     *\n     * @param src the binary to convert\n     * @param srcPos the position in {@code src}, in boolean unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination int\n     * @param dstPos the position of the lsb, in bits, in the result int\n     * @param nBools the number of booleans to convert\n     * @return an int containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 32}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBools > src.length}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);",
      "Junit_version": "4",
      "returnType": "int"
    },
    "Test_method": {
      "Method_body": "final boolean[] src = new boolean[] { false, false, true, true, true, false, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, true, false, false, true, true, false, false, false, false, true, false, true, false, true, false, false, true, true, false, true, true, true, false, false, false, false, true };\n\r// conversion of \"CDF1F0C10F12345678\" by HexToBinary\nassertEquals(0x00000000, Conversion.binaryToInt(src, 0 * 4, 0, 0, 0 * 4));\n\rassertEquals(0x0000000C, Conversion.binaryToInt(src, 0 * 4, 0, 0, 1 * 4));\n\rassertEquals(0x1C0F1FDC, Conversion.binaryToInt(src, 0 * 4, 0, 0, 8 * 4));\n\rassertEquals(0x01C0F1FD, Conversion.binaryToInt(src, 1 * 4, 0, 0, 8 * 4));\n\rassertEquals(0x12345679, Conversion.binaryToInt(src, 0 * 4, 0x12345679, 0, 0 * 4));\n\rassertEquals(0x87645679, Conversion.binaryToInt(src, 15 * 4, 0x12345679, 20, 3 * 4));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "7",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#binaryToInt(boolean[], int, int, int, int)}.\n */\n@Test\npublic void testBinaryToInt() {\n    final boolean[] src = new boolean[] { false, false, true, true, true, false, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, true, false, false, true, true, false, false, false, false, true, false, true, false, true, false, false, true, true, false, true, true, true, false, false, false, false, true };\n    // conversion of \"CDF1F0C10F12345678\" by HexToBinary\n    assertEquals(0x00000000, Conversion.binaryToInt(src, 0 * 4, 0, 0, 0 * 4));\n    assertEquals(0x0000000C, Conversion.binaryToInt(src, 0 * 4, 0, 0, 1 * 4));\n    assertEquals(0x1C0F1FDC, Conversion.binaryToInt(src, 0 * 4, 0, 0, 8 * 4));\n    assertEquals(0x01C0F1FD, Conversion.binaryToInt(src, 1 * 4, 0, 0, 8 * 4));\n    assertEquals(0x12345679, Conversion.binaryToInt(src, 0 * 4, 0x12345679, 0, 0 * 4));\n    assertEquals(0x87645679, Conversion.binaryToInt(src, 15 * 4, 0x12345679, 20, 3 * 4));\n}",
      "Method_name": "testBinaryToInt",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[binaryToInt(5), binaryToInt(5), binaryToInt(5), binaryToInt(5), binaryToInt(5), binaryToInt(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testBinaryToInt",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testBinaryToInt() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#binaryToInt(boolean[], int, int, int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools) {\n    if (src.length == 0 && srcPos == 0 || 0 == nBools) {\n        return dstInit;\n    }\n    if (nBools - 1 + dstPos >= 64) {\n        throw new IllegalArgumentException(\"nBools-1+dstPos is greater or equal to than 64\");\n    }\n    long out = dstInit;\n    for (int i = 0; i < nBools; i++) {\n        final int shift = i + dstPos;\n        final long bits = (src[i + srcPos] ? 1L : 0) << shift;\n        final long mask = 0x1L << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "boolean[],int,long,int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "binaryToLong(final boolean() src, final int srcPos, final long dstInit, final int dstPos, final int nBools)",
      "Method_name": "binaryToLong",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###binaryToLong",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts binary (represented as boolean array) into a long using the default (little\n     * endian, Lsb0) byte and bit ordering.\n     * </p>\n     *\n     * @param src the binary to convert\n     * @param srcPos the position in {@code src}, in boolean unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination long\n     * @param dstPos the position of the lsb, in bits, in the result long\n     * @param nBools the number of booleans to convert\n     * @return a long containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 64}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBools > src.length}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);",
      "Junit_version": "4",
      "returnType": "long"
    },
    "Test_method": {
      "Method_body": "final boolean[] src = new boolean[] { false, false, true, true, true, false, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, true, false, false, true, true, false, false, false, false, true, false, true, false, true, false, false, true, true, false, true, true, true, false, false, false, false, true };\n\r// conversion of \"CDF1F0C10F12345678\" by HexToBinary\nassertEquals(0x0000000000000000L, Conversion.binaryToLong(src, 0, 0L, 0, 0));\n\rassertEquals(0x000000000000000CL, Conversion.binaryToLong(src, 0, 0L, 0, 1 * 4));\n\rassertEquals(0x000000001C0F1FDCL, Conversion.binaryToLong(src, 0, 0L, 0, 8 * 4));\n\rassertEquals(0x0000000001C0F1FDL, Conversion.binaryToLong(src, 1 * 4, 0L, 0, 8 * 4));\n\rassertEquals(0x123456798ABCDEF0L, Conversion.binaryToLong(src, 0, 0x123456798ABCDEF0L, 0, 0));\n\rassertEquals(0x1234567876BCDEF0L, Conversion.binaryToLong(src, 15 * 4, 0x123456798ABCDEF0L, 24, 3 * 4));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "7",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#binaryToLong(boolean[], int, long, int, int)}.\n */\n@Test\npublic void testBinaryToLong() {\n    final boolean[] src = new boolean[] { false, false, true, true, true, false, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, true, false, false, true, true, false, false, false, false, true, false, true, false, true, false, false, true, true, false, true, true, true, false, false, false, false, true };\n    // conversion of \"CDF1F0C10F12345678\" by HexToBinary\n    assertEquals(0x0000000000000000L, Conversion.binaryToLong(src, 0, 0L, 0, 0));\n    assertEquals(0x000000000000000CL, Conversion.binaryToLong(src, 0, 0L, 0, 1 * 4));\n    assertEquals(0x000000001C0F1FDCL, Conversion.binaryToLong(src, 0, 0L, 0, 8 * 4));\n    assertEquals(0x0000000001C0F1FDL, Conversion.binaryToLong(src, 1 * 4, 0L, 0, 8 * 4));\n    assertEquals(0x123456798ABCDEF0L, Conversion.binaryToLong(src, 0, 0x123456798ABCDEF0L, 0, 0));\n    assertEquals(0x1234567876BCDEF0L, Conversion.binaryToLong(src, 15 * 4, 0x123456798ABCDEF0L, 24, 3 * 4));\n}",
      "Method_name": "testBinaryToLong",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[binaryToLong(5), binaryToLong(5), binaryToLong(5), binaryToLong(5), binaryToLong(5), binaryToLong(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testBinaryToLong",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testBinaryToLong() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#binaryToLong(boolean[], int, long, int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools) {\n    if (src.length == 0 && srcPos == 0 || 0 == nBools) {\n        return dstInit;\n    }\n    if (nBools - 1 + dstPos >= 16) {\n        throw new IllegalArgumentException(\"nBools-1+dstPos is greater or equal to than 16\");\n    }\n    short out = dstInit;\n    for (int i = 0; i < nBools; i++) {\n        final int shift = i + dstPos;\n        final int bits = (src[i + srcPos] ? 1 : 0) << shift;\n        final int mask = 0x1 << shift;\n        out = (short) ((out & ~mask) | bits);\n    }\n    return out;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "boolean[],int,short,int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "binaryToShort(final boolean() src, final int srcPos, final short dstInit, final int dstPos, final int nBools)",
      "Method_name": "binaryToShort",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###binaryToShort",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts binary (represented as boolean array) into a short using the default (little\n     * endian, Lsb0) byte and bit ordering.\n     * </p>\n     *\n     * @param src the binary to convert\n     * @param srcPos the position in {@code src}, in boolean unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination short\n     * @param dstPos the position of the lsb, in bits, in the result short\n     * @param nBools the number of booleans to convert\n     * @return a short containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code nBools-1+dstPos >= 16}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBools > src.length}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);",
      "Junit_version": "4",
      "returnType": "short"
    },
    "Test_method": {
      "Method_body": "final boolean[] src = new boolean[] { false, false, true, true, true, false, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, true, false, false, true, true, false, false, false, false, true, false, true, false, true, false, false, true, true, false, true, true, true, false, false, false, false, true };\n\r// conversion of \"CDF1F0C10F12345678\" by HexToBinary\nassertEquals((short) 0x0000, Conversion.binaryToShort(src, 0 * 4, (short) 0, 0, 0 * 4));\n\rassertEquals((short) 0x000C, Conversion.binaryToShort(src, 0 * 4, (short) 0, 0, 1 * 4));\n\rassertEquals((short) 0x1FDC, Conversion.binaryToShort(src, 0 * 4, (short) 0, 0, 4 * 4));\n\rassertEquals((short) 0xF1FD, Conversion.binaryToShort(src, 1 * 4, (short) 0, 0, 4 * 4));\n\rassertEquals((short) 0x1234, Conversion.binaryToShort(src, 0 * 4, (short) 0x1234, 0, 0 * 4));\n\rassertEquals((short) 0x8764, Conversion.binaryToShort(src, 15 * 4, (short) 0x1234, 4, 3 * 4));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "7",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#binaryToShort(boolean[], int, short, int, int)}.\n */\n@Test\npublic void testBinaryToShort() {\n    final boolean[] src = new boolean[] { false, false, true, true, true, false, true, true, true, true, true, true, true, false, false, false, true, true, true, true, false, false, false, false, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, false, false, false, false, true, false, false, true, true, false, false, false, false, true, false, true, false, true, false, false, true, true, false, true, true, true, false, false, false, false, true };\n    // conversion of \"CDF1F0C10F12345678\" by HexToBinary\n    assertEquals((short) 0x0000, Conversion.binaryToShort(src, 0 * 4, (short) 0, 0, 0 * 4));\n    assertEquals((short) 0x000C, Conversion.binaryToShort(src, 0 * 4, (short) 0, 0, 1 * 4));\n    assertEquals((short) 0x1FDC, Conversion.binaryToShort(src, 0 * 4, (short) 0, 0, 4 * 4));\n    assertEquals((short) 0xF1FD, Conversion.binaryToShort(src, 1 * 4, (short) 0, 0, 4 * 4));\n    assertEquals((short) 0x1234, Conversion.binaryToShort(src, 0 * 4, (short) 0x1234, 0, 0 * 4));\n    assertEquals((short) 0x8764, Conversion.binaryToShort(src, 15 * 4, (short) 0x1234, 4, 3 * 4));\n}",
      "Method_name": "testBinaryToShort",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[binaryToShort(5), binaryToShort(5), binaryToShort(5), binaryToShort(5), binaryToShort(5), binaryToShort(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testBinaryToShort",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testBinaryToShort() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#binaryToShort(boolean[], int, short, int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes) {\n    if (src.length == 0 && srcPos == 0 || 0 == nBytes) {\n        return dstInit;\n    }\n    if ((nBytes - 1) * 8 + dstPos >= 32) {\n        throw new IllegalArgumentException(\"(nBytes-1)*8+dstPos is greater or equal to than 32\");\n    }\n    int out = dstInit;\n    for (int i = 0; i < nBytes; i++) {\n        final int shift = i * 8 + dstPos;\n        final int bits = (0xff & src[i + srcPos]) << shift;\n        final int mask = 0xff << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "byte[],int,int,int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "byteArrayToInt(final byte() src, final int srcPos, final int dstInit, final int dstPos, final int nBytes)",
      "Method_name": "byteArrayToInt",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###byteArrayToInt",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts an array of byte into an int using the default (little endian, Lsb0) byte and bit\n     * ordering.\n     * </p>\n     *\n     * @param src the byte array to convert\n     * @param srcPos the position in {@code src}, in byte unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination int\n     * @param dstPos the position of the lsb, in bits, in the result int\n     * @param nBytes the number of bytes to convert\n     * @return an int containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 32}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBytes > src.length}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);",
      "Junit_version": "4",
      "returnType": "int"
    },
    "Test_method": {
      "Method_body": "final byte[] src = new byte[] { (byte) 0xCD, (byte) 0xF1, (byte) 0xF0, (byte) 0xC1, (byte) 0x0F, (byte) 0x12, (byte) 0x34, (byte) 0x56, (byte) 0x78 };\n\rassertEquals(0x00000000, Conversion.byteArrayToInt(src, 0, 0, 0, 0));\n\rassertEquals(0x000000CD, Conversion.byteArrayToInt(src, 0, 0, 0, 1));\n\rassertEquals(0xC1F0F1CD, Conversion.byteArrayToInt(src, 0, 0, 0, 4));\n\rassertEquals(0x0FC1F0F1, Conversion.byteArrayToInt(src, 1, 0, 0, 4));\n\rassertEquals(0x12345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 0, 0));\n\rassertEquals(0xCD345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 24, 1));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "7",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#byteArrayToInt(byte[], int, int, int, int)}.\n */\n@Test\npublic void testByteArrayToInt() {\n    final byte[] src = new byte[] { (byte) 0xCD, (byte) 0xF1, (byte) 0xF0, (byte) 0xC1, (byte) 0x0F, (byte) 0x12, (byte) 0x34, (byte) 0x56, (byte) 0x78 };\n    assertEquals(0x00000000, Conversion.byteArrayToInt(src, 0, 0, 0, 0));\n    assertEquals(0x000000CD, Conversion.byteArrayToInt(src, 0, 0, 0, 1));\n    assertEquals(0xC1F0F1CD, Conversion.byteArrayToInt(src, 0, 0, 0, 4));\n    assertEquals(0x0FC1F0F1, Conversion.byteArrayToInt(src, 1, 0, 0, 4));\n    assertEquals(0x12345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 0, 0));\n    assertEquals(0xCD345678, Conversion.byteArrayToInt(src, 0, 0x12345678, 24, 1));\n    // assertEquals(0x56341278,Conversion.ByteArrayToInt(src, 5, 0x01234567, 8, 4));\n}",
      "Method_name": "testByteArrayToInt",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[byteArrayToInt(5), byteArrayToInt(5), byteArrayToInt(5), byteArrayToInt(5), byteArrayToInt(5), byteArrayToInt(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testByteArrayToInt",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testByteArrayToInt() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#byteArrayToInt(byte[], int, int, int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes) {\n    if (src.length == 0 && srcPos == 0 || 0 == nBytes) {\n        return dstInit;\n    }\n    if ((nBytes - 1) * 8 + dstPos >= 64) {\n        throw new IllegalArgumentException(\"(nBytes-1)*8+dstPos is greater or equal to than 64\");\n    }\n    long out = dstInit;\n    for (int i = 0; i < nBytes; i++) {\n        final int shift = i * 8 + dstPos;\n        final long bits = (0xffL & src[i + srcPos]) << shift;\n        final long mask = 0xffL << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "byte[],int,long,int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "byteArrayToLong(final byte() src, final int srcPos, final long dstInit, final int dstPos, final int nBytes)",
      "Method_name": "byteArrayToLong",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###byteArrayToLong",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts an array of byte into a long using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the byte array to convert\n     * @param srcPos the position in {@code src}, in byte unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination long\n     * @param dstPos the position of the lsb, in bits, in the result long\n     * @param nBytes the number of bytes to convert\n     * @return a long containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code (nBytes-1)*8+dstPos >= 64}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nBytes > src.length}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);",
      "Junit_version": "4",
      "returnType": "long"
    },
    "Test_method": {
      "Method_body": "final byte[] src = new byte[] { (byte) 0xCD, (byte) 0xF1, (byte) 0xF0, (byte) 0xC1, (byte) 0x0F, (byte) 0x12, (byte) 0x34, (byte) 0x56, (byte) 0x78 };\n\rassertEquals(0x0000000000000000L, Conversion.byteArrayToLong(src, 0, 0L, 0, 0));\n\rassertEquals(0x00000000000000CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 1));\n\rassertEquals(0x00000000C1F0F1CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 4));\n\rassertEquals(0x000000000FC1F0F1L, Conversion.byteArrayToLong(src, 1, 0L, 0, 4));\n\rassertEquals(0x123456789ABCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0));\n\rassertEquals(0x12345678CDBCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1));\n\rassertEquals(0x123456789A7856F0L, Conversion.byteArrayToLong(src, 7, 0x123456789ABCDEF0L, 8, 2));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "8",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#byteArrayToLong(byte[], int, long, int, int)}.\n */\n@Test\npublic void testByteArrayToLong() {\n    final byte[] src = new byte[] { (byte) 0xCD, (byte) 0xF1, (byte) 0xF0, (byte) 0xC1, (byte) 0x0F, (byte) 0x12, (byte) 0x34, (byte) 0x56, (byte) 0x78 };\n    assertEquals(0x0000000000000000L, Conversion.byteArrayToLong(src, 0, 0L, 0, 0));\n    assertEquals(0x00000000000000CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 1));\n    assertEquals(0x00000000C1F0F1CDL, Conversion.byteArrayToLong(src, 0, 0L, 0, 4));\n    assertEquals(0x000000000FC1F0F1L, Conversion.byteArrayToLong(src, 1, 0L, 0, 4));\n    assertEquals(0x123456789ABCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0));\n    assertEquals(0x12345678CDBCDEF0L, Conversion.byteArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1));\n    assertEquals(0x123456789A7856F0L, Conversion.byteArrayToLong(src, 7, 0x123456789ABCDEF0L, 8, 2));\n}",
      "Method_name": "testByteArrayToLong",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[byteArrayToLong(5), byteArrayToLong(5), byteArrayToLong(5), byteArrayToLong(5), byteArrayToLong(5), byteArrayToLong(5), byteArrayToLong(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testByteArrayToLong",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testByteArrayToLong() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#byteArrayToLong(byte[], int, long, int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex) {\n    if (0 == nHex) {\n        return dstInit;\n    }\n    if ((nHex - 1) * 4 + dstPos >= 8) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+dstPos is greater or equal to than 8\");\n    }\n    byte out = dstInit;\n    for (int i = 0; i < nHex; i++) {\n        final int shift = i * 4 + dstPos;\n        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n        final int mask = 0xf << shift;\n        out = (byte) ((out & ~mask) | bits);\n    }\n    return out;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "String,int,byte,int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex)",
      "Method_name": "hexToByte",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###hexToByte",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts an array of Char into a byte using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the hex string to convert\n     * @param srcPos the position in {@code src}, in Char unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination byte\n     * @param dstPos the position of the lsb, in bits, in the result byte\n     * @param nHex the number of Chars to convert\n     * @return a byte containing the selected bits\n     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 8}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);",
      "Junit_version": "4",
      "returnType": "byte"
    },
    "Test_method": {
      "Method_body": "final String src = \"CDF1F0C10F12345678\";\n\rassertEquals((byte) 0x00, Conversion.hexToByte(src, 0, (byte) 0, 0, 0));\n\rassertEquals((byte) 0x0C, Conversion.hexToByte(src, 0, (byte) 0, 0, 1));\n\rassertEquals((byte) 0xDC, Conversion.hexToByte(src, 0, (byte) 0, 0, 2));\n\rassertEquals((byte) 0xFD, Conversion.hexToByte(src, 1, (byte) 0, 0, 2));\n\rassertEquals((byte) 0x34, Conversion.hexToByte(src, 0, (byte) 0x34, 0, 0));\n\rassertEquals((byte) 0x84, Conversion.hexToByte(src, 17, (byte) 0x34, 4, 1));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "7",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#hexToByte(String, int, byte, int, int)}.\n */\n@Test\npublic void testHexToByte() {\n    final String src = \"CDF1F0C10F12345678\";\n    assertEquals((byte) 0x00, Conversion.hexToByte(src, 0, (byte) 0, 0, 0));\n    assertEquals((byte) 0x0C, Conversion.hexToByte(src, 0, (byte) 0, 0, 1));\n    assertEquals((byte) 0xDC, Conversion.hexToByte(src, 0, (byte) 0, 0, 2));\n    assertEquals((byte) 0xFD, Conversion.hexToByte(src, 1, (byte) 0, 0, 2));\n    assertEquals((byte) 0x34, Conversion.hexToByte(src, 0, (byte) 0x34, 0, 0));\n    assertEquals((byte) 0x84, Conversion.hexToByte(src, 17, (byte) 0x34, 4, 1));\n}",
      "Method_name": "testHexToByte",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[hexToByte(5), hexToByte(5), hexToByte(5), hexToByte(5), hexToByte(5), hexToByte(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testHexToByte",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testHexToByte() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#hexToByte(String, int, byte, int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex) {\n    if (0 == nHex) {\n        return dstInit;\n    }\n    if ((nHex - 1) * 4 + dstPos >= 32) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+dstPos is greater or equal to than 32\");\n    }\n    int out = dstInit;\n    for (int i = 0; i < nHex; i++) {\n        final int shift = i * 4 + dstPos;\n        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n        final int mask = 0xf << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "String,int,int,int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex)",
      "Method_name": "hexToInt",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###hexToInt",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts an array of Char into an int using the default (little endian, Lsb0) byte and bit\n     * ordering.\n     * </p>\n     *\n     * @param src the hex string to convert\n     * @param srcPos the position in {@code src}, in Char unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination int\n     * @param dstPos the position of the lsb, in bits, in the result int\n     * @param nHex the number of Chars to convert\n     * @return an int containing the selected bits\n     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 32}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);",
      "Junit_version": "4",
      "returnType": "int"
    },
    "Test_method": {
      "Method_body": "final String src = \"CDF1F0C10F12345678\";\n\rassertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0));\n\rassertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1));\n\rassertEquals(0x1C0F1FDC, Conversion.hexToInt(src, 0, 0, 0, 8));\n\rassertEquals(0x01C0F1FD, Conversion.hexToInt(src, 1, 0, 0, 8));\n\rassertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0));\n\rassertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 20, 3));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "7",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#hexToInt(String, int, int, int, int)}.\n */\n@Test\npublic void testHexToInt() {\n    final String src = \"CDF1F0C10F12345678\";\n    assertEquals(0x00000000, Conversion.hexToInt(src, 0, 0, 0, 0));\n    assertEquals(0x0000000C, Conversion.hexToInt(src, 0, 0, 0, 1));\n    assertEquals(0x1C0F1FDC, Conversion.hexToInt(src, 0, 0, 0, 8));\n    assertEquals(0x01C0F1FD, Conversion.hexToInt(src, 1, 0, 0, 8));\n    assertEquals(0x12345679, Conversion.hexToInt(src, 0, 0x12345679, 0, 0));\n    assertEquals(0x87645679, Conversion.hexToInt(src, 15, 0x12345679, 20, 3));\n}",
      "Method_name": "testHexToInt",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[hexToInt(5), hexToInt(5), hexToInt(5), hexToInt(5), hexToInt(5), hexToInt(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testHexToInt",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testHexToInt() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#hexToInt(String, int, int, int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex) {\n    if (0 == nHex) {\n        return dstInit;\n    }\n    if ((nHex - 1) * 4 + dstPos >= 64) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+dstPos is greater or equal to than 64\");\n    }\n    long out = dstInit;\n    for (int i = 0; i < nHex; i++) {\n        final int shift = i * 4 + dstPos;\n        final long bits = (0xfL & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n        final long mask = 0xfL << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "String,int,long,int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex)",
      "Method_name": "hexToLong",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###hexToLong",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts an array of Char into a long using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the hex string to convert\n     * @param srcPos the position in {@code src}, in Char unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination long\n     * @param dstPos the position of the lsb, in bits, in the result long\n     * @param nHex the number of Chars to convert\n     * @return a long containing the selected bits\n     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 64}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);",
      "Junit_version": "4",
      "returnType": "long"
    },
    "Test_method": {
      "Method_body": "final String src = \"CDF1F0C10F12345678\";\n\rassertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0));\n\rassertEquals(0x000000000000000CL, Conversion.hexToLong(src, 0, 0L, 0, 1));\n\rassertEquals(0x000000001C0F1FDCL, Conversion.hexToLong(src, 0, 0L, 0, 8));\n\rassertEquals(0x0000000001C0F1FDL, Conversion.hexToLong(src, 1, 0L, 0, 8));\n\rassertEquals(0x123456798ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456798ABCDEF0L, 0, 0));\n\rassertEquals(0x1234567876BCDEF0L, Conversion.hexToLong(src, 15, 0x123456798ABCDEF0L, 24, 3));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "7",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#hexToLong(String, int, long, int, int)}.\n */\n@Test\npublic void testHexToLong() {\n    final String src = \"CDF1F0C10F12345678\";\n    assertEquals(0x0000000000000000L, Conversion.hexToLong(src, 0, 0L, 0, 0));\n    assertEquals(0x000000000000000CL, Conversion.hexToLong(src, 0, 0L, 0, 1));\n    assertEquals(0x000000001C0F1FDCL, Conversion.hexToLong(src, 0, 0L, 0, 8));\n    assertEquals(0x0000000001C0F1FDL, Conversion.hexToLong(src, 1, 0L, 0, 8));\n    assertEquals(0x123456798ABCDEF0L, Conversion.hexToLong(src, 0, 0x123456798ABCDEF0L, 0, 0));\n    assertEquals(0x1234567876BCDEF0L, Conversion.hexToLong(src, 15, 0x123456798ABCDEF0L, 24, 3));\n}",
      "Method_name": "testHexToLong",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[hexToLong(5), hexToLong(5), hexToLong(5), hexToLong(5), hexToLong(5), hexToLong(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testHexToLong",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testHexToLong() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#hexToLong(String, int, long, int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex) {\n    if (0 == nHex) {\n        return dstInit;\n    }\n    if ((nHex - 1) * 4 + dstPos >= 16) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+dstPos is greater or equal to than 16\");\n    }\n    short out = dstInit;\n    for (int i = 0; i < nHex; i++) {\n        final int shift = i * 4 + dstPos;\n        final int bits = (0xf & hexDigitToInt(src.charAt(i + srcPos))) << shift;\n        final int mask = 0xf << shift;\n        out = (short) ((out & ~mask) | bits);\n    }\n    return out;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "String,int,short,int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex)",
      "Method_name": "hexToShort",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###hexToShort",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts an array of Char into a short using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the hex string to convert\n     * @param srcPos the position in {@code src}, in Char unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination short\n     * @param dstPos the position of the lsb, in bits, in the result short\n     * @param nHex the number of Chars to convert\n     * @return a short containing the selected bits\n     * @throws IllegalArgumentException if {@code (nHexs-1)*4+dstPos >= 16}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);",
      "Junit_version": "4",
      "returnType": "short"
    },
    "Test_method": {
      "Method_body": "final String src = \"CDF1F0C10F12345678\";\n\rassertEquals((short) 0x0000, Conversion.hexToShort(src, 0, (short) 0, 0, 0));\n\rassertEquals((short) 0x000C, Conversion.hexToShort(src, 0, (short) 0, 0, 1));\n\rassertEquals((short) 0x1FDC, Conversion.hexToShort(src, 0, (short) 0, 0, 4));\n\rassertEquals((short) 0xF1FD, Conversion.hexToShort(src, 1, (short) 0, 0, 4));\n\rassertEquals((short) 0x1234, Conversion.hexToShort(src, 0, (short) 0x1234, 0, 0));\n\rassertEquals((short) 0x8764, Conversion.hexToShort(src, 15, (short) 0x1234, 4, 3));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "7",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#hexToShort(String, int, short, int, int)}.\n */\n@Test\npublic void testHexToShort() {\n    final String src = \"CDF1F0C10F12345678\";\n    assertEquals((short) 0x0000, Conversion.hexToShort(src, 0, (short) 0, 0, 0));\n    assertEquals((short) 0x000C, Conversion.hexToShort(src, 0, (short) 0, 0, 1));\n    assertEquals((short) 0x1FDC, Conversion.hexToShort(src, 0, (short) 0, 0, 4));\n    assertEquals((short) 0xF1FD, Conversion.hexToShort(src, 1, (short) 0, 0, 4));\n    assertEquals((short) 0x1234, Conversion.hexToShort(src, 0, (short) 0x1234, 0, 0));\n    assertEquals((short) 0x8764, Conversion.hexToShort(src, 15, (short) 0x1234, 4, 3));\n}",
      "Method_name": "testHexToShort",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[hexToShort(5), hexToShort(5), hexToShort(5), hexToShort(5), hexToShort(5), hexToShort(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testHexToShort",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testHexToShort() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#hexToShort(String, int, short, int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {\n    if (0 == nHexs) {\n        return dstInit;\n    }\n    if ((nHexs - 1) * 4 + srcPos >= 64) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+srcPos is greater or equal to than 64\");\n    }\n    final StringBuilder sb = new StringBuilder(dstInit);\n    int append = sb.length();\n    for (int i = 0; i < nHexs; i++) {\n        final int shift = i * 4 + srcPos;\n        final int bits = (int) (0xF & (src >> shift));\n        if (dstPos + i == append) {\n            ++append;\n            sb.append(intToHexDigit(bits));\n        } else {\n            sb.setCharAt(dstPos + i, intToHexDigit(bits));\n        }\n    }\n    return sb.toString();\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "6",
      "Filed": "",
      "Parameter_type": "long,int,String,int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs)",
      "Method_name": "longToHex",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###longToHex",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts a long into an array of Char using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the long to convert\n     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n     * @param dstInit the initial value for the result String\n     * @param dstPos the position in {@code dst} where to copy the result\n     * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to the\n     *            width of the input (from srcPos to msb)\n     * @return {@code dst}\n     * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 64}\n     * @throws StringIndexOutOfBoundsException if {@code dst.init.length() < dstPos}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);",
      "Junit_version": "4",
      "returnType": "String"
    },
    "Test_method": {
      "Method_body": "assertEquals(\"\", Conversion.longToHex(0x0000000000000000L, 0, \"\", 0, 0));\n\rassertEquals(\"\", Conversion.longToHex(0x0000000000000000L, 100, \"\", 0, 0));\n\rassertEquals(\"\", Conversion.longToHex(0x0000000000000000L, 0, \"\", 100, 0));\n\rassertEquals(\"ffffffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 0, 0));\n\rassertEquals(\"3fffffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDE3L, 0, \"ffffffffffffffffffffffff\", 0, 1));\n\rassertEquals(\"feffffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 0, 2));\n\rassertEquals(\"fedcffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 0, 4));\n\rassertEquals(\"fedcba098765432fffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 0, 15));\n\rassertEquals(\"fedcba0987654321ffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 0, 16));\n\rassertEquals(\"fff3ffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDE3L, 0, \"ffffffffffffffffffffffff\", 3, 1));\n\rassertEquals(\"ffffefffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 3, 2));\n\rassertEquals(\"ffffedcfffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 3, 4));\n\rassertEquals(\"ffffedcba098765432ffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 3, 15));\n\rassertEquals(\"ffffedcba0987654321fffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 3, 16));\n\rassertEquals(\"7fffffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 1, \"ffffffffffffffffffffffff\", 0, 1));\n\rassertEquals(\"bfffffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 2, \"ffffffffffffffffffffffff\", 0, 1));\n\rassertEquals(\"fffdb975121fca86420fffff\", Conversion.longToHex(0x1234567890ABCDEFL, 3, \"ffffffffffffffffffffffff\", 3, 16));\n\r// assertEquals(\"ffffffffffffffffffffffff\",Conversion.longToHex(0x1234567890ABCDEFL,4,\"ffffffffffffffffffffffff\",3,16));//rejected\n// by assertion\nassertEquals(\"fffedcba0987654321ffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 4, \"ffffffffffffffffffffffff\", 3, 15));\n\rassertEquals(\"fedcba0987654321\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"\", 0, 16));\n\rtry {\n    Conversion.longToHex(0x1234567890ABCDEFL, 0, \"\", 1, 8);\n    fail(\"Thrown \" + StringIndexOutOfBoundsException.class.getName() + \" expected\");\n} catch (final StringIndexOutOfBoundsException e) {\n    // OK\n}",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "20",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#longToHex(long, int, String, int, int)}.\n */\n@Test\npublic void testLongToHex() {\n    assertEquals(\"\", Conversion.longToHex(0x0000000000000000L, 0, \"\", 0, 0));\n    assertEquals(\"\", Conversion.longToHex(0x0000000000000000L, 100, \"\", 0, 0));\n    assertEquals(\"\", Conversion.longToHex(0x0000000000000000L, 0, \"\", 100, 0));\n    assertEquals(\"ffffffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 0, 0));\n    assertEquals(\"3fffffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDE3L, 0, \"ffffffffffffffffffffffff\", 0, 1));\n    assertEquals(\"feffffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 0, 2));\n    assertEquals(\"fedcffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 0, 4));\n    assertEquals(\"fedcba098765432fffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 0, 15));\n    assertEquals(\"fedcba0987654321ffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 0, 16));\n    assertEquals(\"fff3ffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDE3L, 0, \"ffffffffffffffffffffffff\", 3, 1));\n    assertEquals(\"ffffefffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 3, 2));\n    assertEquals(\"ffffedcfffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 3, 4));\n    assertEquals(\"ffffedcba098765432ffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 3, 15));\n    assertEquals(\"ffffedcba0987654321fffff\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"ffffffffffffffffffffffff\", 3, 16));\n    assertEquals(\"7fffffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 1, \"ffffffffffffffffffffffff\", 0, 1));\n    assertEquals(\"bfffffffffffffffffffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 2, \"ffffffffffffffffffffffff\", 0, 1));\n    assertEquals(\"fffdb975121fca86420fffff\", Conversion.longToHex(0x1234567890ABCDEFL, 3, \"ffffffffffffffffffffffff\", 3, 16));\n    // assertEquals(\"ffffffffffffffffffffffff\",Conversion.longToHex(0x1234567890ABCDEFL,4,\"ffffffffffffffffffffffff\",3,16));//rejected\n    // by assertion\n    assertEquals(\"fffedcba0987654321ffffff\", Conversion.longToHex(0x1234567890ABCDEFL, 4, \"ffffffffffffffffffffffff\", 3, 15));\n    assertEquals(\"fedcba0987654321\", Conversion.longToHex(0x1234567890ABCDEFL, 0, \"\", 0, 16));\n    try {\n        Conversion.longToHex(0x1234567890ABCDEFL, 0, \"\", 1, 8);\n        fail(\"Thrown \" + StringIndexOutOfBoundsException.class.getName() + \" expected\");\n    } catch (final StringIndexOutOfBoundsException e) {\n        // OK\n    }\n}",
      "Method_name": "testLongToHex",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[longToHex(5), longToHex(5), longToHex(5), longToHex(5), longToHex(5), longToHex(5), longToHex(5), longToHex(5), longToHex(5), longToHex(5), longToHex(5), longToHex(5), longToHex(5), longToHex(5), longToHex(5), longToHex(5), longToHex(5), longToHex(5), longToHex(5), longToHex(5), fail(1), getName(0)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testLongToHex",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testLongToHex() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#longToHex(long, int, String, int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts) {\n    if (0 == nInts) {\n        return dst;\n    }\n    if ((nInts - 1) * 32 + srcPos >= 64) {\n        throw new IllegalArgumentException(\"(nInts-1)*32+srcPos is greater or equal to than 64\");\n    }\n    for (int i = 0; i < nInts; i++) {\n        final int shift = i * 32 + srcPos;\n        dst[dstPos + i] = (int) (0xffffffff & (src >> shift));\n    }\n    return dst;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "long,int,int[],int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "longToIntArray(final long src, final int srcPos, final int() dst, final int dstPos, final int nInts)",
      "Method_name": "longToIntArray",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###longToIntArray",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts a long into an array of int using the default (little endian, Lsb0) byte and bit\n     * ordering.\n     * </p>\n     *\n     * @param src the long to convert\n     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n     * @param dst the destination array\n     * @param dstPos the position in {@code dst} where to copy the result\n     * @param nInts the number of ints to copy to {@code dst}, must be smaller or equal to the\n     *            width of the input (from srcPos to msb)\n     * @return {@code dst}\n     * @throws NullPointerException if {@code dst} is {@code null} and {@code nInts > 0}\n     * @throws IllegalArgumentException if {@code (nInts-1)*32+srcPos >= 64}\n     * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nInts > dst.length}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);",
      "Junit_version": "4",
      "returnType": "int[]"
    },
    "Test_method": {
      "Method_body": "assertArrayEquals(new int[] {}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[] {}, 0, 0));\n\rassertArrayEquals(new int[] {}, Conversion.longToIntArray(0x0000000000000000L, 100, new int[] {}, 0, 0));\n\rassertArrayEquals(new int[] {}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[] {}, 100, 0));\n\rassertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 0, 0));\n\rassertArrayEquals(new int[] { 0x90ABCDEF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 0, 1));\n\rassertArrayEquals(new int[] { 0x90ABCDEF, 0x12345678, 0xFFFFFFFF, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 0, 2));\n\r// assertArrayEquals(new\n// int[]{0x90ABCDEF,0x12345678,0x90ABCDEF,0x12345678},Conversion.longToIntArray(0x1234567890ABCDEFL,\n// 0,new int[]{-1,-1,-1,-1},0,4));//rejected by assertion\n// assertArrayEquals(new\n// int[]{0xFFFFFFFF,0x90ABCDEF,0x12345678,0x90ABCDEF},Conversion.longToIntArray(0x1234567890ABCDEFL,\n// 0,new int[]{-1,-1,-1,-1},1,3));\nassertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF, 0x12345678 }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 2, 2));\n\rassertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 2, 1));\n\rassertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 3, 1));\n\rassertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x4855E6F7, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 1, new int[] { -1, -1, -1, -1 }, 2, 1));\n\rassertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x242AF37B, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 2, new int[] { -1, -1, -1, -1 }, 2, 1));\n\rassertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x121579BD, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 3, new int[] { -1, -1, -1, -1 }, 2, 1));\n\rassertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x890ABCDE, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 4, new int[] { -1, -1, -1, -1 }, 2, 1));\n\r// assertArrayEquals(new\n// int[]{0x4855E6F7,0x091A2B3C,0x4855E6F7,0x091A2B3C},Conversion.longToIntArray(0x1234567890ABCDEFL,\n// 1,new int[]{-1,-1,-1,-1},0,4));//rejected by assertion\nassertArrayEquals(new int[] { 0x091A2B3C }, Conversion.longToIntArray(0x1234567890ABCDEFL, 33, new int[] { 0 }, 0, 1));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "14",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertArrayEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#longToIntArray(long, int, int[], int, int)}.\n */\n@Test\npublic void testLongToIntArray() {\n    assertArrayEquals(new int[] {}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[] {}, 0, 0));\n    assertArrayEquals(new int[] {}, Conversion.longToIntArray(0x0000000000000000L, 100, new int[] {}, 0, 0));\n    assertArrayEquals(new int[] {}, Conversion.longToIntArray(0x0000000000000000L, 0, new int[] {}, 100, 0));\n    assertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 0, 0));\n    assertArrayEquals(new int[] { 0x90ABCDEF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new int[] { 0x90ABCDEF, 0x12345678, 0xFFFFFFFF, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 0, 2));\n    // assertArrayEquals(new\n    // int[]{0x90ABCDEF,0x12345678,0x90ABCDEF,0x12345678},Conversion.longToIntArray(0x1234567890ABCDEFL,\n    // 0,new int[]{-1,-1,-1,-1},0,4));//rejected by assertion\n    // assertArrayEquals(new\n    // int[]{0xFFFFFFFF,0x90ABCDEF,0x12345678,0x90ABCDEF},Conversion.longToIntArray(0x1234567890ABCDEFL,\n    // 0,new int[]{-1,-1,-1,-1},1,3));\n    assertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF, 0x12345678 }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 2, 2));\n    assertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0x90ABCDEF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 0, new int[] { -1, -1, -1, -1 }, 3, 1));\n    assertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x4855E6F7, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 1, new int[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x242AF37B, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 2, new int[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x121579BD, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 3, new int[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new int[] { 0xFFFFFFFF, 0xFFFFFFFF, 0x890ABCDE, 0xFFFFFFFF }, Conversion.longToIntArray(0x1234567890ABCDEFL, 4, new int[] { -1, -1, -1, -1 }, 2, 1));\n    // assertArrayEquals(new\n    // int[]{0x4855E6F7,0x091A2B3C,0x4855E6F7,0x091A2B3C},Conversion.longToIntArray(0x1234567890ABCDEFL,\n    // 1,new int[]{-1,-1,-1,-1},0,4));//rejected by assertion\n    assertArrayEquals(new int[] { 0x091A2B3C }, Conversion.longToIntArray(0x1234567890ABCDEFL, 33, new int[] { 0 }, 0, 1));\n}",
      "Method_name": "testLongToIntArray",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[longToIntArray(5), longToIntArray(5), longToIntArray(5), longToIntArray(5), longToIntArray(5), longToIntArray(5), longToIntArray(5), longToIntArray(5), longToIntArray(5), longToIntArray(5), longToIntArray(5), longToIntArray(5), longToIntArray(5), longToIntArray(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testLongToIntArray",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testLongToIntArray() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#longToIntArray(long, int, int[], int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts) {\n    if (src.length == 0 && srcPos == 0 || 0 == nShorts) {\n        return dstInit;\n    }\n    if ((nShorts - 1) * 16 + dstPos >= 32) {\n        throw new IllegalArgumentException(\"(nShorts-1)*16+dstPos is greater or equal to than 32\");\n    }\n    int out = dstInit;\n    for (int i = 0; i < nShorts; i++) {\n        final int shift = i * 16 + dstPos;\n        final int bits = (0xffff & src[i + srcPos]) << shift;\n        final int mask = 0xffff << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "short[],int,int,int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "shortArrayToInt(final short() src, final int srcPos, final int dstInit, final int dstPos, final int nShorts)",
      "Method_name": "shortArrayToInt",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###shortArrayToInt",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts an array of short into an int using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the short array to convert\n     * @param srcPos the position in {@code src}, in short unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination int\n     * @param dstPos the position of the lsb, in bits, in the result int\n     * @param nShorts the number of shorts to convert\n     * @return an int containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 32}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nShorts > src.length}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);",
      "Junit_version": "4",
      "returnType": "int"
    },
    "Test_method": {
      "Method_body": "final short[] src = new short[] { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 };\n\rassertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0));\n\rassertEquals(0x0000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1));\n\rassertEquals(0xF0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2));\n\rassertEquals(0x0F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 2));\n\rassertEquals(0x12345678, Conversion.shortArrayToInt(src, 0, 0x12345678, 0, 0));\n\rassertEquals(0xCDF15678, Conversion.shortArrayToInt(src, 0, 0x12345678, 16, 1));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "7",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#shortArrayToInt(short[], int, int, int, int)}.\n */\n@Test\npublic void testShortArrayToInt() {\n    final short[] src = new short[] { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 };\n    assertEquals(0x00000000, Conversion.shortArrayToInt(src, 0, 0, 0, 0));\n    assertEquals(0x0000CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 1));\n    assertEquals(0xF0C1CDF1, Conversion.shortArrayToInt(src, 0, 0, 0, 2));\n    assertEquals(0x0F12F0C1, Conversion.shortArrayToInt(src, 1, 0, 0, 2));\n    assertEquals(0x12345678, Conversion.shortArrayToInt(src, 0, 0x12345678, 0, 0));\n    assertEquals(0xCDF15678, Conversion.shortArrayToInt(src, 0, 0x12345678, 16, 1));\n    // assertEquals(0x34567800,Conversion.ShortArrayToInt(src, 3, 0x12345678, 16, 2));\n}",
      "Method_name": "testShortArrayToInt",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[shortArrayToInt(5), shortArrayToInt(5), shortArrayToInt(5), shortArrayToInt(5), shortArrayToInt(5), shortArrayToInt(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testShortArrayToInt",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testShortArrayToInt() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#shortArrayToInt(short[], int, int, int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts) {\n    if (src.length == 0 && srcPos == 0 || 0 == nShorts) {\n        return dstInit;\n    }\n    if ((nShorts - 1) * 16 + dstPos >= 64) {\n        throw new IllegalArgumentException(\"(nShorts-1)*16+dstPos is greater or equal to than 64\");\n    }\n    long out = dstInit;\n    for (int i = 0; i < nShorts; i++) {\n        final int shift = i * 16 + dstPos;\n        final long bits = (0xffffL & src[i + srcPos]) << shift;\n        final long mask = 0xffffL << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "short[],int,long,int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "shortArrayToLong(final short() src, final int srcPos, final long dstInit, final int dstPos, final int nShorts)",
      "Method_name": "shortArrayToLong",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###shortArrayToLong",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts an array of short into a long using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the short array to convert\n     * @param srcPos the position in {@code src}, in short unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination long\n     * @param dstPos the position of the lsb, in bits, in the result long\n     * @param nShorts the number of shorts to convert\n     * @return a long containing the selected bits\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws IllegalArgumentException if {@code (nShorts-1)*16+dstPos >= 64}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nShorts > src.length}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);",
      "Junit_version": "4",
      "returnType": "long"
    },
    "Test_method": {
      "Method_body": "final short[] src = new short[] { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 };\n\rassertEquals(0x0000000000000000L, Conversion.shortArrayToLong(src, 0, 0L, 0, 0));\n\rassertEquals(0x000000000000CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 1));\n\rassertEquals(0x00000000F0C1CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 2));\n\rassertEquals(0x780034560F12F0C1L, Conversion.shortArrayToLong(src, 1, 0L, 0, 4));\n\rassertEquals(0x123456789ABCDEF0L, Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0));\n\rassertEquals(0x123456CDF1BCDEF0L, Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1));\n\rassertEquals(0x123478003456DEF0L, Conversion.shortArrayToLong(src, 3, 0x123456789ABCDEF0L, 16, 2));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "8",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#shortArrayToLong(short[], int, long, int, int)}.\n */\n@Test\npublic void testShortArrayToLong() {\n    final short[] src = new short[] { (short) 0xCDF1, (short) 0xF0C1, (short) 0x0F12, (short) 0x3456, (short) 0x7800 };\n    assertEquals(0x0000000000000000L, Conversion.shortArrayToLong(src, 0, 0L, 0, 0));\n    assertEquals(0x000000000000CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 1));\n    assertEquals(0x00000000F0C1CDF1L, Conversion.shortArrayToLong(src, 0, 0L, 0, 2));\n    assertEquals(0x780034560F12F0C1L, Conversion.shortArrayToLong(src, 1, 0L, 0, 4));\n    assertEquals(0x123456789ABCDEF0L, Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0));\n    assertEquals(0x123456CDF1BCDEF0L, Conversion.shortArrayToLong(src, 0, 0x123456789ABCDEF0L, 24, 1));\n    assertEquals(0x123478003456DEF0L, Conversion.shortArrayToLong(src, 3, 0x123456789ABCDEF0L, 16, 2));\n}",
      "Method_name": "testShortArrayToLong",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[shortArrayToLong(5), shortArrayToLong(5), shortArrayToLong(5), shortArrayToLong(5), shortArrayToLong(5), shortArrayToLong(5), shortArrayToLong(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testShortArrayToLong",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testShortArrayToLong() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#shortArrayToLong(short[], int, long, int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static Calendar round(final Calendar date, final int field) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    final Calendar rounded = (Calendar) date.clone();\n    modify(rounded, field, ModifyType.ROUND);\n    return rounded;\n}",
      "all_field_declaration": "/**\n * Number of milliseconds in a standard second.\n * @since 2.1\n */\npublic static final long MILLIS_PER_SECOND = 1000;\n/**\n * Number of milliseconds in a standard minute.\n * @since 2.1\n */\npublic static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n/**\n * Number of milliseconds in a standard hour.\n * @since 2.1\n */\npublic static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n/**\n * Number of milliseconds in a standard day.\n * @since 2.1\n */\npublic static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n/**\n * This is half a month, so this represents whether a date is in the top\n * or bottom half of the month.\n */\npublic static final int SEMI_MONTH = 1001;\nprivate static final int[][] fields = { { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */\n}, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } };\n/**\n * A week range, starting on Sunday.\n */\npublic static final int RANGE_WEEK_SUNDAY = 1;\n/**\n * A week range, starting on Monday.\n */\npublic static final int RANGE_WEEK_MONDAY = 2;\n/**\n * A week range, starting on the day focused.\n */\npublic static final int RANGE_WEEK_RELATIVE = 3;\n/**\n * A week range, centered around the day focused.\n */\npublic static final int RANGE_WEEK_CENTER = 4;\n/**\n * A month range, the week starting on Sunday.\n */\npublic static final int RANGE_MONTH_SUNDAY = 5;\n/**\n * A month range, the week starting on Monday.\n */\npublic static final int RANGE_MONTH_MONDAY = 6;",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "Calendar,int",
      "Import_statements": "import java.util.Calendar;\n",
      "public_method_signature": "public DateUtils();\npublic static boolean isSameDay(final Date date1, final Date date2);\npublic static boolean isSameDay(final Calendar cal1, final Calendar cal2);\npublic static boolean isSameInstant(final Date date1, final Date date2);\npublic static boolean isSameInstant(final Calendar cal1, final Calendar cal2);\npublic static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2);\npublic static Date parseDate(final String str, final String... parsePatterns) throws ParseException;\npublic static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException;\npublic static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException;\npublic static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException;\npublic static Date addYears(final Date date, final int amount);\npublic static Date addMonths(final Date date, final int amount);\npublic static Date addWeeks(final Date date, final int amount);\npublic static Date addDays(final Date date, final int amount);\npublic static Date addHours(final Date date, final int amount);\npublic static Date addMinutes(final Date date, final int amount);\npublic static Date addSeconds(final Date date, final int amount);\npublic static Date addMilliseconds(final Date date, final int amount);\npublic static Date setYears(final Date date, final int amount);\npublic static Date setMonths(final Date date, final int amount);\npublic static Date setDays(final Date date, final int amount);\npublic static Date setHours(final Date date, final int amount);\npublic static Date setMinutes(final Date date, final int amount);\npublic static Date setSeconds(final Date date, final int amount);\npublic static Date setMilliseconds(final Date date, final int amount);\npublic static Calendar toCalendar(final Date date);\npublic static Calendar toCalendar(final Date date, final TimeZone tz);\npublic static Date round(final Date date, final int field);\npublic static Calendar round(final Calendar date, final int field);\npublic static Date round(final Object date, final int field);\npublic static Date truncate(final Date date, final int field);\npublic static Calendar truncate(final Calendar date, final int field);\npublic static Date truncate(final Object date, final int field);\npublic static Date ceiling(final Date date, final int field);\npublic static Calendar ceiling(final Calendar date, final int field);\npublic static Date ceiling(final Object date, final int field);\npublic static Iterator<Calendar> iterator(final Date focus, final int rangeStyle);\npublic static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle);\npublic static Iterator<?> iterator(final Object focus, final int rangeStyle);\npublic static long getFragmentInMilliseconds(final Date date, final int fragment);\npublic static long getFragmentInSeconds(final Date date, final int fragment);\npublic static long getFragmentInMinutes(final Date date, final int fragment);\npublic static long getFragmentInHours(final Date date, final int fragment);\npublic static long getFragmentInDays(final Date date, final int fragment);\npublic static long getFragmentInMilliseconds(final Calendar calendar, final int fragment);\npublic static long getFragmentInSeconds(final Calendar calendar, final int fragment);\npublic static long getFragmentInMinutes(final Calendar calendar, final int fragment);\npublic static long getFragmentInHours(final Calendar calendar, final int fragment);\npublic static long getFragmentInDays(final Calendar calendar, final int fragment);\npublic static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field);\npublic static boolean truncatedEquals(final Date date1, final Date date2, final int field);\npublic static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field);\npublic static int truncatedCompareTo(final Date date1, final Date date2, final int field);",
      "public_field": "/**\n * Number of milliseconds in a standard second.\n * @since 2.1\n */\npublic static final long MILLIS_PER_SECOND = 1000;\n/**\n * Number of milliseconds in a standard minute.\n * @since 2.1\n */\npublic static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n/**\n * Number of milliseconds in a standard hour.\n * @since 2.1\n */\npublic static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n/**\n * Number of milliseconds in a standard day.\n * @since 2.1\n */\npublic static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n/**\n * This is half a month, so this represents whether a date is in the top\n * or bottom half of the month.\n */\npublic static final int SEMI_MONTH = 1001;\n/**\n * A week range, starting on Sunday.\n */\npublic static final int RANGE_WEEK_SUNDAY = 1;\n/**\n * A week range, starting on Monday.\n */\npublic static final int RANGE_WEEK_MONDAY = 2;\n/**\n * A week range, starting on the day focused.\n */\npublic static final int RANGE_WEEK_RELATIVE = 3;\n/**\n * A week range, centered around the day focused.\n */\npublic static final int RANGE_WEEK_CENTER = 4;\n/**\n * A month range, the week starting on Sunday.\n */\npublic static final int RANGE_MONTH_SUNDAY = 5;\n/**\n * A month range, the week starting on Monday.\n */\npublic static final int RANGE_MONTH_MONDAY = 6;",
      "Method_statement": "round(final Calendar date, final int field)",
      "Method_name": "round",
      "Class_declaration": "public class DateUtils {\n",
      "constructors": "public DateUtils() {\n    super();\n}",
      "all_method_signature": "public DateUtils();\npublic static boolean isSameDay(final Date date1, final Date date2);\npublic static boolean isSameDay(final Calendar cal1, final Calendar cal2);\npublic static boolean isSameInstant(final Date date1, final Date date2);\npublic static boolean isSameInstant(final Calendar cal1, final Calendar cal2);\npublic static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2);\npublic static Date parseDate(final String str, final String... parsePatterns) throws ParseException;\npublic static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException;\npublic static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException;\npublic static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException;\nprivate static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException;\npublic static Date addYears(final Date date, final int amount);\npublic static Date addMonths(final Date date, final int amount);\npublic static Date addWeeks(final Date date, final int amount);\npublic static Date addDays(final Date date, final int amount);\npublic static Date addHours(final Date date, final int amount);\npublic static Date addMinutes(final Date date, final int amount);\npublic static Date addSeconds(final Date date, final int amount);\npublic static Date addMilliseconds(final Date date, final int amount);\nprivate static Date add(final Date date, final int calendarField, final int amount);\npublic static Date setYears(final Date date, final int amount);\npublic static Date setMonths(final Date date, final int amount);\npublic static Date setDays(final Date date, final int amount);\npublic static Date setHours(final Date date, final int amount);\npublic static Date setMinutes(final Date date, final int amount);\npublic static Date setSeconds(final Date date, final int amount);\npublic static Date setMilliseconds(final Date date, final int amount);\nprivate static Date set(final Date date, final int calendarField, final int amount);\npublic static Calendar toCalendar(final Date date);\npublic static Calendar toCalendar(final Date date, final TimeZone tz);\npublic static Date round(final Date date, final int field);\npublic static Calendar round(final Calendar date, final int field);\npublic static Date round(final Object date, final int field);\npublic static Date truncate(final Date date, final int field);\npublic static Calendar truncate(final Calendar date, final int field);\npublic static Date truncate(final Object date, final int field);\npublic static Date ceiling(final Date date, final int field);\npublic static Calendar ceiling(final Calendar date, final int field);\npublic static Date ceiling(final Object date, final int field);\nprivate static void modify(final Calendar val, final int field, final ModifyType modType);\npublic static Iterator<Calendar> iterator(final Date focus, final int rangeStyle);\npublic static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle);\npublic static Iterator<?> iterator(final Object focus, final int rangeStyle);\npublic static long getFragmentInMilliseconds(final Date date, final int fragment);\npublic static long getFragmentInSeconds(final Date date, final int fragment);\npublic static long getFragmentInMinutes(final Date date, final int fragment);\npublic static long getFragmentInHours(final Date date, final int fragment);\npublic static long getFragmentInDays(final Date date, final int fragment);\npublic static long getFragmentInMilliseconds(final Calendar calendar, final int fragment);\npublic static long getFragmentInSeconds(final Calendar calendar, final int fragment);\npublic static long getFragmentInMinutes(final Calendar calendar, final int fragment);\npublic static long getFragmentInHours(final Calendar calendar, final int fragment);\npublic static long getFragmentInDays(final Calendar calendar, final int fragment);\nprivate static long getFragment(final Date date, final int fragment, final TimeUnit unit);\nprivate static long getFragment(final Calendar calendar, final int fragment, final TimeUnit unit);\npublic static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field);\npublic static boolean truncatedEquals(final Date date1, final Date date2, final int field);\npublic static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field);\npublic static int truncatedCompareTo(final Date date1, final Date date2, final int field);\nprivate static void validateDateNotNull(final Date date);",
      "Class_name": "DateUtils",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/time/DateUtils###round",
      "Parameter_num": "2",
      "all_Import_statements": "import java.text.ParseException;\n\nimport java.text.ParsePosition;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n\nimport java.util.Iterator;\n\nimport java.util.Locale;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.TimeZone;\n\nimport java.util.concurrent.TimeUnit;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n\nimport org.apache.commons.lang3.Validate;\n",
      "comment": "\n     * <p>Rounds a date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the date-time of 28 Mar 2002\n     * 13:45:01.231, if this was passed with HOUR, it would return\n     * 28 Mar 2002 14:00:00.000. If this was passed with MONTH, it\n     * would return 1 April 2002 0:00:00.000.</p>\n     *\n     * <p>For a date in a timezone that handles the change to daylight\n     * saving time, rounding to Calendar.HOUR_OF_DAY will behave as follows.\n     * Suppose daylight saving time begins at 02:00 on March 30. Rounding a\n     * date that crosses this time would produce the following values:\n     * </p>\n     * <ul>\n     * <li>March 30, 2003 01:10 rounds to March 30, 2003 01:00</li>\n     * <li>March 30, 2003 01:40 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:10 rounds to March 30, 2003 03:00</li>\n     * <li>March 30, 2003 02:40 rounds to March 30, 2003 04:00</li>\n     * </ul>\n     *\n     * @param date  the date to work with, not null\n     * @param field  the field from {@code Calendar} or <code>SEMI_MONTH</code>\n     * @return the different rounded date, not null\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     ",
      "packageName": "org.apache.commons.lang3.time",
      "method_signature": "public static Calendar round(final Calendar date, final int field);",
      "Junit_version": "4",
      "returnType": "Calendar"
    },
    "Test_method": {
      "Method_body": "// tests for public static Date round(Date date, int field)\nassertEquals(\"round year-1 failed\", dateParser.parse(\"January 1, 2002\"), DateUtils.round(date1, Calendar.YEAR));\n\rassertEquals(\"round year-2 failed\", dateParser.parse(\"January 1, 2002\"), DateUtils.round(date2, Calendar.YEAR));\n\rassertEquals(\"round month-1 failed\", dateParser.parse(\"February 1, 2002\"), DateUtils.round(date1, Calendar.MONTH));\n\rassertEquals(\"round month-2 failed\", dateParser.parse(\"December 1, 2001\"), DateUtils.round(date2, Calendar.MONTH));\n\rassertEquals(\"round semimonth-0 failed\", dateParser.parse(\"February 1, 2002\"), DateUtils.round(date0, DateUtils.SEMI_MONTH));\n\rassertEquals(\"round semimonth-1 failed\", dateParser.parse(\"February 16, 2002\"), DateUtils.round(date1, DateUtils.SEMI_MONTH));\n\rassertEquals(\"round semimonth-2 failed\", dateParser.parse(\"November 16, 2001\"), DateUtils.round(date2, DateUtils.SEMI_MONTH));\n\rassertEquals(\"round date-1 failed\", dateParser.parse(\"February 13, 2002\"), DateUtils.round(date1, Calendar.DATE));\n\rassertEquals(\"round date-2 failed\", dateParser.parse(\"November 18, 2001\"), DateUtils.round(date2, Calendar.DATE));\n\rassertEquals(\"round hour-1 failed\", dateTimeParser.parse(\"February 12, 2002 13:00:00.000\"), DateUtils.round(date1, Calendar.HOUR));\n\rassertEquals(\"round hour-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"), DateUtils.round(date2, Calendar.HOUR));\n\rassertEquals(\"round minute-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:35:00.000\"), DateUtils.round(date1, Calendar.MINUTE));\n\rassertEquals(\"round minute-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"), DateUtils.round(date2, Calendar.MINUTE));\n\rassertEquals(\"round second-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"), DateUtils.round(date1, Calendar.SECOND));\n\rassertEquals(\"round second-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.round(date2, Calendar.SECOND));\n\rassertEquals(\"round ampm-1 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.round(dateAmPm1, Calendar.AM_PM));\n\rassertEquals(\"round ampm-2 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round(dateAmPm2, Calendar.AM_PM));\n\rassertEquals(\"round ampm-3 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round(dateAmPm3, Calendar.AM_PM));\n\rassertEquals(\"round ampm-4 failed\", dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"), DateUtils.round(dateAmPm4, Calendar.AM_PM));\n\r// tests for public static Date round(Object date, int field)\nassertEquals(\"round year-1 failed\", dateParser.parse(\"January 1, 2002\"), DateUtils.round((Object) date1, Calendar.YEAR));\n\rassertEquals(\"round year-2 failed\", dateParser.parse(\"January 1, 2002\"), DateUtils.round((Object) date2, Calendar.YEAR));\n\rassertEquals(\"round month-1 failed\", dateParser.parse(\"February 1, 2002\"), DateUtils.round((Object) date1, Calendar.MONTH));\n\rassertEquals(\"round month-2 failed\", dateParser.parse(\"December 1, 2001\"), DateUtils.round((Object) date2, Calendar.MONTH));\n\rassertEquals(\"round semimonth-1 failed\", dateParser.parse(\"February 16, 2002\"), DateUtils.round((Object) date1, DateUtils.SEMI_MONTH));\n\rassertEquals(\"round semimonth-2 failed\", dateParser.parse(\"November 16, 2001\"), DateUtils.round((Object) date2, DateUtils.SEMI_MONTH));\n\rassertEquals(\"round date-1 failed\", dateParser.parse(\"February 13, 2002\"), DateUtils.round((Object) date1, Calendar.DATE));\n\rassertEquals(\"round date-2 failed\", dateParser.parse(\"November 18, 2001\"), DateUtils.round((Object) date2, Calendar.DATE));\n\rassertEquals(\"round hour-1 failed\", dateTimeParser.parse(\"February 12, 2002 13:00:00.000\"), DateUtils.round((Object) date1, Calendar.HOUR));\n\rassertEquals(\"round hour-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"), DateUtils.round((Object) date2, Calendar.HOUR));\n\rassertEquals(\"round minute-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:35:00.000\"), DateUtils.round((Object) date1, Calendar.MINUTE));\n\rassertEquals(\"round minute-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"), DateUtils.round((Object) date2, Calendar.MINUTE));\n\rassertEquals(\"round second-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"), DateUtils.round((Object) date1, Calendar.SECOND));\n\rassertEquals(\"round second-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.round((Object) date2, Calendar.SECOND));\n\rassertEquals(\"round calendar second-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"), DateUtils.round((Object) cal1, Calendar.SECOND));\n\rassertEquals(\"round calendar second-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.round((Object) cal2, Calendar.SECOND));\n\rassertEquals(\"round ampm-1 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.round((Object) dateAmPm1, Calendar.AM_PM));\n\rassertEquals(\"round ampm-2 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round((Object) dateAmPm2, Calendar.AM_PM));\n\rassertEquals(\"round ampm-3 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round((Object) dateAmPm3, Calendar.AM_PM));\n\rassertEquals(\"round ampm-4 failed\", dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"), DateUtils.round((Object) dateAmPm4, Calendar.AM_PM));\n\rtry {\n    DateUtils.round((Date) null, Calendar.SECOND);\n    fail();\n} catch (final IllegalArgumentException ex) {\n}\n\rtry {\n    DateUtils.round((Calendar) null, Calendar.SECOND);\n    fail();\n} catch (final IllegalArgumentException ex) {\n}\n\rtry {\n    DateUtils.round((Object) null, Calendar.SECOND);\n    fail();\n} catch (final IllegalArgumentException ex) {\n}\n\rtry {\n    DateUtils.round(\"\", Calendar.SECOND);\n    fail();\n} catch (final ClassCastException ex) {\n}\n\rtry {\n    DateUtils.round(date1, -9999);\n    fail();\n} catch (final IllegalArgumentException ex) {\n}\n\rassertEquals(\"round ampm-1 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.round((Object) calAmPm1, Calendar.AM_PM));\n\rassertEquals(\"round ampm-2 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round((Object) calAmPm2, Calendar.AM_PM));\n\rassertEquals(\"round ampm-3 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round((Object) calAmPm3, Calendar.AM_PM));\n\rassertEquals(\"round ampm-4 failed\", dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"), DateUtils.round((Object) calAmPm4, Calendar.AM_PM));\n\r// Fix for http://issues.apache.org/bugzilla/show_bug.cgi?id=25560 / LANG-13\n// Test rounding across the beginning of daylight saving time\ntry {\n    TimeZone.setDefault(zone);\n    dateTimeParser.setTimeZone(zone);\n    assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round(date4, Calendar.DATE));\n    assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round((Object) cal4, Calendar.DATE));\n    assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round(date5, Calendar.DATE));\n    assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round((Object) cal5, Calendar.DATE));\n    assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round(date6, Calendar.DATE));\n    assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round((Object) cal6, Calendar.DATE));\n    assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round(date7, Calendar.DATE));\n    assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round((Object) cal7, Calendar.DATE));\n    assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 01:00:00.000\"), DateUtils.round(date4, Calendar.HOUR_OF_DAY));\n    assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 01:00:00.000\"), DateUtils.round((Object) cal4, Calendar.HOUR_OF_DAY));\n    assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"), DateUtils.round(date5, Calendar.HOUR_OF_DAY));\n    assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"), DateUtils.round((Object) cal5, Calendar.HOUR_OF_DAY));\n    assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"), DateUtils.round(date6, Calendar.HOUR_OF_DAY));\n    assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"), DateUtils.round((Object) cal6, Calendar.HOUR_OF_DAY));\n    assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"), DateUtils.round(date7, Calendar.HOUR_OF_DAY));\n    assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"), DateUtils.round((Object) cal7, Calendar.HOUR_OF_DAY));\n} finally {\n    TimeZone.setDefault(defaultZone);\n    dateTimeParser.setTimeZone(defaultZone);\n}",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "49",
      "Filed": "private DateFormat dateParser = null;private DateFormat dateTimeParser = null;private Date dateAmPm1 = null;private Date dateAmPm2 = null;private Date dateAmPm3 = null;private Date dateAmPm4 = null;private Date date0 = null;private Date date1 = null;private Date date2 = null;private Date date4 = null;private Date date5 = null;private Date date6 = null;private Date date7 = null;private Calendar calAmPm1 = null;private Calendar calAmPm2 = null;private Calendar calAmPm3 = null;private Calendar calAmPm4 = null;private Calendar cal1 = null;private Calendar cal2 = null;private Calendar cal4 = null;private Calendar cal5 = null;private Calendar cal6 = null;private Calendar cal7 = null;private TimeZone zone = null;private TimeZone defaultZone = null;",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport org.junit.Test;\n",
      "allMethod_info": "// -----------------------------------------------------------------------\n/**\n * Tests various values with the round method\n *\n * @throws java.lang.Exception so we don't have to catch it\n */\n@Test\npublic void testRound() throws Exception {\n    // tests for public static Date round(Date date, int field)\n    assertEquals(\"round year-1 failed\", dateParser.parse(\"January 1, 2002\"), DateUtils.round(date1, Calendar.YEAR));\n    assertEquals(\"round year-2 failed\", dateParser.parse(\"January 1, 2002\"), DateUtils.round(date2, Calendar.YEAR));\n    assertEquals(\"round month-1 failed\", dateParser.parse(\"February 1, 2002\"), DateUtils.round(date1, Calendar.MONTH));\n    assertEquals(\"round month-2 failed\", dateParser.parse(\"December 1, 2001\"), DateUtils.round(date2, Calendar.MONTH));\n    assertEquals(\"round semimonth-0 failed\", dateParser.parse(\"February 1, 2002\"), DateUtils.round(date0, DateUtils.SEMI_MONTH));\n    assertEquals(\"round semimonth-1 failed\", dateParser.parse(\"February 16, 2002\"), DateUtils.round(date1, DateUtils.SEMI_MONTH));\n    assertEquals(\"round semimonth-2 failed\", dateParser.parse(\"November 16, 2001\"), DateUtils.round(date2, DateUtils.SEMI_MONTH));\n    assertEquals(\"round date-1 failed\", dateParser.parse(\"February 13, 2002\"), DateUtils.round(date1, Calendar.DATE));\n    assertEquals(\"round date-2 failed\", dateParser.parse(\"November 18, 2001\"), DateUtils.round(date2, Calendar.DATE));\n    assertEquals(\"round hour-1 failed\", dateTimeParser.parse(\"February 12, 2002 13:00:00.000\"), DateUtils.round(date1, Calendar.HOUR));\n    assertEquals(\"round hour-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"), DateUtils.round(date2, Calendar.HOUR));\n    assertEquals(\"round minute-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:35:00.000\"), DateUtils.round(date1, Calendar.MINUTE));\n    assertEquals(\"round minute-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"), DateUtils.round(date2, Calendar.MINUTE));\n    assertEquals(\"round second-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"), DateUtils.round(date1, Calendar.SECOND));\n    assertEquals(\"round second-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.round(date2, Calendar.SECOND));\n    assertEquals(\"round ampm-1 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.round(dateAmPm1, Calendar.AM_PM));\n    assertEquals(\"round ampm-2 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round(dateAmPm2, Calendar.AM_PM));\n    assertEquals(\"round ampm-3 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round(dateAmPm3, Calendar.AM_PM));\n    assertEquals(\"round ampm-4 failed\", dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"), DateUtils.round(dateAmPm4, Calendar.AM_PM));\n    // tests for public static Date round(Object date, int field)\n    assertEquals(\"round year-1 failed\", dateParser.parse(\"January 1, 2002\"), DateUtils.round((Object) date1, Calendar.YEAR));\n    assertEquals(\"round year-2 failed\", dateParser.parse(\"January 1, 2002\"), DateUtils.round((Object) date2, Calendar.YEAR));\n    assertEquals(\"round month-1 failed\", dateParser.parse(\"February 1, 2002\"), DateUtils.round((Object) date1, Calendar.MONTH));\n    assertEquals(\"round month-2 failed\", dateParser.parse(\"December 1, 2001\"), DateUtils.round((Object) date2, Calendar.MONTH));\n    assertEquals(\"round semimonth-1 failed\", dateParser.parse(\"February 16, 2002\"), DateUtils.round((Object) date1, DateUtils.SEMI_MONTH));\n    assertEquals(\"round semimonth-2 failed\", dateParser.parse(\"November 16, 2001\"), DateUtils.round((Object) date2, DateUtils.SEMI_MONTH));\n    assertEquals(\"round date-1 failed\", dateParser.parse(\"February 13, 2002\"), DateUtils.round((Object) date1, Calendar.DATE));\n    assertEquals(\"round date-2 failed\", dateParser.parse(\"November 18, 2001\"), DateUtils.round((Object) date2, Calendar.DATE));\n    assertEquals(\"round hour-1 failed\", dateTimeParser.parse(\"February 12, 2002 13:00:00.000\"), DateUtils.round((Object) date1, Calendar.HOUR));\n    assertEquals(\"round hour-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"), DateUtils.round((Object) date2, Calendar.HOUR));\n    assertEquals(\"round minute-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:35:00.000\"), DateUtils.round((Object) date1, Calendar.MINUTE));\n    assertEquals(\"round minute-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"), DateUtils.round((Object) date2, Calendar.MINUTE));\n    assertEquals(\"round second-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"), DateUtils.round((Object) date1, Calendar.SECOND));\n    assertEquals(\"round second-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.round((Object) date2, Calendar.SECOND));\n    assertEquals(\"round calendar second-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:34:57.000\"), DateUtils.round((Object) cal1, Calendar.SECOND));\n    assertEquals(\"round calendar second-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.round((Object) cal2, Calendar.SECOND));\n    assertEquals(\"round ampm-1 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.round((Object) dateAmPm1, Calendar.AM_PM));\n    assertEquals(\"round ampm-2 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round((Object) dateAmPm2, Calendar.AM_PM));\n    assertEquals(\"round ampm-3 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round((Object) dateAmPm3, Calendar.AM_PM));\n    assertEquals(\"round ampm-4 failed\", dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"), DateUtils.round((Object) dateAmPm4, Calendar.AM_PM));\n    try {\n        DateUtils.round((Date) null, Calendar.SECOND);\n        fail();\n    } catch (final IllegalArgumentException ex) {\n    }\n    try {\n        DateUtils.round((Calendar) null, Calendar.SECOND);\n        fail();\n    } catch (final IllegalArgumentException ex) {\n    }\n    try {\n        DateUtils.round((Object) null, Calendar.SECOND);\n        fail();\n    } catch (final IllegalArgumentException ex) {\n    }\n    try {\n        DateUtils.round(\"\", Calendar.SECOND);\n        fail();\n    } catch (final ClassCastException ex) {\n    }\n    try {\n        DateUtils.round(date1, -9999);\n        fail();\n    } catch (final IllegalArgumentException ex) {\n    }\n    assertEquals(\"round ampm-1 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.round((Object) calAmPm1, Calendar.AM_PM));\n    assertEquals(\"round ampm-2 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round((Object) calAmPm2, Calendar.AM_PM));\n    assertEquals(\"round ampm-3 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.round((Object) calAmPm3, Calendar.AM_PM));\n    assertEquals(\"round ampm-4 failed\", dateTimeParser.parse(\"February 4, 2002 00:00:00.000\"), DateUtils.round((Object) calAmPm4, Calendar.AM_PM));\n    // Fix for http://issues.apache.org/bugzilla/show_bug.cgi?id=25560 / LANG-13\n    // Test rounding across the beginning of daylight saving time\n    try {\n        TimeZone.setDefault(zone);\n        dateTimeParser.setTimeZone(zone);\n        assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round(date4, Calendar.DATE));\n        assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round((Object) cal4, Calendar.DATE));\n        assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round(date5, Calendar.DATE));\n        assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round((Object) cal5, Calendar.DATE));\n        assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round(date6, Calendar.DATE));\n        assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round((Object) cal6, Calendar.DATE));\n        assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round(date7, Calendar.DATE));\n        assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.round((Object) cal7, Calendar.DATE));\n        assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 01:00:00.000\"), DateUtils.round(date4, Calendar.HOUR_OF_DAY));\n        assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 01:00:00.000\"), DateUtils.round((Object) cal4, Calendar.HOUR_OF_DAY));\n        assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"), DateUtils.round(date5, Calendar.HOUR_OF_DAY));\n        assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"), DateUtils.round((Object) cal5, Calendar.HOUR_OF_DAY));\n        assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"), DateUtils.round(date6, Calendar.HOUR_OF_DAY));\n        assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 03:00:00.000\"), DateUtils.round((Object) cal6, Calendar.HOUR_OF_DAY));\n        assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"), DateUtils.round(date7, Calendar.HOUR_OF_DAY));\n        assertEquals(\"round MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 04:00:00.000\"), DateUtils.round((Object) cal7, Calendar.HOUR_OF_DAY));\n    } finally {\n        TimeZone.setDefault(defaultZone);\n        dateTimeParser.setTimeZone(defaultZone);\n    }\n}",
      "Method_name": "testRound",
      "Class_declaration": "public class DateUtilsTest {\n",
      "constructors": "",
      "Class_name": "DateUtilsTest",
      "methodName_paraNum": "[parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), round(2), fail(0), round(2), fail(0), round(2), fail(0), round(2), fail(0), round(2), fail(0), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), setDefault(1), setTimeZone(1), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), parse(1), round(2), setDefault(1), setTimeZone(1)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/time/DateUtilsTest###testRound",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java",
      "Signature": "public void testRound() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertNotSame;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.junit.Assert.fail;\n\nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Modifier;\n\nimport java.text.DateFormat;\n\nimport java.text.ParseException;\n\nimport java.text.SimpleDateFormat;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n\nimport java.util.GregorianCalendar;\n\nimport java.util.Iterator;\n\nimport java.util.Locale;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang3.test.SystemDefaults;\n\nimport org.apache.commons.lang3.test.SystemDefaultsSwitch;\n\nimport org.junit.Before;\n\nimport org.junit.BeforeClass;\n\nimport org.junit.Rule;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests various values with the round method\n     *\n     * @throws java.lang.Exception so we don't have to catch it\n     ",
      "packageName": "org.apache.commons.lang3.time",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static double logSum(double[] logProps) {\n    double logPropSum = Double.NEGATIVE_INFINITY;\n    for (int d = 0; d < logProps.length; d++) {\n        logPropSum = FastMath.logAdd(logPropSum, logProps[d]);\n    }\n    return logPropSum;\n}",
      "all_field_declaration": "",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "3",
      "Filed": "",
      "Parameter_type": "double[]",
      "Import_statements": "import edu.jhu.prim.util.math.FastMath;\n",
      "public_method_signature": "public static double[] copyOf(double[] original, int newLength);\npublic static double[] copyOf(double[] original);\npublic static double[][] copyOf(double[][] array);\npublic static double[][][] copyOf(double[][][] array);\npublic static double[][][][] copyOf(double[][][][] array);\npublic static void copy(double[] array, double[] clone);\npublic static void copy(double[][] array, double[][] clone);\npublic static void copy(double[][][] array, double[][][] clone);\npublic static void copy(double[][][][] array, double[][][][] clone);\npublic static void fill(final double[] array, final double value);\npublic static void fill(double[][] array, double value);\npublic static void fill(double[][][] array, double value);\npublic static void fill(double[][][][] array, double value);\npublic static String toString(double[] array, String formatString);\npublic static String deepToString(double[][] array);\npublic static double sum(double[] vector);\npublic static double prod(double[] vector);\npublic static void assertNoZeroes(double[] draw, double[] logDraw);\npublic static void assertNoNegInfs(double[] logDraw);\npublic static void assertNoZeros(double[] draw);\npublic static void assertSameSize(double[][] newLogPhi, double[][] logPhi);\npublic static double[] getExp(double[] logPhi);\npublic static void exp(double[] phi);\npublic static void log(double[] phi);\npublic static void log(double[][] phi);\npublic static void logForIlp(double[] phi);\npublic static double[] getLog(double[] phi);\npublic static double[] getLogForIlp(double[] phi);\npublic static void updateLogPhi(double[] phi, double[] logPhi);\npublic static double sum(double[][] matrix);\npublic static double max(double[] array);\npublic static double min(double[] array);\npublic static int argmax(double[] array);\npublic static int argmin(double[] array);\npublic static IntTuple getArgmax(double[][] array);\npublic static IntTuple getArgmax(double[][] array, double delta);\npublic static double dotProduct(double[] array1, double[] array2);\npublic static void scale(double[] array, double alpha);\npublic static void scale(double[][] array, double alpha);\npublic static double mean(double[] array);\npublic static double variance(double[] array);\npublic static double stdDev(double[] array);\npublic static double logSum(double[] logProps);\npublic static void add(double[] params, double lambda);\npublic static void add(double[] array1, double[] array2);\npublic static void subtract(double[] array1, double[] array2);\npublic static void multiply(double[] array1, double[] array2);\npublic static void divide(double[] array1, double[] array2);\npublic static double l1norm(double[] array);\npublic static double l2norm(double[] array);\npublic static double infinityNorm(double[] gradient);\npublic static double infinityNorm(double[][] gradient);\npublic static boolean isInRange(double[] p, double min, double max);\npublic static void reorder(double[] array, int[] order);\npublic static boolean contains(double[] array, double value, double delta);\npublic static boolean contains(double[][] array, double value, double delta);\npublic static void shuffle(double[] array);\npublic static int indexOf(double[] array, double val);\npublic static int lastIndexOf(double[] array, double val);\npublic static int count(double[] array, double val);\npublic static double[] newFilled(int length, double val);",
      "public_field": "",
      "Method_statement": "logSum(double() logProps)",
      "Method_name": "logSum",
      "Class_declaration": "public class DoubleArrays {\n",
      "constructors": "private DoubleArrays() {\n}",
      "all_method_signature": "private DoubleArrays();\npublic static double[] copyOf(double[] original, int newLength);\npublic static double[] copyOf(double[] original);\npublic static double[][] copyOf(double[][] array);\npublic static double[][][] copyOf(double[][][] array);\npublic static double[][][][] copyOf(double[][][][] array);\npublic static void copy(double[] array, double[] clone);\npublic static void copy(double[][] array, double[][] clone);\npublic static void copy(double[][][] array, double[][][] clone);\npublic static void copy(double[][][][] array, double[][][][] clone);\npublic static void fill(final double[] array, final double value);\npublic static void fill(double[][] array, double value);\npublic static void fill(double[][][] array, double value);\npublic static void fill(double[][][][] array, double value);\npublic static String toString(double[] array, String formatString);\npublic static String deepToString(double[][] array);\npublic static double sum(double[] vector);\npublic static double prod(double[] vector);\npublic static void assertNoZeroes(double[] draw, double[] logDraw);\npublic static void assertNoNegInfs(double[] logDraw);\npublic static void assertNoZeros(double[] draw);\npublic static void assertSameSize(double[][] newLogPhi, double[][] logPhi);\npublic static double[] getExp(double[] logPhi);\npublic static void exp(double[] phi);\npublic static void log(double[] phi);\npublic static void log(double[][] phi);\npublic static void logForIlp(double[] phi);\npublic static double[] getLog(double[] phi);\npublic static double[] getLogForIlp(double[] phi);\npublic static void updateLogPhi(double[] phi, double[] logPhi);\npublic static double sum(double[][] matrix);\npublic static double max(double[] array);\npublic static double min(double[] array);\npublic static int argmax(double[] array);\npublic static int argmin(double[] array);\npublic static IntTuple getArgmax(double[][] array);\npublic static IntTuple getArgmax(double[][] array, double delta);\npublic static double dotProduct(double[] array1, double[] array2);\npublic static void scale(double[] array, double alpha);\npublic static void scale(double[][] array, double alpha);\npublic static double mean(double[] array);\npublic static double variance(double[] array);\npublic static double stdDev(double[] array);\npublic static double logSum(double[] logProps);\npublic static void add(double[] params, double lambda);\npublic static void add(double[] array1, double[] array2);\npublic static void subtract(double[] array1, double[] array2);\npublic static void multiply(double[] array1, double[] array2);\npublic static void divide(double[] array1, double[] array2);\npublic static double l1norm(double[] array);\npublic static double l2norm(double[] array);\npublic static double infinityNorm(double[] gradient);\npublic static double infinityNorm(double[][] gradient);\npublic static boolean isInRange(double[] p, double min, double max);\npublic static void reorder(double[] array, int[] order);\npublic static boolean contains(double[] array, double value, double delta);\npublic static boolean contains(double[][] array, double value, double delta);\npublic static void shuffle(double[] array);\npublic static int indexOf(double[] array, double val);\npublic static int lastIndexOf(double[] array, double val);\npublic static int count(double[] array, double val);\npublic static double[] newFilled(int length, double val);",
      "Class_name": "DoubleArrays",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java/edu/jhu/prim/arrays/DoubleArrays###logSum",
      "Parameter_num": "1",
      "all_Import_statements": "import java.util.Arrays;\n\nimport edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.tuple.IntTuple;\n\nimport edu.jhu.prim.util.math.FastMath;\n\nimport edu.jhu.prim.util.random.Prng;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.arrays",
      "method_signature": "public static double logSum(double[] logProps);",
      "Junit_version": "4",
      "returnType": "double"
    },
    "Test_method": {
      "Method_body": "assertEquals(Double.POSITIVE_INFINITY, DoubleArrays.logSum(new double[] { Double.POSITIVE_INFINITY, 0.1 }), 1e-13);\n\rboolean old = FastMath.useLogAddTable;\n\rFastMath.useLogAddTable = false;\n\rassertEquals(Double.POSITIVE_INFINITY, DoubleArrays.logSum(new double[] { Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY }), 1e-13);\n\rFastMath.useLogAddTable = true;\n\rassertEquals(Double.POSITIVE_INFINITY, DoubleArrays.logSum(new double[] { Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY }), 1e-13);\n\rFastMath.useLogAddTable = old;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "7",
      "Filed": "",
      "Import_statements": "import java.util.Arrays;\nimport edu.jhu.prim.util.math.FastMath;\n",
      "allMethod_info": "@Test\npublic void testLogSum() {\n    assertEquals(Double.POSITIVE_INFINITY, DoubleArrays.logSum(new double[] { Double.POSITIVE_INFINITY, 0.1 }), 1e-13);\n    boolean old = FastMath.useLogAddTable;\n    FastMath.useLogAddTable = false;\n    assertEquals(Double.POSITIVE_INFINITY, DoubleArrays.logSum(new double[] { Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY }), 1e-13);\n    FastMath.useLogAddTable = true;\n    assertEquals(Double.POSITIVE_INFINITY, DoubleArrays.logSum(new double[] { Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY }), 1e-13);\n    FastMath.useLogAddTable = old;\n}",
      "Method_name": "testLogSum",
      "Class_declaration": "public class DoubleArraysTest {\n",
      "constructors": "",
      "Class_name": "DoubleArraysTest",
      "methodName_paraNum": "[logSum(1), logSum(1), logSum(1)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java/edu/jhu/prim/arrays/DoubleArraysTest###testLogSum",
      "relativePath": "mgormley_prim/src/test/java/edu/jhu/prim/arrays/DoubleArraysTest.java",
      "Signature": "public void testLogSum() {\n",
      "all_Import_statements": "import static org.junit.Assert.*;\n\nimport java.util.Arrays;\n\nimport org.junit.Test;\n\nimport edu.jhu.prim.util.Timer;\n\nimport edu.jhu.prim.util.math.FastMath;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.arrays",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements) {\n    String duration = formatDuration(durationMillis, \"d' days 'H' hours 'm' minutes 's' seconds'\");\n    if (suppressLeadingZeroElements) {\n        duration = \" \" + duration;\n        String tmp = StringUtils.replaceOnce(duration, \" 0 days\", StringUtils.EMPTY);\n        if (tmp.length() != duration.length()) {\n            duration = tmp;\n            tmp = StringUtils.replaceOnce(duration, \" 0 hours\", StringUtils.EMPTY);\n            if (tmp.length() != duration.length()) {\n                duration = tmp;\n                tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", StringUtils.EMPTY);\n                duration = tmp;\n                if (tmp.length() != duration.length()) {\n                    duration = StringUtils.replaceOnce(tmp, \" 0 seconds\", StringUtils.EMPTY);\n                }\n            }\n        }\n        if (duration.length() != 0) {\n            duration = duration.substring(1);\n        }\n    }\n    if (suppressTrailingZeroElements) {\n        String tmp = StringUtils.replaceOnce(duration, \" 0 seconds\", StringUtils.EMPTY);\n        if (tmp.length() != duration.length()) {\n            duration = tmp;\n            tmp = StringUtils.replaceOnce(duration, \" 0 minutes\", StringUtils.EMPTY);\n            if (tmp.length() != duration.length()) {\n                duration = tmp;\n                tmp = StringUtils.replaceOnce(duration, \" 0 hours\", StringUtils.EMPTY);\n                if (tmp.length() != duration.length()) {\n                    duration = StringUtils.replaceOnce(tmp, \" 0 days\", StringUtils.EMPTY);\n                }\n            }\n        }\n    }\n    duration = \" \" + duration;\n    duration = StringUtils.replaceOnce(duration, \" 1 seconds\", \" 1 second\");\n    duration = StringUtils.replaceOnce(duration, \" 1 minutes\", \" 1 minute\");\n    duration = StringUtils.replaceOnce(duration, \" 1 hours\", \" 1 hour\");\n    duration = StringUtils.replaceOnce(duration, \" 1 days\", \" 1 day\");\n    return duration.trim();\n}",
      "all_field_declaration": "/**\n * <p>Pattern used with <code>FastDateFormat</code> and <code>SimpleDateFormat</code>\n * for the ISO 8601 period format used in durations.</p>\n *\n * @see org.apache.commons.lang3.time.FastDateFormat\n * @see java.text.SimpleDateFormat\n */\npublic static final String ISO_EXTENDED_FORMAT_PATTERN = \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.SSS'S'\";\nstatic final Object y = \"y\";\nstatic final Object M = \"M\";\nstatic final Object d = \"d\";\nstatic final Object H = \"H\";\nstatic final Object m = \"m\";\nstatic final Object s = \"s\";\nstatic final Object S = \"S\";",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "9",
      "Filed": "static final Object y = \"y\";static final Object M = \"M\";static final Object d = \"d\";static final Object H = \"H\";static final Object m = \"m\";static final Object s = \"s\";static final Object S = \"S\";",
      "Parameter_type": "long,boolean,boolean",
      "Import_statements": "import org.apache.commons.lang3.StringUtils;\n",
      "public_method_signature": "public DurationFormatUtils();\npublic static String formatDurationHMS(final long durationMillis);\npublic static String formatDurationISO(final long durationMillis);\npublic static String formatDuration(final long durationMillis, final String format);\npublic static String formatDuration(final long durationMillis, final String format, final boolean padWithZeros);\npublic static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements);\npublic static String formatPeriodISO(final long startMillis, final long endMillis);\npublic static String formatPeriod(final long startMillis, final long endMillis, final String format);\npublic static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone);",
      "public_field": "/**\n * <p>Pattern used with <code>FastDateFormat</code> and <code>SimpleDateFormat</code>\n * for the ISO 8601 period format used in durations.</p>\n *\n * @see org.apache.commons.lang3.time.FastDateFormat\n * @see java.text.SimpleDateFormat\n */\npublic static final String ISO_EXTENDED_FORMAT_PATTERN = \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.SSS'S'\";",
      "Method_statement": "formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements)",
      "Method_name": "formatDurationWords",
      "Class_declaration": "public class DurationFormatUtils {\n",
      "constructors": "public DurationFormatUtils() {\n    super();\n}",
      "all_method_signature": "public DurationFormatUtils();\npublic static String formatDurationHMS(final long durationMillis);\npublic static String formatDurationISO(final long durationMillis);\npublic static String formatDuration(final long durationMillis, final String format);\npublic static String formatDuration(final long durationMillis, final String format, final boolean padWithZeros);\npublic static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements);\npublic static String formatPeriodISO(final long startMillis, final long endMillis);\npublic static String formatPeriod(final long startMillis, final long endMillis, final String format);\npublic static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone);\n static String format(final Token[] tokens, final long years, final long months, final long days, final long hours, final long minutes, final long seconds, final long milliseconds, final boolean padWithZeros);\nprivate static String paddedValue(final long value, final boolean padWithZeros, final int count);\n static Token[] lexx(final String format);",
      "Class_name": "DurationFormatUtils",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/time/DurationFormatUtils###formatDurationWords",
      "Parameter_num": "3",
      "all_Import_statements": "import java.util.ArrayList;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n\nimport java.util.GregorianCalendar;\n\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport org.apache.commons.lang3.Validate;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>Formats an elapsed time into a pluralization correct string.</p>\n     *\n     * <p>This method formats durations using the days and lower fields of the\n     * format pattern. Months and larger are not used.</p>\n     *\n     * @param durationMillis  the elapsed time to report in milliseconds\n     * @param suppressLeadingZeroElements  suppresses leading 0 elements\n     * @param suppressTrailingZeroElements  suppresses trailing 0 elements\n     * @return the formatted text in days/hours/minutes/seconds, not null\n     * @throws java.lang.IllegalArgumentException if durationMillis is negative\n     ",
      "packageName": "org.apache.commons.lang3.time",
      "method_signature": "public static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements);",
      "Junit_version": "4",
      "returnType": "String"
    },
    "Test_method": {
      "Method_body": "String text = null;\n\rtext = DurationFormatUtils.formatDurationWords(50 * 1000, true, false);\n\rassertEquals(\"50 seconds\", text);\n\rtext = DurationFormatUtils.formatDurationWords(65 * 1000, true, false);\n\rassertEquals(\"1 minute 5 seconds\", text);\n\rtext = DurationFormatUtils.formatDurationWords(120 * 1000, true, false);\n\rassertEquals(\"2 minutes 0 seconds\", text);\n\rtext = DurationFormatUtils.formatDurationWords(121 * 1000, true, false);\n\rassertEquals(\"2 minutes 1 second\", text);\n\rtext = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false);\n\rassertEquals(\"1 hour 12 minutes 0 seconds\", text);\n\rtext = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false);\n\rassertEquals(\"1 day 0 hours 0 minutes 0 seconds\", text);\n\rtext = DurationFormatUtils.formatDurationWords(50 * 1000, true, true);\n\rassertEquals(\"50 seconds\", text);\n\rtext = DurationFormatUtils.formatDurationWords(65 * 1000, true, true);\n\rassertEquals(\"1 minute 5 seconds\", text);\n\rtext = DurationFormatUtils.formatDurationWords(120 * 1000, true, true);\n\rassertEquals(\"2 minutes\", text);\n\rtext = DurationFormatUtils.formatDurationWords(121 * 1000, true, true);\n\rassertEquals(\"2 minutes 1 second\", text);\n\rtext = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true);\n\rassertEquals(\"1 hour 12 minutes\", text);\n\rtext = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true);\n\rassertEquals(\"1 day\", text);\n\rtext = DurationFormatUtils.formatDurationWords(50 * 1000, false, true);\n\rassertEquals(\"0 days 0 hours 0 minutes 50 seconds\", text);\n\rtext = DurationFormatUtils.formatDurationWords(65 * 1000, false, true);\n\rassertEquals(\"0 days 0 hours 1 minute 5 seconds\", text);\n\rtext = DurationFormatUtils.formatDurationWords(120 * 1000, false, true);\n\rassertEquals(\"0 days 0 hours 2 minutes\", text);\n\rtext = DurationFormatUtils.formatDurationWords(121 * 1000, false, true);\n\rassertEquals(\"0 days 0 hours 2 minutes 1 second\", text);\n\rtext = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true);\n\rassertEquals(\"0 days 1 hour 12 minutes\", text);\n\rtext = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true);\n\rassertEquals(\"1 day\", text);\n\rtext = DurationFormatUtils.formatDurationWords(50 * 1000, false, false);\n\rassertEquals(\"0 days 0 hours 0 minutes 50 seconds\", text);\n\rtext = DurationFormatUtils.formatDurationWords(65 * 1000, false, false);\n\rassertEquals(\"0 days 0 hours 1 minute 5 seconds\", text);\n\rtext = DurationFormatUtils.formatDurationWords(120 * 1000, false, false);\n\rassertEquals(\"0 days 0 hours 2 minutes 0 seconds\", text);\n\rtext = DurationFormatUtils.formatDurationWords(121 * 1000, false, false);\n\rassertEquals(\"0 days 0 hours 2 minutes 1 second\", text);\n\rtext = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false);\n\rassertEquals(\"0 days 1 hour 12 minutes 0 seconds\", text);\n\rtext = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false);\n\rassertEquals(\"1 day 1 hour 12 minutes 0 seconds\", text);\n\rtext = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false);\n\rassertEquals(\"2 days 1 hour 12 minutes 0 seconds\", text);\n\rfor (int i = 2; i < 31; i++) {\n    text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false);\n    assertEquals(i + \" days 0 hours 0 minutes 0 seconds\", text);\n}",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "52",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "// -----------------------------------------------------------------------\n@Test\npublic void testFormatDurationWords() {\n    String text = null;\n    text = DurationFormatUtils.formatDurationWords(50 * 1000, true, false);\n    assertEquals(\"50 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(65 * 1000, true, false);\n    assertEquals(\"1 minute 5 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(120 * 1000, true, false);\n    assertEquals(\"2 minutes 0 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(121 * 1000, true, false);\n    assertEquals(\"2 minutes 1 second\", text);\n    text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, false);\n    assertEquals(\"1 hour 12 minutes 0 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, false);\n    assertEquals(\"1 day 0 hours 0 minutes 0 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(50 * 1000, true, true);\n    assertEquals(\"50 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(65 * 1000, true, true);\n    assertEquals(\"1 minute 5 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(120 * 1000, true, true);\n    assertEquals(\"2 minutes\", text);\n    text = DurationFormatUtils.formatDurationWords(121 * 1000, true, true);\n    assertEquals(\"2 minutes 1 second\", text);\n    text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, true, true);\n    assertEquals(\"1 hour 12 minutes\", text);\n    text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, true, true);\n    assertEquals(\"1 day\", text);\n    text = DurationFormatUtils.formatDurationWords(50 * 1000, false, true);\n    assertEquals(\"0 days 0 hours 0 minutes 50 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(65 * 1000, false, true);\n    assertEquals(\"0 days 0 hours 1 minute 5 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(120 * 1000, false, true);\n    assertEquals(\"0 days 0 hours 2 minutes\", text);\n    text = DurationFormatUtils.formatDurationWords(121 * 1000, false, true);\n    assertEquals(\"0 days 0 hours 2 minutes 1 second\", text);\n    text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, true);\n    assertEquals(\"0 days 1 hour 12 minutes\", text);\n    text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000, false, true);\n    assertEquals(\"1 day\", text);\n    text = DurationFormatUtils.formatDurationWords(50 * 1000, false, false);\n    assertEquals(\"0 days 0 hours 0 minutes 50 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(65 * 1000, false, false);\n    assertEquals(\"0 days 0 hours 1 minute 5 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(120 * 1000, false, false);\n    assertEquals(\"0 days 0 hours 2 minutes 0 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(121 * 1000, false, false);\n    assertEquals(\"0 days 0 hours 2 minutes 1 second\", text);\n    text = DurationFormatUtils.formatDurationWords(72 * 60 * 1000, false, false);\n    assertEquals(\"0 days 1 hour 12 minutes 0 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false);\n    assertEquals(\"1 day 1 hour 12 minutes 0 seconds\", text);\n    text = DurationFormatUtils.formatDurationWords(2 * 24 * 60 * 60 * 1000 + 72 * 60 * 1000, false, false);\n    assertEquals(\"2 days 1 hour 12 minutes 0 seconds\", text);\n    for (int i = 2; i < 31; i++) {\n        text = DurationFormatUtils.formatDurationWords(i * 24 * 60 * 60 * 1000L, false, false);\n        assertEquals(i + \" days 0 hours 0 minutes 0 seconds\", text);\n    }\n}",
      "Method_name": "testFormatDurationWords",
      "Class_declaration": "public class DurationFormatUtilsTest {\n",
      "constructors": "",
      "Class_name": "DurationFormatUtilsTest",
      "methodName_paraNum": "[formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3), formatDurationWords(3)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/time/DurationFormatUtilsTest###testFormatDurationWords",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/time/DurationFormatUtilsTest.java",
      "Signature": "public void testFormatDurationWords() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Modifier;\n\nimport java.util.Calendar;\n\nimport java.util.TimeZone;\n\nimport org.junit.Test;\n",
      "comment": " -----------------------------------------------------------------------",
      "packageName": "org.apache.commons.lang3.time",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@GwtIncompatible(\"incompatible method\")\npublic EqualsBuilder reflectionAppend(final Object lhs, final Object rhs) {\n    if (!isEquals) {\n        return this;\n    }\n    if (lhs == rhs) {\n        return this;\n    }\n    if (lhs == null || rhs == null) {\n        isEquals = false;\n        return this;\n    }\n    final Class<?> lhsClass = lhs.getClass();\n    final Class<?> rhsClass = rhs.getClass();\n    Class<?> testClass;\n    if (lhsClass.isInstance(rhs)) {\n        testClass = lhsClass;\n        if (!rhsClass.isInstance(lhs)) {\n            testClass = rhsClass;\n        }\n    } else if (rhsClass.isInstance(lhs)) {\n        testClass = rhsClass;\n        if (!lhsClass.isInstance(rhs)) {\n            testClass = lhsClass;\n        }\n    } else {\n        isEquals = false;\n        return this;\n    }\n    try {\n        if (testClass.isArray()) {\n            append(lhs, rhs);\n        } else {\n            reflectionAppend(lhs, rhs, testClass);\n            while (testClass.getSuperclass() != null && testClass != reflectUpToClass) {\n                testClass = testClass.getSuperclass();\n                reflectionAppend(lhs, rhs, testClass);\n            }\n        }\n    } catch (final IllegalArgumentException e) {\n        isEquals = false;\n        return this;\n    }\n    return this;\n}",
      "all_field_declaration": "/**\n * <p>\n * A registry of objects used by reflection methods to detect cyclical object references and avoid infinite loops.\n * </p>\n *\n * @since 3.0\n */\n@GwtIncompatible(\"incompatible method\")\nprivate static final ThreadLocal<Set<Pair<IDKey, IDKey>>> REGISTRY = new ThreadLocal<>();\nprivate boolean isEquals = true;\nprivate boolean testTransients = false;\nprivate boolean testRecursive = false;\nprivate Class<?> reflectUpToClass = null;\nprivate String[] excludeFields = null;",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "9",
      "Filed": "private boolean isEquals = true;private Class<?> reflectUpToClass = null;",
      "Parameter_type": "Object,Object",
      "Import_statements": "import com.google.gwt.core.shared.GwtIncompatible;\n",
      "public_method_signature": "public EqualsBuilder();\npublic EqualsBuilder setTestTransients(final boolean testTransients);\npublic EqualsBuilder setTestRecursive(final boolean testRecursive);\npublic EqualsBuilder setReflectUpToClass(final Class<?> reflectUpToClass);\npublic EqualsBuilder setExcludeFields(final String... excludeFields);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final Collection<String> excludeFields);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final String... excludeFields);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final boolean testRecursive, final String... excludeFields);\npublic EqualsBuilder reflectionAppend(final Object lhs, final Object rhs);\npublic EqualsBuilder appendSuper(final boolean superEquals);\npublic EqualsBuilder append(final Object lhs, final Object rhs);\npublic EqualsBuilder append(final long lhs, final long rhs);\npublic EqualsBuilder append(final int lhs, final int rhs);\npublic EqualsBuilder append(final short lhs, final short rhs);\npublic EqualsBuilder append(final char lhs, final char rhs);\npublic EqualsBuilder append(final byte lhs, final byte rhs);\npublic EqualsBuilder append(final double lhs, final double rhs);\npublic EqualsBuilder append(final float lhs, final float rhs);\npublic EqualsBuilder append(final boolean lhs, final boolean rhs);\npublic EqualsBuilder append(final Object[] lhs, final Object[] rhs);\npublic EqualsBuilder append(final long[] lhs, final long[] rhs);\npublic EqualsBuilder append(final int[] lhs, final int[] rhs);\npublic EqualsBuilder append(final short[] lhs, final short[] rhs);\npublic EqualsBuilder append(final char[] lhs, final char[] rhs);\npublic EqualsBuilder append(final byte[] lhs, final byte[] rhs);\npublic EqualsBuilder append(final double[] lhs, final double[] rhs);\npublic EqualsBuilder append(final float[] lhs, final float[] rhs);\npublic EqualsBuilder append(final boolean[] lhs, final boolean[] rhs);\npublic boolean isEquals();\npublic Boolean build();\npublic void reset();",
      "public_field": "",
      "Method_statement": "reflectionAppend(final Object lhs, final Object rhs)",
      "Method_name": "reflectionAppend",
      "Class_declaration": "public class EqualsBuilder {\n",
      "constructors": "public EqualsBuilder() {\n}",
      "all_method_signature": " static Set<Pair<IDKey, IDKey>> getRegistry();\n static Pair<IDKey, IDKey> getRegisterPair(final Object lhs, final Object rhs);\n static boolean isRegistered(final Object lhs, final Object rhs);\nprivate static void register(final Object lhs, final Object rhs);\nprivate static void unregister(final Object lhs, final Object rhs);\npublic EqualsBuilder();\npublic EqualsBuilder setTestTransients(final boolean testTransients);\npublic EqualsBuilder setTestRecursive(final boolean testRecursive);\npublic EqualsBuilder setReflectUpToClass(final Class<?> reflectUpToClass);\npublic EqualsBuilder setExcludeFields(final String... excludeFields);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final Collection<String> excludeFields);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final String... excludeFields);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final String... excludeFields);\npublic static boolean reflectionEquals(final Object lhs, final Object rhs, final boolean testTransients, final Class<?> reflectUpToClass, final boolean testRecursive, final String... excludeFields);\npublic EqualsBuilder reflectionAppend(final Object lhs, final Object rhs);\nprivate void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz);\npublic EqualsBuilder appendSuper(final boolean superEquals);\npublic EqualsBuilder append(final Object lhs, final Object rhs);\nprivate void appendArray(final Object lhs, final Object rhs);\npublic EqualsBuilder append(final long lhs, final long rhs);\npublic EqualsBuilder append(final int lhs, final int rhs);\npublic EqualsBuilder append(final short lhs, final short rhs);\npublic EqualsBuilder append(final char lhs, final char rhs);\npublic EqualsBuilder append(final byte lhs, final byte rhs);\npublic EqualsBuilder append(final double lhs, final double rhs);\npublic EqualsBuilder append(final float lhs, final float rhs);\npublic EqualsBuilder append(final boolean lhs, final boolean rhs);\npublic EqualsBuilder append(final Object[] lhs, final Object[] rhs);\npublic EqualsBuilder append(final long[] lhs, final long[] rhs);\npublic EqualsBuilder append(final int[] lhs, final int[] rhs);\npublic EqualsBuilder append(final short[] lhs, final short[] rhs);\npublic EqualsBuilder append(final char[] lhs, final char[] rhs);\npublic EqualsBuilder append(final byte[] lhs, final byte[] rhs);\npublic EqualsBuilder append(final double[] lhs, final double[] rhs);\npublic EqualsBuilder append(final float[] lhs, final float[] rhs);\npublic EqualsBuilder append(final boolean[] lhs, final boolean[] rhs);\npublic boolean isEquals();\npublic Boolean build();\nprotected void setEquals(final boolean isEquals);\npublic void reset();",
      "Class_name": "EqualsBuilder",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/builder/EqualsBuilder###reflectionAppend",
      "Parameter_num": "2",
      "all_Import_statements": "import java.lang.reflect.AccessibleObject;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.Modifier;\n\nimport java.util.Collection;\n\nimport java.util.HashSet;\n\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\nimport org.apache.commons.lang3.ClassUtils;\n\nimport org.apache.commons.lang3.tuple.Pair;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>Tests if two <code>objects</code> by using reflection.</p>\n     *\n     * <p>It uses <code>AccessibleObject.setAccessible</code> to gain access to private\n     * fields. This means that it will throw a security exception if run under\n     * a security manager, if the permissions are not set up correctly. It is also\n     * not as efficient as testing explicitly. Non-primitive fields are compared using\n     * <code>equals()</code>.</p>\n     *\n     * <p>If the testTransients field is set to <code>true</code>, transient\n     * members will be tested, otherwise they are ignored, as they are likely\n     * derived fields, and not part of the value of the <code>Object</code>.</p>\n     *\n     * <p>Static fields will not be included. Superclass fields will be appended\n     * up to and including the specified superclass in field <code>reflectUpToClass</code>.\n     * A null superclass is treated as java.lang.Object.</p>\n     *\n     * <p>Field names listed in field <code>excludeFields</code> will be ignored.</p>\n     *\n     * @param lhs  the left hand object\n     * @param rhs  the left hand object\n     * @return EqualsBuilder - used to chain calls.\n     ",
      "packageName": "org.apache.commons.lang3.builder",
      "method_signature": "public EqualsBuilder reflectionAppend(final Object lhs, final Object rhs);",
      "Junit_version": "4",
      "returnType": "EqualsBuilder"
    },
    "Test_method": {
      "Method_body": "assertTrue(EqualsBuilder.reflectionEquals(null, null));\n\rfinal TestObject o1 = new TestObject(4);\n\rfinal TestObject o2 = new TestObject(5);\n\rassertTrue(new EqualsBuilder().reflectionAppend(o1, o1).build());\n\rassertFalse(new EqualsBuilder().reflectionAppend(o1, o2).build());\n\ro2.setA(4);\n\rassertTrue(new EqualsBuilder().reflectionAppend(o1, o2).build());\n\rassertFalse(new EqualsBuilder().reflectionAppend(o1, this).build());\n\rassertFalse(new EqualsBuilder().reflectionAppend(o1, null).build());\n\rassertFalse(new EqualsBuilder().reflectionAppend(null, o2).build());",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "10",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport org.junit.Test;\n",
      "allMethod_info": "@Test\npublic void testReflectionAppend() {\n    assertTrue(EqualsBuilder.reflectionEquals(null, null));\n    final TestObject o1 = new TestObject(4);\n    final TestObject o2 = new TestObject(5);\n    assertTrue(new EqualsBuilder().reflectionAppend(o1, o1).build());\n    assertFalse(new EqualsBuilder().reflectionAppend(o1, o2).build());\n    o2.setA(4);\n    assertTrue(new EqualsBuilder().reflectionAppend(o1, o2).build());\n    assertFalse(new EqualsBuilder().reflectionAppend(o1, this).build());\n    assertFalse(new EqualsBuilder().reflectionAppend(o1, null).build());\n    assertFalse(new EqualsBuilder().reflectionAppend(null, o2).build());\n}",
      "Method_name": "testReflectionAppend",
      "Class_declaration": "public class EqualsBuilderTest {\n",
      "constructors": "",
      "Class_name": "EqualsBuilderTest",
      "methodName_paraNum": "[reflectionEquals(2), build(0), reflectionAppend(2), build(0), reflectionAppend(2), setA(1), build(0), reflectionAppend(2), build(0), reflectionAppend(2), build(0), reflectionAppend(2), build(0), reflectionAppend(2)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/builder/EqualsBuilderTest###testReflectionAppend",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/builder/EqualsBuilderTest.java",
      "Signature": "public void testReflectionAppend() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNull;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.lang.reflect.Method;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.lang3.reflect.MethodUtils;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3.builder",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic boolean equals(final Object obj) {\n    if (!(obj instanceof FastDateParser)) {\n        return false;\n    }\n    final FastDateParser other = (FastDateParser) obj;\n    return pattern.equals(other.pattern) && timeZone.equals(other.timeZone) && locale.equals(other.locale);\n}",
      "all_field_declaration": "/**\n * Required for serialization support.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 3L;\nstatic final Locale JAPANESE_IMPERIAL = new Locale(\"ja\", \"JP\", \"JP\");\n// defining fields\nprivate final String pattern;\nprivate final TimeZone timeZone;\nprivate final Locale locale;\nprivate final int century;\nprivate final int startYear;\n// derived fields\nprivate transient List<StrategyAndWidth> patterns;\n// comparator used to sort regex alternatives\n// alternatives should be ordered longer first, and shorter last. ('february' before 'feb')\n// all entries must be lowercase by locale.\nprivate static final Comparator<String> LONGER_FIRST_LOWERCASE = new Comparator<String>() {\n\n    @Override\n    public int compare(final String left, final String right) {\n        return right.compareTo(left);\n    }\n};\n@SuppressWarnings(\"unchecked\")\nprivate static final ConcurrentMap<Locale, Strategy>[] caches = new ConcurrentMap[Calendar.FIELD_COUNT];\nprivate static final Strategy ABBREVIATED_YEAR_STRATEGY = new NumberStrategy(Calendar.YEAR) {\n\n    @Override\n    int modify(final FastDateParser parser, final int iValue) {\n        return iValue < 100 ? parser.adjustYear(iValue) : iValue;\n    }\n};\nprivate static final Strategy NUMBER_MONTH_STRATEGY = new NumberStrategy(Calendar.MONTH) {\n\n    @Override\n    int modify(final FastDateParser parser, final int iValue) {\n        return iValue - 1;\n    }\n};\nprivate static final Strategy LITERAL_YEAR_STRATEGY = new NumberStrategy(Calendar.YEAR);\nprivate static final Strategy WEEK_OF_YEAR_STRATEGY = new NumberStrategy(Calendar.WEEK_OF_YEAR);\nprivate static final Strategy WEEK_OF_MONTH_STRATEGY = new NumberStrategy(Calendar.WEEK_OF_MONTH);\nprivate static final Strategy DAY_OF_YEAR_STRATEGY = new NumberStrategy(Calendar.DAY_OF_YEAR);\nprivate static final Strategy DAY_OF_MONTH_STRATEGY = new NumberStrategy(Calendar.DAY_OF_MONTH);\nprivate static final Strategy DAY_OF_WEEK_STRATEGY = new NumberStrategy(Calendar.DAY_OF_WEEK) {\n\n    @Override\n    int modify(final FastDateParser parser, final int iValue) {\n        return iValue != 7 ? iValue + 1 : Calendar.SUNDAY;\n    }\n};\nprivate static final Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY = new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH);\nprivate static final Strategy HOUR_OF_DAY_STRATEGY = new NumberStrategy(Calendar.HOUR_OF_DAY);\nprivate static final Strategy HOUR24_OF_DAY_STRATEGY = new NumberStrategy(Calendar.HOUR_OF_DAY) {\n\n    @Override\n    int modify(final FastDateParser parser, final int iValue) {\n        return iValue == 24 ? 0 : iValue;\n    }\n};\nprivate static final Strategy HOUR12_STRATEGY = new NumberStrategy(Calendar.HOUR) {\n\n    @Override\n    int modify(final FastDateParser parser, final int iValue) {\n        return iValue == 12 ? 0 : iValue;\n    }\n};\nprivate static final Strategy HOUR_STRATEGY = new NumberStrategy(Calendar.HOUR);\nprivate static final Strategy MINUTE_STRATEGY = new NumberStrategy(Calendar.MINUTE);\nprivate static final Strategy SECOND_STRATEGY = new NumberStrategy(Calendar.SECOND);\nprivate static final Strategy MILLISECOND_STRATEGY = new NumberStrategy(Calendar.MILLISECOND);",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "3",
      "Filed": "private final String pattern;private final TimeZone timeZone;private final Locale locale;",
      "Parameter_type": "Object",
      "Import_statements": "import java.util.Date;\n",
      "public_method_signature": "public String getPattern();\npublic TimeZone getTimeZone();\npublic Locale getLocale();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();\npublic Object parseObject(final String source) throws ParseException;\npublic Date parse(final String source) throws ParseException;\npublic Object parseObject(final String source, final ParsePosition pos);\npublic Date parse(final String source, final ParsePosition pos);\npublic boolean parse(final String source, final ParsePosition pos, final Calendar calendar);",
      "public_field": "",
      "Method_statement": "equals(final Object obj)",
      "Method_name": "equals",
      "Class_declaration": "public class FastDateParser {\n",
      "constructors": "protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale) {\n    this(pattern, timeZone, locale, null);\n}protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale, final Date centuryStart) {\n    this.pattern = pattern;\n    this.timeZone = timeZone;\n    this.locale = locale;\n    final Calendar definingCalendar = Calendar.getInstance(timeZone, locale);\n    int centuryStartYear;\n    if (centuryStart != null) {\n        definingCalendar.setTime(centuryStart);\n        centuryStartYear = definingCalendar.get(Calendar.YEAR);\n    } else if (locale.equals(JAPANESE_IMPERIAL)) {\n        centuryStartYear = 0;\n    } else {\n        definingCalendar.setTime(new Date());\n        centuryStartYear = definingCalendar.get(Calendar.YEAR) - 80;\n    }\n    century = centuryStartYear / 100 * 100;\n    startYear = centuryStartYear - century;\n    init(definingCalendar);\n}",
      "all_method_signature": "protected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale);\nprotected FastDateParser(final String pattern, final TimeZone timeZone, final Locale locale, final Date centuryStart);\nprivate void init(final Calendar definingCalendar);\nprivate static boolean isFormatLetter(final char c);\npublic String getPattern();\npublic TimeZone getTimeZone();\npublic Locale getLocale();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();\nprivate void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException;\npublic Object parseObject(final String source) throws ParseException;\npublic Date parse(final String source) throws ParseException;\npublic Object parseObject(final String source, final ParsePosition pos);\npublic Date parse(final String source, final ParsePosition pos);\npublic boolean parse(final String source, final ParsePosition pos, final Calendar calendar);\nprivate static StringBuilder simpleQuote(final StringBuilder sb, final String value);\nprivate static Map<String, Integer> appendDisplayNames(final Calendar cal, final Locale locale, final int field, final StringBuilder regex);\nprivate int adjustYear(final int twoDigitYear);\nprivate Strategy getStrategy(final char f, final int width, final Calendar definingCalendar);\nprivate static ConcurrentMap<Locale, Strategy> getCache(final int field);\nprivate Strategy getLocaleSpecificStrategy(final int field, final Calendar definingCalendar);",
      "Class_name": "FastDateParser",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/time/FastDateParser###equals",
      "Parameter_num": "1",
      "all_Import_statements": "import java.io.IOException;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.Serializable;\n\nimport java.text.DateFormatSymbols;\n\nimport java.text.ParseException;\n\nimport java.text.ParsePosition;\n\nimport java.util.ArrayList;\n\nimport java.util.Calendar;\n\nimport java.util.Comparator;\n\nimport java.util.Date;\n\nimport java.util.HashMap;\n\nimport java.util.List;\n\nimport java.util.ListIterator;\n\nimport java.util.Locale;\n\nimport java.util.Map;\n\nimport java.util.Set;\n\nimport java.util.TimeZone;\n\nimport java.util.TreeSet;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport java.util.concurrent.ConcurrentMap;\n\nimport java.util.regex.Matcher;\n\nimport java.util.regex.Pattern;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>Compare another object for equality with this object.</p>\n     *\n     * @param obj  the object to compare to\n     * @return <code>true</code>if equal to this instance\n     ",
      "packageName": "org.apache.commons.lang3.time",
      "method_signature": "public boolean equals(final Object obj);",
      "Junit_version": "4",
      "returnType": "boolean"
    },
    "Test_method": {
      "Method_body": "final DateParser parser1 = getInstance(YMD_SLASH);\n\rfinal DateParser parser2 = getInstance(YMD_SLASH);\n\rassertEquals(parser1, parser2);\n\rassertEquals(parser1.hashCode(), parser2.hashCode());\n\rassertFalse(parser1.equals(new Object()));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "private static final String YMD_SLASH = \"yyyy/MM/dd\";",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport java.util.Date;\n",
      "allMethod_info": "@Test\npublic void testEquals() {\n    final DateParser parser1 = getInstance(YMD_SLASH);\n    final DateParser parser2 = getInstance(YMD_SLASH);\n    assertEquals(parser1, parser2);\n    assertEquals(parser1.hashCode(), parser2.hashCode());\n    assertFalse(parser1.equals(new Object()));\n}",
      "Method_name": "testEquals",
      "Class_declaration": "public class FastDateParserTest {\n",
      "constructors": "",
      "Class_name": "FastDateParserTest",
      "methodName_paraNum": "[getInstance(1), getInstance(1), hashCode(0), hashCode(0), equals(1)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/time/FastDateParserTest###testEquals",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/time/FastDateParserTest.java",
      "Signature": "public void testEquals() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.junit.Assert.fail;\n\nimport java.io.Serializable;\n\nimport java.text.ParseException;\n\nimport java.text.ParsePosition;\n\nimport java.text.SimpleDateFormat;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n\nimport java.util.GregorianCalendar;\n\nimport java.util.HashMap;\n\nimport java.util.Locale;\n\nimport java.util.Map;\n\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang3.LocaleUtils;\n\nimport org.apache.commons.lang3.SerializationUtils;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3.time",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic String format(final Date date) {\n    final Calendar c = newCalendar();\n    c.setTime(date);\n    return applyRulesToString(c);\n}",
      "all_field_declaration": "// A lot of the speed in this class comes from caching, but some comes\n// from the special int to StringBuffer conversion.\n// \n// The following produces a padded 2 digit number:\n// buffer.append((char)(value / 10 + '0'));\n// buffer.append((char)(value % 10 + '0'));\n// \n// Note that the fastest append to StringBuffer is a single char (used here).\n// Note that Integer.toString() is not called, the conversion is simply\n// taking the value and adding (mathematically) the ASCII value for '0'.\n// So, don't change this code! It works and is very fast.\n/**\n * Required for serialization support.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 1L;\n/**\n * FULL locale dependent date or time style.\n */\npublic static final int FULL = DateFormat.FULL;\n/**\n * LONG locale dependent date or time style.\n */\npublic static final int LONG = DateFormat.LONG;\n/**\n * MEDIUM locale dependent date or time style.\n */\npublic static final int MEDIUM = DateFormat.MEDIUM;\n/**\n * SHORT locale dependent date or time style.\n */\npublic static final int SHORT = DateFormat.SHORT;\n/**\n * The pattern.\n */\nprivate final String mPattern;\n/**\n * The time zone.\n */\nprivate final TimeZone mTimeZone;\n/**\n * The locale.\n */\nprivate final Locale mLocale;\n/**\n * The parsed rules.\n */\nprivate transient Rule[] mRules;\n/**\n * The estimated maximum length.\n */\nprivate transient int mMaxLengthEstimate;\nprivate static final int MAX_DIGITS = 10;\nprivate static final ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache = new ConcurrentHashMap<>(7);",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "3",
      "Filed": "",
      "Parameter_type": "Date",
      "Import_statements": "import java.util.Calendar;\nimport java.util.Date;\n",
      "public_method_signature": "public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos);\npublic String format(final long millis);\npublic String format(final Date date);\npublic String format(final Calendar calendar);\npublic StringBuffer format(final long millis, final StringBuffer buf);\npublic StringBuffer format(final Date date, final StringBuffer buf);\npublic StringBuffer format(final Calendar calendar, final StringBuffer buf);\npublic B format(final long millis, final B buf);\npublic B format(final Date date, final B buf);\npublic B format(Calendar calendar, final B buf);\npublic String getPattern();\npublic TimeZone getTimeZone();\npublic Locale getLocale();\npublic int getMaxLengthEstimate();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();",
      "public_field": "/**\n * FULL locale dependent date or time style.\n */\npublic static final int FULL = DateFormat.FULL;\n/**\n * LONG locale dependent date or time style.\n */\npublic static final int LONG = DateFormat.LONG;\n/**\n * MEDIUM locale dependent date or time style.\n */\npublic static final int MEDIUM = DateFormat.MEDIUM;\n/**\n * SHORT locale dependent date or time style.\n */\npublic static final int SHORT = DateFormat.SHORT;",
      "Method_statement": "format(final Date date)",
      "Method_name": "format",
      "Class_declaration": "public class FastDatePrinter {\n",
      "constructors": "protected FastDatePrinter(final String pattern, final TimeZone timeZone, final Locale locale) {\n    mPattern = pattern;\n    mTimeZone = timeZone;\n    mLocale = locale;\n    init();\n}",
      "all_method_signature": "protected FastDatePrinter(final String pattern, final TimeZone timeZone, final Locale locale);\nprivate void init();\nprotected List<Rule> parsePattern();\nprotected String parseToken(final String pattern, final int[] indexRef);\nprotected NumberRule selectNumberRule(final int field, final int padding);\npublic StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos);\n String format(final Object obj);\npublic String format(final long millis);\nprivate String applyRulesToString(final Calendar c);\nprivate Calendar newCalendar();\npublic String format(final Date date);\npublic String format(final Calendar calendar);\npublic StringBuffer format(final long millis, final StringBuffer buf);\npublic StringBuffer format(final Date date, final StringBuffer buf);\npublic StringBuffer format(final Calendar calendar, final StringBuffer buf);\npublic B format(final long millis, final B buf);\npublic B format(final Date date, final B buf);\npublic B format(Calendar calendar, final B buf);\nprotected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf);\nprivate B applyRules(final Calendar calendar, final B buf);\npublic String getPattern();\npublic TimeZone getTimeZone();\npublic Locale getLocale();\npublic int getMaxLengthEstimate();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();\nprivate void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException;\nprivate static void appendDigits(final Appendable buffer, final int value) throws IOException;\nprivate static void appendFullDigits(final Appendable buffer, int value, int minFieldWidth) throws IOException;\n static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale);",
      "Class_name": "FastDatePrinter",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/time/FastDatePrinter###format",
      "Parameter_num": "1",
      "all_Import_statements": "import java.io.IOException;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.Serializable;\n\nimport java.text.DateFormat;\n\nimport java.text.DateFormatSymbols;\n\nimport java.text.FieldPosition;\n\nimport java.util.ArrayList;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n\nimport java.util.List;\n\nimport java.util.Locale;\n\nimport java.util.TimeZone;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.apache.commons.lang3.exception.ExceptionUtils;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": " (non-Javadoc)\n     * @see org.apache.commons.lang3.time.DatePrinter#format(java.util.Date)\n     ",
      "packageName": "org.apache.commons.lang3.time",
      "method_signature": "public String format(final Date date);",
      "Junit_version": "4",
      "returnType": "String"
    },
    "Test_method": {
      "Method_body": "final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20);\n\rfinal GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 0, 0);\n\rfinal Date date1 = cal1.getTime();\n\rfinal Date date2 = cal2.getTime();\n\rfinal long millis1 = date1.getTime();\n\rfinal long millis2 = date2.getTime();\n\rDatePrinter fdf = getInstance(\"yyyy-MM-dd'T'HH:mm:ss\");\n\rSimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n\rassertEquals(sdf.format(date1), fdf.format(date1));\n\rassertEquals(\"2003-01-10T15:33:20\", fdf.format(date1));\n\rassertEquals(\"2003-01-10T15:33:20\", fdf.format(cal1));\n\rassertEquals(\"2003-01-10T15:33:20\", fdf.format(millis1));\n\rassertEquals(\"2003-07-10T09:00:00\", fdf.format(date2));\n\rassertEquals(\"2003-07-10T09:00:00\", fdf.format(cal2));\n\rassertEquals(\"2003-07-10T09:00:00\", fdf.format(millis2));\n\rfdf = getInstance(\"Z\");\n\rassertEquals(\"-0500\", fdf.format(date1));\n\rassertEquals(\"-0500\", fdf.format(cal1));\n\rassertEquals(\"-0500\", fdf.format(millis1));\n\rassertEquals(\"-0400\", fdf.format(date2));\n\rassertEquals(\"-0400\", fdf.format(cal2));\n\rassertEquals(\"-0400\", fdf.format(millis2));\n\rfdf = getInstance(\"ZZ\");\n\rassertEquals(\"-05:00\", fdf.format(date1));\n\rassertEquals(\"-05:00\", fdf.format(cal1));\n\rassertEquals(\"-05:00\", fdf.format(millis1));\n\rassertEquals(\"-04:00\", fdf.format(date2));\n\rassertEquals(\"-04:00\", fdf.format(cal2));\n\rassertEquals(\"-04:00\", fdf.format(millis2));\n\rfinal String pattern = \"GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M\" + \" dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z\";\n\rfdf = getInstance(pattern);\n\rsdf = new SimpleDateFormat(pattern);\n\r// SDF bug fix starting with Java 7\nassertEquals(sdf.format(date1).replaceAll(\"2003 03 03 03\", \"2003 2003 03 2003\"), fdf.format(date1));\n\rassertEquals(sdf.format(date2).replaceAll(\"2003 03 03 03\", \"2003 2003 03 2003\"), fdf.format(date2));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "34",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport java.text.SimpleDateFormat;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\n",
      "allMethod_info": "@SystemDefaults(timezone = \"America/New_York\", locale = \"en_US\")\n@Test\npublic void testFormat() {\n    final GregorianCalendar cal1 = new GregorianCalendar(2003, 0, 10, 15, 33, 20);\n    final GregorianCalendar cal2 = new GregorianCalendar(2003, 6, 10, 9, 0, 0);\n    final Date date1 = cal1.getTime();\n    final Date date2 = cal2.getTime();\n    final long millis1 = date1.getTime();\n    final long millis2 = date2.getTime();\n    DatePrinter fdf = getInstance(\"yyyy-MM-dd'T'HH:mm:ss\");\n    SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n    assertEquals(sdf.format(date1), fdf.format(date1));\n    assertEquals(\"2003-01-10T15:33:20\", fdf.format(date1));\n    assertEquals(\"2003-01-10T15:33:20\", fdf.format(cal1));\n    assertEquals(\"2003-01-10T15:33:20\", fdf.format(millis1));\n    assertEquals(\"2003-07-10T09:00:00\", fdf.format(date2));\n    assertEquals(\"2003-07-10T09:00:00\", fdf.format(cal2));\n    assertEquals(\"2003-07-10T09:00:00\", fdf.format(millis2));\n    fdf = getInstance(\"Z\");\n    assertEquals(\"-0500\", fdf.format(date1));\n    assertEquals(\"-0500\", fdf.format(cal1));\n    assertEquals(\"-0500\", fdf.format(millis1));\n    assertEquals(\"-0400\", fdf.format(date2));\n    assertEquals(\"-0400\", fdf.format(cal2));\n    assertEquals(\"-0400\", fdf.format(millis2));\n    fdf = getInstance(\"ZZ\");\n    assertEquals(\"-05:00\", fdf.format(date1));\n    assertEquals(\"-05:00\", fdf.format(cal1));\n    assertEquals(\"-05:00\", fdf.format(millis1));\n    assertEquals(\"-04:00\", fdf.format(date2));\n    assertEquals(\"-04:00\", fdf.format(cal2));\n    assertEquals(\"-04:00\", fdf.format(millis2));\n    final String pattern = \"GGGG GGG GG G yyyy yyy yy y MMMM MMM MM M\" + \" dddd ddd dd d DDDD DDD DD D EEEE EEE EE E aaaa aaa aa a zzzz zzz zz z\";\n    fdf = getInstance(pattern);\n    sdf = new SimpleDateFormat(pattern);\n    // SDF bug fix starting with Java 7\n    assertEquals(sdf.format(date1).replaceAll(\"2003 03 03 03\", \"2003 2003 03 2003\"), fdf.format(date1));\n    assertEquals(sdf.format(date2).replaceAll(\"2003 03 03 03\", \"2003 2003 03 2003\"), fdf.format(date2));\n}",
      "Method_name": "testFormat",
      "Class_declaration": "public class FastDatePrinterTest {\n",
      "constructors": "",
      "Class_name": "FastDatePrinterTest",
      "methodName_paraNum": "[getTime(0), getTime(0), getTime(0), getTime(0), getInstance(1), format(1), format(1), format(1), format(1), format(1), format(1), format(1), format(1), getInstance(1), format(1), format(1), format(1), format(1), format(1), format(1), getInstance(1), format(1), format(1), format(1), format(1), format(1), format(1), getInstance(1), replaceAll(2), format(1), format(1), replaceAll(2), format(1), format(1)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest###testFormat",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java",
      "Signature": "public void testFormat() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.Serializable;\n\nimport java.text.FieldPosition;\n\nimport java.text.ParseException;\n\nimport java.text.SimpleDateFormat;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n\nimport java.util.GregorianCalendar;\n\nimport java.util.Locale;\n\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang3.SerializationUtils;\n\nimport org.apache.commons.lang3.test.SystemDefaults;\n\nimport org.apache.commons.lang3.test.SystemDefaultsSwitch;\n\nimport org.junit.Rule;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3.time",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static List<Field> getFieldsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls) {\n    Validate.isTrue(annotationCls != null, \"The annotation class must not be null\");\n    final List<Field> allFields = getAllFieldsList(cls);\n    final List<Field> annotatedFields = new ArrayList<>();\n    for (final Field field : allFields) {\n        if (field.getAnnotation(annotationCls) != null) {\n            annotatedFields.add(field);\n        }\n    }\n    return annotatedFields;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "Class<?>,Class<? extends Annotation>",
      "Import_statements": "import org.apache.commons.lang3.Validate;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.util.ArrayList;\nimport java.util.List;\n",
      "public_method_signature": "public FieldUtils();\npublic static Field getField(final Class<?> cls, final String fieldName);\npublic static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess);\npublic static Field getDeclaredField(final Class<?> cls, final String fieldName);\npublic static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess);\npublic static Field[] getAllFields(final Class<?> cls);\npublic static List<Field> getAllFieldsList(final Class<?> cls);\npublic static Field[] getFieldsWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls);\npublic static List<Field> getFieldsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls);\npublic static Object readStaticField(final Field field) throws IllegalAccessException;\npublic static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException;\npublic static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readDeclaredStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException;\npublic static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readField(final Field field, final Object target) throws IllegalAccessException;\npublic static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readField(final Object target, final String fieldName) throws IllegalAccessException;\npublic static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readDeclaredField(final Object target, final String fieldName) throws IllegalAccessException;\npublic static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeStaticField(final Field field, final Object value) throws IllegalAccessException;\npublic static void writeStaticField(final Field field, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException;\npublic static void writeStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException;\npublic static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeField(final Field field, final Object target, final Object value) throws IllegalAccessException;\npublic static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void removeFinalModifier(final Field field);\npublic static void removeFinalModifier(final Field field, final boolean forceAccess);\npublic static void writeField(final Object target, final String fieldName, final Object value) throws IllegalAccessException;\npublic static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeDeclaredField(final Object target, final String fieldName, final Object value) throws IllegalAccessException;\npublic static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException;",
      "public_field": "",
      "Method_statement": "getFieldsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls)",
      "Method_name": "getFieldsListWithAnnotation",
      "Class_declaration": "public class FieldUtils {\n",
      "constructors": "public FieldUtils() {\n    super();\n}",
      "all_method_signature": "public FieldUtils();\npublic static Field getField(final Class<?> cls, final String fieldName);\npublic static Field getField(final Class<?> cls, final String fieldName, final boolean forceAccess);\npublic static Field getDeclaredField(final Class<?> cls, final String fieldName);\npublic static Field getDeclaredField(final Class<?> cls, final String fieldName, final boolean forceAccess);\npublic static Field[] getAllFields(final Class<?> cls);\npublic static List<Field> getAllFieldsList(final Class<?> cls);\npublic static Field[] getFieldsWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls);\npublic static List<Field> getFieldsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls);\npublic static Object readStaticField(final Field field) throws IllegalAccessException;\npublic static Object readStaticField(final Field field, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException;\npublic static Object readStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readDeclaredStaticField(final Class<?> cls, final String fieldName) throws IllegalAccessException;\npublic static Object readDeclaredStaticField(final Class<?> cls, final String fieldName, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readField(final Field field, final Object target) throws IllegalAccessException;\npublic static Object readField(final Field field, final Object target, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readField(final Object target, final String fieldName) throws IllegalAccessException;\npublic static Object readField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException;\npublic static Object readDeclaredField(final Object target, final String fieldName) throws IllegalAccessException;\npublic static Object readDeclaredField(final Object target, final String fieldName, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeStaticField(final Field field, final Object value) throws IllegalAccessException;\npublic static void writeStaticField(final Field field, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException;\npublic static void writeStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value) throws IllegalAccessException;\npublic static void writeDeclaredStaticField(final Class<?> cls, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeField(final Field field, final Object target, final Object value) throws IllegalAccessException;\npublic static void writeField(final Field field, final Object target, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void removeFinalModifier(final Field field);\npublic static void removeFinalModifier(final Field field, final boolean forceAccess);\npublic static void writeField(final Object target, final String fieldName, final Object value) throws IllegalAccessException;\npublic static void writeField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException;\npublic static void writeDeclaredField(final Object target, final String fieldName, final Object value) throws IllegalAccessException;\npublic static void writeDeclaredField(final Object target, final String fieldName, final Object value, final boolean forceAccess) throws IllegalAccessException;",
      "Class_name": "FieldUtils",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/reflect/FieldUtils###getFieldsListWithAnnotation",
      "Parameter_num": "2",
      "all_Import_statements": "import org.apache.commons.lang3.ClassUtils;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport org.apache.commons.lang3.Validate;\n\nimport java.lang.annotation.Annotation;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.Modifier;\n\nimport java.util.ArrayList;\n\nimport java.util.Collections;\n\nimport java.util.List;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * Gets all fields of the given class and its parents (if any) that are annotated with the given annotation.\n     * @param cls\n     *            the {@link Class} to query\n     * @param annotationCls\n     *            the {@link Annotation} that must be present on a field to be matched\n     * @return a list of Fields (possibly empty).\n     * @throws IllegalArgumentException\n     *            if the class or annotation are {@code null}\n     * @since 3.4\n     ",
      "packageName": "org.apache.commons.lang3.reflect",
      "method_signature": "public static List<Field> getFieldsListWithAnnotation(final Class<?> cls, final Class<? extends Annotation> annotationCls);",
      "Junit_version": "4",
      "returnType": "List<Field>"
    },
    "Test_method": {
      "Method_body": "assertEquals(0, FieldUtils.getFieldsListWithAnnotation(Object.class, Annotated.class).size());\n\rfinal List<Field> annotatedFields = Arrays.asList(FieldUtilsTest.class.getDeclaredField(\"publicChild\"), FieldUtilsTest.class.getDeclaredField(\"privatelyShadowedChild\"));\n\rfinal List<Field> fieldUtilsTestAnnotatedFields = FieldUtils.getFieldsListWithAnnotation(FieldUtilsTest.class, Annotated.class);\n\rassertEquals(annotatedFields.size(), fieldUtilsTestAnnotatedFields.size());\n\rassertTrue(fieldUtilsTestAnnotatedFields.contains(annotatedFields.get(0)));\n\rassertTrue(fieldUtilsTestAnnotatedFields.contains(annotatedFields.get(1)));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "6",
      "Filed": "@Annotated\nprivate PublicChild publicChild;@Annotated\nprivate PrivatelyShadowedChild privatelyShadowedChild;",
      "Import_statements": "import org.apache.commons.lang3.reflect.testbed.Annotated;\nimport org.junit.Test;\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\nimport java.util.List;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n",
      "allMethod_info": "@Test\npublic void testGetFieldsListWithAnnotation() throws NoSuchFieldException {\n    assertEquals(0, FieldUtils.getFieldsListWithAnnotation(Object.class, Annotated.class).size());\n    final List<Field> annotatedFields = Arrays.asList(FieldUtilsTest.class.getDeclaredField(\"publicChild\"), FieldUtilsTest.class.getDeclaredField(\"privatelyShadowedChild\"));\n    final List<Field> fieldUtilsTestAnnotatedFields = FieldUtils.getFieldsListWithAnnotation(FieldUtilsTest.class, Annotated.class);\n    assertEquals(annotatedFields.size(), fieldUtilsTestAnnotatedFields.size());\n    assertTrue(fieldUtilsTestAnnotatedFields.contains(annotatedFields.get(0)));\n    assertTrue(fieldUtilsTestAnnotatedFields.contains(annotatedFields.get(1)));\n}",
      "Method_name": "testGetFieldsListWithAnnotation",
      "Class_declaration": "public class FieldUtilsTest {\n",
      "constructors": "",
      "Class_name": "FieldUtilsTest",
      "methodName_paraNum": "[size(0), getFieldsListWithAnnotation(2), asList(2), getDeclaredField(1), getDeclaredField(1), getFieldsListWithAnnotation(2), size(0), size(0), contains(1), get(1), contains(1), get(1)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/reflect/FieldUtilsTest###testGetFieldsListWithAnnotation",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/reflect/FieldUtilsTest.java",
      "Signature": "public void testGetFieldsListWithAnnotation() {\n",
      "all_Import_statements": "import org.apache.commons.lang3.ArrayUtils;\n\nimport org.apache.commons.lang3.reflect.testbed.Ambig;\n\nimport org.apache.commons.lang3.reflect.testbed.Annotated;\n\nimport org.apache.commons.lang3.reflect.testbed.Foo;\n\nimport org.apache.commons.lang3.reflect.testbed.PrivatelyShadowedChild;\n\nimport org.apache.commons.lang3.reflect.testbed.PublicChild;\n\nimport org.apache.commons.lang3.reflect.testbed.PubliclyShadowedChild;\n\nimport org.apache.commons.lang3.reflect.testbed.StaticContainer;\n\nimport org.apache.commons.lang3.reflect.testbed.StaticContainerChild;\n\nimport org.junit.Before;\n\nimport org.junit.Test;\n\nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.Modifier;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.List;\n\nimport static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertNull;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.junit.Assert.fail;\n\nimport static org.junit.Assume.assumeNotNull;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3.reflect",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static String getNameWithoutSuffix(Path path) {\n    String name = path.getFileName().toString();\n    int index = name.lastIndexOf('.');\n    if (index == -1) {\n        return name;\n    }\n    return name.substring(0, index);\n}",
      "all_field_declaration": "private static final Log LOG = LogFactory.from(FileUtil.class);",
      "sub_project_name": "XDean_Java-EX",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "Path",
      "Import_statements": "import java.nio.file.Path;\n",
      "public_method_signature": "public static String getNameWithoutSuffix(Path path);\npublic static void createDirectory(Path path) throws IOException;\npublic static Path rename(Path path, String name) throws IOException;\npublic static Path rename(Path path, UnaryOperator<String> nameConverter) throws IOException;\npublic static boolean equals(Path p1, Path p2) throws IOException;\npublic static Flowable<Path> deepTraversal(Path path);\npublic static Flowable<Path> wideTraversal(Path path);\npublic static String md5(Path path) throws IOException;\npublic static String digest(Path path, String algorithm) throws NoSuchAlgorithmException, IOException;",
      "public_field": "",
      "Method_statement": "getNameWithoutSuffix(Path path)",
      "Method_name": "getNameWithoutSuffix",
      "Class_declaration": "public class FileUtil {\n",
      "constructors": "",
      "all_method_signature": "public static String getNameWithoutSuffix(Path path);\npublic static void createDirectory(Path path) throws IOException;\npublic static Path rename(Path path, String name) throws IOException;\npublic static Path rename(Path path, UnaryOperator<String> nameConverter) throws IOException;\npublic static boolean equals(Path p1, Path p2) throws IOException;\npublic static Flowable<Path> deepTraversal(Path path);\npublic static Flowable<Path> wideTraversal(Path path);\npublic static String md5(Path path) throws IOException;\npublic static String digest(Path path, String algorithm) throws NoSuchAlgorithmException, IOException;",
      "Class_name": "FileUtil",
      "project_path": "XDean_Java-EX###XDean_Java-EX/src/main/java/cn/xdean/jex/io/FileUtil###getNameWithoutSuffix",
      "Parameter_num": "1",
      "all_Import_statements": "import cn.xdean.jex.lang.TaskUtil;\n\nimport cn.xdean.jex.lang.collection.Traverse;\n\nimport cn.xdean.jex.security.SecurityUtil;\n\nimport com.google.common.base.Stopwatch;\n\nimport io.reactivex.Flowable;\n\nimport xdean.jex.log.Log;\n\nimport xdean.jex.log.LogFactory;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.nio.file.Files;\n\nimport java.nio.file.Path;\n\nimport java.security.NoSuchAlgorithmException;\n\nimport java.util.Collections;\n\nimport java.util.concurrent.TimeUnit;\n\nimport java.util.function.UnaryOperator;\n",
      "comment": "",
      "packageName": "cn.xdean.jex.io",
      "method_signature": "public static String getNameWithoutSuffix(Path path);",
      "Junit_version": "4",
      "returnType": "String"
    },
    "Test_method": {
      "Method_body": "assertEquals(\"file\", FileUtil.getNameWithoutSuffix(Paths.get(CP).resolve(\"file.txt\")));\n\rassertEquals(\"file1\", FileUtil.getNameWithoutSuffix(Paths.get(CP).resolve(\"file1\")));",
      "sub_project_name": "XDean_Java-EX",
      "lineNumbers": "2",
      "Filed": "private static final URI CP = ExceptionUtil.uncheck(() -> FileUtilTest.class.getResource(\".\").toURI());",
      "Import_statements": "import java.nio.file.Paths;\nimport static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "@Test\npublic void testGetNameWithoutSuffix() throws Exception {\n    assertEquals(\"file\", FileUtil.getNameWithoutSuffix(Paths.get(CP).resolve(\"file.txt\")));\n    assertEquals(\"file1\", FileUtil.getNameWithoutSuffix(Paths.get(CP).resolve(\"file1\")));\n}",
      "Method_name": "testGetNameWithoutSuffix",
      "Class_declaration": "public class FileUtilTest {\n",
      "constructors": "",
      "Class_name": "FileUtilTest",
      "methodName_paraNum": "[getNameWithoutSuffix(1), resolve(1), get(1), getNameWithoutSuffix(1), resolve(1), get(1)]",
      "project_path": "XDean_Java-EX###XDean_Java-EX/src/test/java/cn/xdean/jex/io/FileUtilTest###testGetNameWithoutSuffix",
      "relativePath": "XDean_Java-EX/src/test/java/cn/xdean/jex/io/FileUtilTest.java",
      "Signature": "public void testGetNameWithoutSuffix() {\n",
      "all_Import_statements": "import cn.xdean.jex.lang.ExceptionUtil;\n\nimport org.junit.Assert;\n\nimport org.junit.Ignore;\n\nimport org.junit.Test;\n\nimport java.io.IOException;\n\nimport java.net.URI;\n\nimport java.nio.file.Paths;\n\nimport static org.junit.Assert.assertEquals;\n",
      "comment": "",
      "packageName": "cn.xdean.jex.io",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic boolean equals(final Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof Fraction)) {\n        return false;\n    }\n    final Fraction other = (Fraction) obj;\n    return getNumerator() == other.getNumerator() && getDenominator() == other.getDenominator();\n}",
      "all_field_declaration": "/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 65382027393090L;\n/**\n * <code>Fraction</code> representation of 0.\n */\npublic static final Fraction ZERO = new Fraction(0, 1);\n/**\n * <code>Fraction</code> representation of 1.\n */\npublic static final Fraction ONE = new Fraction(1, 1);\n/**\n * <code>Fraction</code> representation of 1/2.\n */\npublic static final Fraction ONE_HALF = new Fraction(1, 2);\n/**\n * <code>Fraction</code> representation of 1/3.\n */\npublic static final Fraction ONE_THIRD = new Fraction(1, 3);\n/**\n * <code>Fraction</code> representation of 2/3.\n */\npublic static final Fraction TWO_THIRDS = new Fraction(2, 3);\n/**\n * <code>Fraction</code> representation of 1/4.\n */\npublic static final Fraction ONE_QUARTER = new Fraction(1, 4);\n/**\n * <code>Fraction</code> representation of 2/4.\n */\npublic static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n/**\n * <code>Fraction</code> representation of 3/4.\n */\npublic static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n/**\n * <code>Fraction</code> representation of 1/5.\n */\npublic static final Fraction ONE_FIFTH = new Fraction(1, 5);\n/**\n * <code>Fraction</code> representation of 2/5.\n */\npublic static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n/**\n * <code>Fraction</code> representation of 3/5.\n */\npublic static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n/**\n * <code>Fraction</code> representation of 4/5.\n */\npublic static final Fraction FOUR_FIFTHS = new Fraction(4, 5);\n/**\n * The numerator number part of the fraction (the three in three sevenths).\n */\nprivate final int numerator;\n/**\n * The denominator number part of the fraction (the seven in three sevenths).\n */\nprivate final int denominator;\n/**\n * Cached output hashCode (class is immutable).\n */\nprivate transient int hashCode = 0;\n/**\n * Cached output toString (class is immutable).\n */\nprivate transient String toString = null;\n/**\n * Cached output toProperString (class is immutable).\n */\nprivate transient String toProperString = null;",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "Object",
      "Import_statements": "",
      "public_method_signature": "public static Fraction getFraction(int numerator, int denominator);\npublic static Fraction getFraction(final int whole, final int numerator, final int denominator);\npublic static Fraction getReducedFraction(int numerator, int denominator);\npublic static Fraction getFraction(double value);\npublic static Fraction getFraction(String str);\npublic int getNumerator();\npublic int getDenominator();\npublic int getProperNumerator();\npublic int getProperWhole();\npublic int intValue();\npublic long longValue();\npublic float floatValue();\npublic double doubleValue();\npublic Fraction reduce();\npublic Fraction invert();\npublic Fraction negate();\npublic Fraction abs();\npublic Fraction pow(final int power);\npublic Fraction add(final Fraction fraction);\npublic Fraction subtract(final Fraction fraction);\npublic Fraction multiplyBy(final Fraction fraction);\npublic Fraction divideBy(final Fraction fraction);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic int compareTo(final Fraction other);\npublic String toString();\npublic String toProperString();",
      "public_field": "/**\n * <code>Fraction</code> representation of 0.\n */\npublic static final Fraction ZERO = new Fraction(0, 1);\n/**\n * <code>Fraction</code> representation of 1.\n */\npublic static final Fraction ONE = new Fraction(1, 1);\n/**\n * <code>Fraction</code> representation of 1/2.\n */\npublic static final Fraction ONE_HALF = new Fraction(1, 2);\n/**\n * <code>Fraction</code> representation of 1/3.\n */\npublic static final Fraction ONE_THIRD = new Fraction(1, 3);\n/**\n * <code>Fraction</code> representation of 2/3.\n */\npublic static final Fraction TWO_THIRDS = new Fraction(2, 3);\n/**\n * <code>Fraction</code> representation of 1/4.\n */\npublic static final Fraction ONE_QUARTER = new Fraction(1, 4);\n/**\n * <code>Fraction</code> representation of 2/4.\n */\npublic static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n/**\n * <code>Fraction</code> representation of 3/4.\n */\npublic static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n/**\n * <code>Fraction</code> representation of 1/5.\n */\npublic static final Fraction ONE_FIFTH = new Fraction(1, 5);\n/**\n * <code>Fraction</code> representation of 2/5.\n */\npublic static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n/**\n * <code>Fraction</code> representation of 3/5.\n */\npublic static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n/**\n * <code>Fraction</code> representation of 4/5.\n */\npublic static final Fraction FOUR_FIFTHS = new Fraction(4, 5);",
      "Method_statement": "equals(final Object obj)",
      "Method_name": "equals",
      "Class_declaration": "public  final class Fraction {\n",
      "constructors": "private Fraction(final int numerator, final int denominator) {\n    super();\n    this.numerator = numerator;\n    this.denominator = denominator;\n}",
      "all_method_signature": "private Fraction(final int numerator, final int denominator);\npublic static Fraction getFraction(int numerator, int denominator);\npublic static Fraction getFraction(final int whole, final int numerator, final int denominator);\npublic static Fraction getReducedFraction(int numerator, int denominator);\npublic static Fraction getFraction(double value);\npublic static Fraction getFraction(String str);\npublic int getNumerator();\npublic int getDenominator();\npublic int getProperNumerator();\npublic int getProperWhole();\npublic int intValue();\npublic long longValue();\npublic float floatValue();\npublic double doubleValue();\npublic Fraction reduce();\npublic Fraction invert();\npublic Fraction negate();\npublic Fraction abs();\npublic Fraction pow(final int power);\nprivate static int greatestCommonDivisor(int u, int v);\nprivate static int mulAndCheck(final int x, final int y);\nprivate static int mulPosAndCheck(final int x, final int y);\nprivate static int addAndCheck(final int x, final int y);\nprivate static int subAndCheck(final int x, final int y);\npublic Fraction add(final Fraction fraction);\npublic Fraction subtract(final Fraction fraction);\nprivate Fraction addSub(final Fraction fraction, final boolean isAdd);\npublic Fraction multiplyBy(final Fraction fraction);\npublic Fraction divideBy(final Fraction fraction);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic int compareTo(final Fraction other);\npublic String toString();\npublic String toProperString();",
      "Class_name": "Fraction",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/math/Fraction###equals",
      "Parameter_num": "1",
      "all_Import_statements": "import java.math.BigInteger;\n\nimport org.apache.commons.lang3.Validate;\n",
      "comment": "\n     * <p>Compares this fraction to another object to test if they are equal.</p>.\n     *\n     * <p>To be equal, both values must be equal. Thus 2/4 is not equal to 1/2.</p>\n     *\n     * @param obj the reference object with which to compare\n     * @return <code>true</code> if this object is equal\n     ",
      "packageName": "org.apache.commons.lang3.math",
      "method_signature": "public boolean equals(final Object obj);",
      "Junit_version": "4",
      "returnType": "boolean"
    },
    "Test_method": {
      "Method_body": "Fraction f1 = null;\n\rFraction f2 = null;\n\rf1 = Fraction.getFraction(3, 5);\n\rassertFalse(f1.equals(null));\n\rassertFalse(f1.equals(new Object()));\n\rassertFalse(f1.equals(Integer.valueOf(6)));\n\rf1 = Fraction.getFraction(3, 5);\n\rf2 = Fraction.getFraction(2, 5);\n\rassertFalse(f1.equals(f2));\n\rassertTrue(f1.equals(f1));\n\rassertTrue(f2.equals(f2));\n\rf2 = Fraction.getFraction(3, 5);\n\rassertTrue(f1.equals(f2));\n\rf2 = Fraction.getFraction(6, 10);\n\rassertFalse(f1.equals(f2));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "15",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n",
      "allMethod_info": "@Test\npublic void testEquals() {\n    Fraction f1 = null;\n    Fraction f2 = null;\n    f1 = Fraction.getFraction(3, 5);\n    assertFalse(f1.equals(null));\n    assertFalse(f1.equals(new Object()));\n    assertFalse(f1.equals(Integer.valueOf(6)));\n    f1 = Fraction.getFraction(3, 5);\n    f2 = Fraction.getFraction(2, 5);\n    assertFalse(f1.equals(f2));\n    assertTrue(f1.equals(f1));\n    assertTrue(f2.equals(f2));\n    f2 = Fraction.getFraction(3, 5);\n    assertTrue(f1.equals(f2));\n    f2 = Fraction.getFraction(6, 10);\n    assertFalse(f1.equals(f2));\n}",
      "Method_name": "testEquals",
      "Class_declaration": "public class FractionTest {\n",
      "constructors": "",
      "Class_name": "FractionTest",
      "methodName_paraNum": "[getFraction(2), equals(1), equals(1), equals(1), valueOf(1), getFraction(2), getFraction(2), equals(1), equals(1), equals(1), getFraction(2), equals(1), getFraction(2), equals(1)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/math/FractionTest###testEquals",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/math/FractionTest.java",
      "Signature": "public void testEquals() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertSame;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.junit.Assert.fail;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3.math",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public Fraction reduce() {\n    if (numerator == 0) {\n        return equals(ZERO) ? this : ZERO;\n    }\n    final int gcd = greatestCommonDivisor(Math.abs(numerator), denominator);\n    if (gcd == 1) {\n        return this;\n    }\n    return Fraction.getFraction(numerator / gcd, denominator / gcd);\n}",
      "all_field_declaration": "/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 65382027393090L;\n/**\n * <code>Fraction</code> representation of 0.\n */\npublic static final Fraction ZERO = new Fraction(0, 1);\n/**\n * <code>Fraction</code> representation of 1.\n */\npublic static final Fraction ONE = new Fraction(1, 1);\n/**\n * <code>Fraction</code> representation of 1/2.\n */\npublic static final Fraction ONE_HALF = new Fraction(1, 2);\n/**\n * <code>Fraction</code> representation of 1/3.\n */\npublic static final Fraction ONE_THIRD = new Fraction(1, 3);\n/**\n * <code>Fraction</code> representation of 2/3.\n */\npublic static final Fraction TWO_THIRDS = new Fraction(2, 3);\n/**\n * <code>Fraction</code> representation of 1/4.\n */\npublic static final Fraction ONE_QUARTER = new Fraction(1, 4);\n/**\n * <code>Fraction</code> representation of 2/4.\n */\npublic static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n/**\n * <code>Fraction</code> representation of 3/4.\n */\npublic static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n/**\n * <code>Fraction</code> representation of 1/5.\n */\npublic static final Fraction ONE_FIFTH = new Fraction(1, 5);\n/**\n * <code>Fraction</code> representation of 2/5.\n */\npublic static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n/**\n * <code>Fraction</code> representation of 3/5.\n */\npublic static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n/**\n * <code>Fraction</code> representation of 4/5.\n */\npublic static final Fraction FOUR_FIFTHS = new Fraction(4, 5);\n/**\n * The numerator number part of the fraction (the three in three sevenths).\n */\nprivate final int numerator;\n/**\n * The denominator number part of the fraction (the seven in three sevenths).\n */\nprivate final int denominator;\n/**\n * Cached output hashCode (class is immutable).\n */\nprivate transient int hashCode = 0;\n/**\n * Cached output toString (class is immutable).\n */\nprivate transient String toString = null;\n/**\n * Cached output toProperString (class is immutable).\n */\nprivate transient String toProperString = null;",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "4",
      "Filed": "public static final Fraction ZERO = new Fraction(0, 1);private final int numerator;private final int denominator;",
      "Parameter_type": "",
      "Import_statements": "",
      "public_method_signature": "public static Fraction getFraction(int numerator, int denominator);\npublic static Fraction getFraction(final int whole, final int numerator, final int denominator);\npublic static Fraction getReducedFraction(int numerator, int denominator);\npublic static Fraction getFraction(double value);\npublic static Fraction getFraction(String str);\npublic int getNumerator();\npublic int getDenominator();\npublic int getProperNumerator();\npublic int getProperWhole();\npublic int intValue();\npublic long longValue();\npublic float floatValue();\npublic double doubleValue();\npublic Fraction reduce();\npublic Fraction invert();\npublic Fraction negate();\npublic Fraction abs();\npublic Fraction pow(final int power);\npublic Fraction add(final Fraction fraction);\npublic Fraction subtract(final Fraction fraction);\npublic Fraction multiplyBy(final Fraction fraction);\npublic Fraction divideBy(final Fraction fraction);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic int compareTo(final Fraction other);\npublic String toString();\npublic String toProperString();",
      "public_field": "/**\n * <code>Fraction</code> representation of 0.\n */\npublic static final Fraction ZERO = new Fraction(0, 1);\n/**\n * <code>Fraction</code> representation of 1.\n */\npublic static final Fraction ONE = new Fraction(1, 1);\n/**\n * <code>Fraction</code> representation of 1/2.\n */\npublic static final Fraction ONE_HALF = new Fraction(1, 2);\n/**\n * <code>Fraction</code> representation of 1/3.\n */\npublic static final Fraction ONE_THIRD = new Fraction(1, 3);\n/**\n * <code>Fraction</code> representation of 2/3.\n */\npublic static final Fraction TWO_THIRDS = new Fraction(2, 3);\n/**\n * <code>Fraction</code> representation of 1/4.\n */\npublic static final Fraction ONE_QUARTER = new Fraction(1, 4);\n/**\n * <code>Fraction</code> representation of 2/4.\n */\npublic static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n/**\n * <code>Fraction</code> representation of 3/4.\n */\npublic static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n/**\n * <code>Fraction</code> representation of 1/5.\n */\npublic static final Fraction ONE_FIFTH = new Fraction(1, 5);\n/**\n * <code>Fraction</code> representation of 2/5.\n */\npublic static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n/**\n * <code>Fraction</code> representation of 3/5.\n */\npublic static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n/**\n * <code>Fraction</code> representation of 4/5.\n */\npublic static final Fraction FOUR_FIFTHS = new Fraction(4, 5);",
      "Method_statement": "reduce()",
      "Method_name": "reduce",
      "Class_declaration": "public  final class Fraction {\n",
      "constructors": "private Fraction(final int numerator, final int denominator) {\n    super();\n    this.numerator = numerator;\n    this.denominator = denominator;\n}",
      "all_method_signature": "private Fraction(final int numerator, final int denominator);\npublic static Fraction getFraction(int numerator, int denominator);\npublic static Fraction getFraction(final int whole, final int numerator, final int denominator);\npublic static Fraction getReducedFraction(int numerator, int denominator);\npublic static Fraction getFraction(double value);\npublic static Fraction getFraction(String str);\npublic int getNumerator();\npublic int getDenominator();\npublic int getProperNumerator();\npublic int getProperWhole();\npublic int intValue();\npublic long longValue();\npublic float floatValue();\npublic double doubleValue();\npublic Fraction reduce();\npublic Fraction invert();\npublic Fraction negate();\npublic Fraction abs();\npublic Fraction pow(final int power);\nprivate static int greatestCommonDivisor(int u, int v);\nprivate static int mulAndCheck(final int x, final int y);\nprivate static int mulPosAndCheck(final int x, final int y);\nprivate static int addAndCheck(final int x, final int y);\nprivate static int subAndCheck(final int x, final int y);\npublic Fraction add(final Fraction fraction);\npublic Fraction subtract(final Fraction fraction);\nprivate Fraction addSub(final Fraction fraction, final boolean isAdd);\npublic Fraction multiplyBy(final Fraction fraction);\npublic Fraction divideBy(final Fraction fraction);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic int compareTo(final Fraction other);\npublic String toString();\npublic String toProperString();",
      "Class_name": "Fraction",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/math/Fraction###reduce",
      "Parameter_num": "0",
      "all_Import_statements": "import java.math.BigInteger;\n\nimport org.apache.commons.lang3.Validate;\n",
      "comment": "\n     * <p>Reduce the fraction to the smallest values for the numerator and\n     * denominator, returning the result.</p>\n     *\n     * <p>For example, if this fraction represents 2/4, then the result\n     * will be 1/2.</p>\n     *\n     * @return a new reduced fraction instance, or this if no simplification possible\n     ",
      "packageName": "org.apache.commons.lang3.math",
      "method_signature": "public Fraction reduce();",
      "Junit_version": "4",
      "returnType": "Fraction"
    },
    "Test_method": {
      "Method_body": "Fraction f = null;\n\rf = Fraction.getFraction(50, 75);\n\rFraction result = f.reduce();\n\rassertEquals(2, result.getNumerator());\n\rassertEquals(3, result.getDenominator());\n\rf = Fraction.getFraction(-2, -3);\n\rresult = f.reduce();\n\rassertEquals(2, result.getNumerator());\n\rassertEquals(3, result.getDenominator());\n\rf = Fraction.getFraction(2, -3);\n\rresult = f.reduce();\n\rassertEquals(-2, result.getNumerator());\n\rassertEquals(3, result.getDenominator());\n\rf = Fraction.getFraction(-2, 3);\n\rresult = f.reduce();\n\rassertEquals(-2, result.getNumerator());\n\rassertEquals(3, result.getDenominator());\n\rassertSame(f, result);\n\rf = Fraction.getFraction(2, 3);\n\rresult = f.reduce();\n\rassertEquals(2, result.getNumerator());\n\rassertEquals(3, result.getDenominator());\n\rassertSame(f, result);\n\rf = Fraction.getFraction(0, 1);\n\rresult = f.reduce();\n\rassertEquals(0, result.getNumerator());\n\rassertEquals(1, result.getDenominator());\n\rassertSame(f, result);\n\rf = Fraction.getFraction(0, 100);\n\rresult = f.reduce();\n\rassertEquals(0, result.getNumerator());\n\rassertEquals(1, result.getDenominator());\n\rassertSame(result, Fraction.ZERO);\n\rf = Fraction.getFraction(Integer.MIN_VALUE, 2);\n\rresult = f.reduce();\n\rassertEquals(Integer.MIN_VALUE / 2, result.getNumerator());\n\rassertEquals(1, result.getDenominator());",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "37",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertSame;\n",
      "allMethod_info": "@Test\npublic void testReduce() {\n    Fraction f = null;\n    f = Fraction.getFraction(50, 75);\n    Fraction result = f.reduce();\n    assertEquals(2, result.getNumerator());\n    assertEquals(3, result.getDenominator());\n    f = Fraction.getFraction(-2, -3);\n    result = f.reduce();\n    assertEquals(2, result.getNumerator());\n    assertEquals(3, result.getDenominator());\n    f = Fraction.getFraction(2, -3);\n    result = f.reduce();\n    assertEquals(-2, result.getNumerator());\n    assertEquals(3, result.getDenominator());\n    f = Fraction.getFraction(-2, 3);\n    result = f.reduce();\n    assertEquals(-2, result.getNumerator());\n    assertEquals(3, result.getDenominator());\n    assertSame(f, result);\n    f = Fraction.getFraction(2, 3);\n    result = f.reduce();\n    assertEquals(2, result.getNumerator());\n    assertEquals(3, result.getDenominator());\n    assertSame(f, result);\n    f = Fraction.getFraction(0, 1);\n    result = f.reduce();\n    assertEquals(0, result.getNumerator());\n    assertEquals(1, result.getDenominator());\n    assertSame(f, result);\n    f = Fraction.getFraction(0, 100);\n    result = f.reduce();\n    assertEquals(0, result.getNumerator());\n    assertEquals(1, result.getDenominator());\n    assertSame(result, Fraction.ZERO);\n    f = Fraction.getFraction(Integer.MIN_VALUE, 2);\n    result = f.reduce();\n    assertEquals(Integer.MIN_VALUE / 2, result.getNumerator());\n    assertEquals(1, result.getDenominator());\n}",
      "Method_name": "testReduce",
      "Class_declaration": "public class FractionTest {\n",
      "constructors": "",
      "Class_name": "FractionTest",
      "methodName_paraNum": "[getFraction(2), reduce(0), getNumerator(0), getDenominator(0), getFraction(2), reduce(0), getNumerator(0), getDenominator(0), getFraction(2), reduce(0), getNumerator(0), getDenominator(0), getFraction(2), reduce(0), getNumerator(0), getDenominator(0), getFraction(2), reduce(0), getNumerator(0), getDenominator(0), getFraction(2), reduce(0), getNumerator(0), getDenominator(0), getFraction(2), reduce(0), getNumerator(0), getDenominator(0), getFraction(2), reduce(0), getNumerator(0), getDenominator(0)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/math/FractionTest###testReduce",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/math/FractionTest.java",
      "Signature": "public void testReduce() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertSame;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.junit.Assert.fail;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3.math",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic boolean equals(Object obj) {\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (this.getClass() != obj.getClass())\n        return false;\n    IntDoubleHashMap other = (IntDoubleHashMap) obj;\n    if (this.size() != other.size()) {\n        return false;\n    }\n    for (int i = 0; i < keys.length; i++) {\n        if (states[i] == FULL) {\n            if (!other.contains(keys[i]))\n                return false;\n            if (other.get(keys[i]) != values[i])\n                return false;\n        }\n    }\n    return true;\n}",
      "all_field_declaration": "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;\n/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;\n/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;\n/**\n * Serializable version identifier\n */\nprivate static final long serialVersionUID = -3646337053166149105L;\n/**\n * Load factor for the map.\n */\nprivate static final float LOAD_FACTOR = 0.75f;\n/**\n * Default starting size.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprotected static final int DEFAULT_EXPECTED_SIZE = 16;\n/**\n * Multiplier for size growth when map fills up.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprivate static final int RESIZE_MULTIPLIER = 2;\n/**\n * Number of bits to perturb the index when probing for collision resolution.\n */\nprivate static final int PERTURB_SHIFT = 5;\n/**\n * Keys table.\n */\nprotected int[] keys;\n/**\n * Values table.\n */\nprotected double[] values;\n/**\n * States table.\n */\nprotected byte[] states;\n/**\n * Return value for missing entries.\n */\nprivate final double missingEntries;\n/**\n * Current size of the map.\n */\nprivate int size;\n/**\n * Bit mask for hash values.\n */\nprivate int mask;\n/**\n * Modifications count.\n */\nprivate transient int count;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "7",
      "Filed": "protected static final byte FULL = 1;protected int[] keys;protected double[] values;protected byte[] states;private int size;",
      "Parameter_type": "Object",
      "Import_statements": "",
      "public_method_signature": "public IntDoubleHashMap();\npublic IntDoubleHashMap(final int expectedSize);\npublic IntDoubleHashMap(final int expectedSize, final double missingEntries);\npublic IntDoubleHashMap(final IntDoubleHashMap source);\npublic IntDoubleHashMap(int[] keys, double[] vals);\npublic double get(final int key);\npublic double getWithDefault(int key, double missingEntries);\npublic boolean contains(final int key);\npublic Iterator<IntDoubleEntry> iterator();\npublic int size();\npublic void remove(final int key);\npublic double removeAndGet(final int key);\npublic void clear();\npublic double put(final int key, final double value);\npublic double putAndGet(final int key, final double value);\npublic void add(final int key, final double value);\npublic double addAndGet(final int key, final double value);\npublic int[] getIndices();\npublic double[] getValues();\npublic Pair<int[], double[]> getIndicesAndValues();\npublic void apply(FnIntDoubleToDouble lambda);\npublic void iterate(FnIntDoubleToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "public_field": "",
      "Method_statement": "equals(Object obj)",
      "Method_name": "equals",
      "Class_declaration": "public class IntDoubleHashMap {\n",
      "constructors": "public IntDoubleHashMap() {\n    this(DEFAULT_EXPECTED_SIZE, Primitives.DEFAULT_MISSING_ENTRY_DOUBLE);\n}public IntDoubleHashMap(final int expectedSize) {\n    this(expectedSize, Primitives.DEFAULT_MISSING_ENTRY_DOUBLE);\n}public IntDoubleHashMap(final int expectedSize, final double missingEntries) {\n    final int capacity = computeCapacity(expectedSize);\n    keys = new int[capacity];\n    values = new double[capacity];\n    states = new byte[capacity];\n    this.missingEntries = missingEntries;\n    size = 0;\n    mask = capacity - 1;\n    count = 0;\n}public IntDoubleHashMap(final IntDoubleHashMap source) {\n    final int length = source.keys.length;\n    keys = new int[length];\n    System.arraycopy(source.keys, 0, keys, 0, length);\n    values = new double[length];\n    System.arraycopy(source.values, 0, values, 0, length);\n    states = new byte[length];\n    System.arraycopy(source.states, 0, states, 0, length);\n    missingEntries = source.missingEntries;\n    size = source.size;\n    mask = source.mask;\n    count = source.count;\n}public IntDoubleHashMap(int[] keys, double[] vals) {\n    this(keys.length, Primitives.DEFAULT_MISSING_ENTRY_DOUBLE);\n    if (keys.length != vals.length) {\n        throw new IllegalStateException(\"keys and vals must be of the same length\");\n    }\n    for (int i = 0; i < keys.length; i++) {\n        this.put(keys[i], vals[i]);\n    }\n}",
      "all_method_signature": "public IntDoubleHashMap();\npublic IntDoubleHashMap(final int expectedSize);\npublic IntDoubleHashMap(final int expectedSize, final double missingEntries);\npublic IntDoubleHashMap(final IntDoubleHashMap source);\npublic IntDoubleHashMap(int[] keys, double[] vals);\nprivate static int computeCapacity(final int expectedSize);\nprivate static int nextPowerOfTwo(final int i);\npublic double get(final int key);\npublic double getWithDefault(int key, double missingEntries);\npublic boolean contains(final int key);\npublic Iterator<IntDoubleEntry> iterator();\nprivate static int perturb(final int hash);\nprivate int findInsertionIndex(final int key);\nprivate static int findInsertionIndex(final int[] keys, final byte[] states, final int key, final int mask);\nprivate static int probe(final int perturb, final int j);\nprivate static int changeIndexSign(final int index);\npublic int size();\npublic void remove(final int key);\npublic double removeAndGet(final int key);\npublic void clear();\nprivate boolean contains(final int key, final int index);\nprivate double doRemove(int index);\npublic double put(final int key, final double value);\npublic double putAndGet(final int key, final double value);\npublic void add(final int key, final double value);\npublic double addAndGet(final int key, final double value);\nprivate void growTable();\nprivate boolean shouldGrowTable();\nprivate static int hashOf(final int key);\nprivate void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException;\npublic int[] getIndices();\npublic double[] getValues();\npublic Pair<int[], double[]> getIndicesAndValues();\npublic void apply(FnIntDoubleToDouble lambda);\npublic void iterate(FnIntDoubleToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "Class_name": "IntDoubleHashMap",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java_generated/edu/jhu/prim/map/IntDoubleHashMap###equals",
      "Parameter_num": "1",
      "all_Import_statements": "import java.io.IOException;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.Serializable;\n\nimport java.util.Arrays;\n\nimport java.util.ConcurrentModificationException;\n\nimport java.util.Iterator;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.Map.Entry;\n\nimport edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.sort.IntDoubleSort;\n\nimport edu.jhu.prim.tuple.Pair;\n\nimport edu.jhu.prim.util.Lambda.FnIntDoubleToDouble;\n\nimport edu.jhu.prim.util.Lambda.FnIntDoubleToVoid;\n\nimport edu.jhu.prim.vector.AbstractIntDoubleVector;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "method_signature": "public boolean equals(Object obj);",
      "Junit_version": "4",
      "returnType": "boolean"
    },
    "Test_method": {
      "Method_body": "IntDoubleHashMap m1 = new IntDoubleHashMap();\n\rIntDoubleHashMap m2 = new IntDoubleHashMap();\n\rassertTrue(m1.equals(m2));\n\rm1.put(2, toDouble(22));\n\rm1.put(1, toDouble(11));\n\rassertFalse(m1.equals(m2));\n\rm2.put(1, toDouble(11));\n\rm2.put(2, toDouble(22));\n\rassertTrue(m1.equals(m2));\n\rm2.put(3, toDouble(33));\n\rassertFalse(m1.equals(m2));\n\rm1.put(3, toDouble(33));\n\rassertTrue(m1.equals(m2));",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "13",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toDouble;\n",
      "allMethod_info": "@Test\npublic void testEquals() throws Exception {\n    IntDoubleHashMap m1 = new IntDoubleHashMap();\n    IntDoubleHashMap m2 = new IntDoubleHashMap();\n    assertTrue(m1.equals(m2));\n    m1.put(2, toDouble(22));\n    m1.put(1, toDouble(11));\n    assertFalse(m1.equals(m2));\n    m2.put(1, toDouble(11));\n    m2.put(2, toDouble(22));\n    assertTrue(m1.equals(m2));\n    m2.put(3, toDouble(33));\n    assertFalse(m1.equals(m2));\n    m1.put(3, toDouble(33));\n    assertTrue(m1.equals(m2));\n}",
      "Method_name": "testEquals",
      "Class_declaration": "public class IntDoubleHashMapTest {\n",
      "constructors": "",
      "Class_name": "IntDoubleHashMapTest",
      "methodName_paraNum": "[equals(1), put(2), toDouble(1), put(2), toDouble(1), equals(1), put(2), toDouble(1), put(2), toDouble(1), equals(1), put(2), toDouble(1), equals(1), put(2), toDouble(1), equals(1)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntDoubleHashMapTest###testEquals",
      "relativePath": "mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntDoubleHashMapTest.java",
      "Signature": "public void testEquals() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toDouble;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n\nimport edu.jhu.prim.Primitives;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic int hashCode() {\n    int h = 0;\n    int[] indices = getIndices();\n    double[] values = getValues();\n    IntDoubleSort.sortIndexAsc(indices, values);\n    for (int i = 0; i < indices.length; i++) {\n        int result = 17;\n        result = 37 * result + Primitives.hashOfInt(indices[i]);\n        result = 37 * result + Primitives.hashOfDouble(values[i]);\n        h += result;\n    }\n    return h;\n}",
      "all_field_declaration": "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;\n/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;\n/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;\n/**\n * Serializable version identifier\n */\nprivate static final long serialVersionUID = -3646337053166149105L;\n/**\n * Load factor for the map.\n */\nprivate static final float LOAD_FACTOR = 0.75f;\n/**\n * Default starting size.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprotected static final int DEFAULT_EXPECTED_SIZE = 16;\n/**\n * Multiplier for size growth when map fills up.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprivate static final int RESIZE_MULTIPLIER = 2;\n/**\n * Number of bits to perturb the index when probing for collision resolution.\n */\nprivate static final int PERTURB_SHIFT = 5;\n/**\n * Keys table.\n */\nprotected int[] keys;\n/**\n * Values table.\n */\nprotected double[] values;\n/**\n * States table.\n */\nprotected byte[] states;\n/**\n * Return value for missing entries.\n */\nprivate final double missingEntries;\n/**\n * Current size of the map.\n */\nprivate int size;\n/**\n * Bit mask for hash values.\n */\nprivate int mask;\n/**\n * Modifications count.\n */\nprivate transient int count;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "6",
      "Filed": "protected double[] values;",
      "Parameter_type": "",
      "Import_statements": "import edu.jhu.prim.Primitives;\nimport edu.jhu.prim.sort.IntDoubleSort;\n",
      "public_method_signature": "public IntDoubleHashMap();\npublic IntDoubleHashMap(final int expectedSize);\npublic IntDoubleHashMap(final int expectedSize, final double missingEntries);\npublic IntDoubleHashMap(final IntDoubleHashMap source);\npublic IntDoubleHashMap(int[] keys, double[] vals);\npublic double get(final int key);\npublic double getWithDefault(int key, double missingEntries);\npublic boolean contains(final int key);\npublic Iterator<IntDoubleEntry> iterator();\npublic int size();\npublic void remove(final int key);\npublic double removeAndGet(final int key);\npublic void clear();\npublic double put(final int key, final double value);\npublic double putAndGet(final int key, final double value);\npublic void add(final int key, final double value);\npublic double addAndGet(final int key, final double value);\npublic int[] getIndices();\npublic double[] getValues();\npublic Pair<int[], double[]> getIndicesAndValues();\npublic void apply(FnIntDoubleToDouble lambda);\npublic void iterate(FnIntDoubleToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "public_field": "",
      "Method_statement": "hashCode()",
      "Method_name": "hashCode",
      "Class_declaration": "public class IntDoubleHashMap {\n",
      "constructors": "public IntDoubleHashMap() {\n    this(DEFAULT_EXPECTED_SIZE, Primitives.DEFAULT_MISSING_ENTRY_DOUBLE);\n}public IntDoubleHashMap(final int expectedSize) {\n    this(expectedSize, Primitives.DEFAULT_MISSING_ENTRY_DOUBLE);\n}public IntDoubleHashMap(final int expectedSize, final double missingEntries) {\n    final int capacity = computeCapacity(expectedSize);\n    keys = new int[capacity];\n    values = new double[capacity];\n    states = new byte[capacity];\n    this.missingEntries = missingEntries;\n    size = 0;\n    mask = capacity - 1;\n    count = 0;\n}public IntDoubleHashMap(final IntDoubleHashMap source) {\n    final int length = source.keys.length;\n    keys = new int[length];\n    System.arraycopy(source.keys, 0, keys, 0, length);\n    values = new double[length];\n    System.arraycopy(source.values, 0, values, 0, length);\n    states = new byte[length];\n    System.arraycopy(source.states, 0, states, 0, length);\n    missingEntries = source.missingEntries;\n    size = source.size;\n    mask = source.mask;\n    count = source.count;\n}public IntDoubleHashMap(int[] keys, double[] vals) {\n    this(keys.length, Primitives.DEFAULT_MISSING_ENTRY_DOUBLE);\n    if (keys.length != vals.length) {\n        throw new IllegalStateException(\"keys and vals must be of the same length\");\n    }\n    for (int i = 0; i < keys.length; i++) {\n        this.put(keys[i], vals[i]);\n    }\n}",
      "all_method_signature": "public IntDoubleHashMap();\npublic IntDoubleHashMap(final int expectedSize);\npublic IntDoubleHashMap(final int expectedSize, final double missingEntries);\npublic IntDoubleHashMap(final IntDoubleHashMap source);\npublic IntDoubleHashMap(int[] keys, double[] vals);\nprivate static int computeCapacity(final int expectedSize);\nprivate static int nextPowerOfTwo(final int i);\npublic double get(final int key);\npublic double getWithDefault(int key, double missingEntries);\npublic boolean contains(final int key);\npublic Iterator<IntDoubleEntry> iterator();\nprivate static int perturb(final int hash);\nprivate int findInsertionIndex(final int key);\nprivate static int findInsertionIndex(final int[] keys, final byte[] states, final int key, final int mask);\nprivate static int probe(final int perturb, final int j);\nprivate static int changeIndexSign(final int index);\npublic int size();\npublic void remove(final int key);\npublic double removeAndGet(final int key);\npublic void clear();\nprivate boolean contains(final int key, final int index);\nprivate double doRemove(int index);\npublic double put(final int key, final double value);\npublic double putAndGet(final int key, final double value);\npublic void add(final int key, final double value);\npublic double addAndGet(final int key, final double value);\nprivate void growTable();\nprivate boolean shouldGrowTable();\nprivate static int hashOf(final int key);\nprivate void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException;\npublic int[] getIndices();\npublic double[] getValues();\npublic Pair<int[], double[]> getIndicesAndValues();\npublic void apply(FnIntDoubleToDouble lambda);\npublic void iterate(FnIntDoubleToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "Class_name": "IntDoubleHashMap",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java_generated/edu/jhu/prim/map/IntDoubleHashMap###hashCode",
      "Parameter_num": "0",
      "all_Import_statements": "import java.io.IOException;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.Serializable;\n\nimport java.util.Arrays;\n\nimport java.util.ConcurrentModificationException;\n\nimport java.util.Iterator;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.Map.Entry;\n\nimport edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.sort.IntDoubleSort;\n\nimport edu.jhu.prim.tuple.Pair;\n\nimport edu.jhu.prim.util.Lambda.FnIntDoubleToDouble;\n\nimport edu.jhu.prim.util.Lambda.FnIntDoubleToVoid;\n\nimport edu.jhu.prim.vector.AbstractIntDoubleVector;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "method_signature": "public int hashCode();",
      "Junit_version": "4",
      "returnType": "int"
    },
    "Test_method": {
      "Method_body": "IntDoubleHashMap m1 = new IntDoubleHashMap();\n\rIntDoubleHashMap m2 = new IntDoubleHashMap();\n\rassertEquals(m1.hashCode(), m2.hashCode());\n\rm1.put(2, toDouble(22));\n\rm1.put(1, toDouble(11));\n\rm2.put(1, toDouble(11));\n\rm2.put(2, toDouble(22));\n\rassertEquals(m1.hashCode(), m2.hashCode());\n\rm2.put(3, toDouble(33));\n\rm1.put(3, toDouble(33));\n\rassertEquals(m1.hashCode(), m2.hashCode());",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "11",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toDouble;\n",
      "allMethod_info": "@Test\npublic void testHashCode() throws Exception {\n    IntDoubleHashMap m1 = new IntDoubleHashMap();\n    IntDoubleHashMap m2 = new IntDoubleHashMap();\n    assertEquals(m1.hashCode(), m2.hashCode());\n    m1.put(2, toDouble(22));\n    m1.put(1, toDouble(11));\n    m2.put(1, toDouble(11));\n    m2.put(2, toDouble(22));\n    assertEquals(m1.hashCode(), m2.hashCode());\n    m2.put(3, toDouble(33));\n    m1.put(3, toDouble(33));\n    assertEquals(m1.hashCode(), m2.hashCode());\n}",
      "Method_name": "testHashCode",
      "Class_declaration": "public class IntDoubleHashMapTest {\n",
      "constructors": "",
      "Class_name": "IntDoubleHashMapTest",
      "methodName_paraNum": "[hashCode(0), hashCode(0), put(2), toDouble(1), put(2), toDouble(1), put(2), toDouble(1), put(2), toDouble(1), hashCode(0), hashCode(0), put(2), toDouble(1), put(2), toDouble(1), hashCode(0), hashCode(0)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntDoubleHashMapTest###testHashCode",
      "relativePath": "mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntDoubleHashMapTest.java",
      "Signature": "public void testHashCode() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toDouble;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n\nimport edu.jhu.prim.Primitives;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic void remove(int idx) {\n    int i = Arrays.binarySearch(indices, 0, used, idx);\n    if (i < 0) {\n        throw new IllegalArgumentException(\"This map does not contain the key: \" + idx);\n    }\n    System.arraycopy(indices, i + 1, indices, i, used - i - 1);\n    System.arraycopy(values, i + 1, values, i, used - i - 1);\n    used--;\n}",
      "all_field_declaration": "private static final long serialVersionUID = 1L;\nprotected int[] indices;\nprotected double[] values;\n// TODO: size\nprotected int used;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "5",
      "Filed": "protected int[] indices;protected double[] values;protected int used;",
      "Parameter_type": "int",
      "Import_statements": "import java.util.Arrays;\n",
      "public_method_signature": "public IntDoubleSortedMap();\npublic IntDoubleSortedMap(int initialSize);\npublic IntDoubleSortedMap(int[] index, double[] data);\npublic IntDoubleSortedMap(IntDoubleSortedMap other);\npublic IntDoubleSortedMap(IntDoubleHashMap other);\npublic void clear();\npublic boolean contains(int idx);\npublic double get(int idx);\npublic double getWithDefault(int idx, double defaultVal);\npublic void remove(int idx);\npublic double put(int idx, double val);\npublic void add(int idx, double val);\npublic void apply(FnIntDoubleToDouble lambda);\npublic void iterate(FnIntDoubleToVoid lambda);\npublic Iterator<IntDoubleEntry> iterator();\npublic int size();\npublic int getUsed();\npublic int[] getIndices();\npublic double[] getValues();\npublic int[] getInternalIndices();\npublic double[] getInternalValues();",
      "public_field": "",
      "Method_statement": "remove(int idx)",
      "Method_name": "remove",
      "Class_declaration": "public class IntDoubleSortedMap {\n",
      "constructors": "public IntDoubleSortedMap() {\n    this(0);\n}public IntDoubleSortedMap(int initialSize) {\n    this.used = 0;\n    this.indices = new int[initialSize];\n    this.values = new double[initialSize];\n}public IntDoubleSortedMap(int[] index, double[] data) {\n    if (!IntSort.isSortedAscAndUnique(index)) {\n        throw new IllegalStateException(\"Indices are not sorted ascending\");\n    }\n    this.used = index.length;\n    this.indices = index;\n    this.values = data;\n}public IntDoubleSortedMap(IntDoubleSortedMap other) {\n    this.used = other.used;\n    this.indices = IntArrays.copyOf(other.indices);\n    this.values = DoubleArrays.copyOf(other.values);\n}public IntDoubleSortedMap(IntDoubleHashMap other) {\n    Pair<int[], double[]> pair = other.getIndicesAndValues();\n    IntDoubleSort.sortIndexAsc(pair.get1(), pair.get2());\n    this.used = other.size();\n    this.indices = pair.get1();\n    this.values = pair.get2();\n}",
      "all_method_signature": "public IntDoubleSortedMap();\npublic IntDoubleSortedMap(int initialSize);\npublic IntDoubleSortedMap(int[] index, double[] data);\npublic IntDoubleSortedMap(IntDoubleSortedMap other);\npublic IntDoubleSortedMap(IntDoubleHashMap other);\npublic void clear();\npublic boolean contains(int idx);\npublic double get(int idx);\npublic double getWithDefault(int idx, double defaultVal);\npublic void remove(int idx);\npublic double put(int idx, double val);\npublic void add(int idx, double val);\npublic void apply(FnIntDoubleToDouble lambda);\npublic void iterate(FnIntDoubleToVoid lambda);\nprivate final int[] insert(int[] array, int i, int val);\nprivate final double[] insert(double[] array, int i, double val);\npublic Iterator<IntDoubleEntry> iterator();\npublic int size();\npublic int getUsed();\npublic int[] getIndices();\npublic double[] getValues();\npublic int[] getInternalIndices();\npublic double[] getInternalValues();",
      "Class_name": "IntDoubleSortedMap",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java_generated/edu/jhu/prim/map/IntDoubleSortedMap###remove",
      "Parameter_num": "1",
      "all_Import_statements": "import java.util.Arrays;\n\nimport java.util.Iterator;\n\nimport edu.jhu.prim.arrays.DoubleArrays;\n\nimport edu.jhu.prim.arrays.IntArrays;\n\nimport edu.jhu.prim.list.DoubleArrayList;\n\nimport edu.jhu.prim.list.IntArrayList;\n\nimport edu.jhu.prim.sort.IntDoubleSort;\n\nimport edu.jhu.prim.sort.IntSort;\n\nimport edu.jhu.prim.tuple.Pair;\n\nimport edu.jhu.prim.util.Lambda.FnIntDoubleToDouble;\n\nimport edu.jhu.prim.util.Lambda.FnIntDoubleToVoid;\n\nimport edu.jhu.prim.vector.AbstractIntDoubleVector;\n",
      "comment": " (non-Javadoc)\n     * @see edu.jhu.util.vector.IntDoubleMap#remove(int)\n     ",
      "packageName": "edu.jhu.prim.map",
      "method_signature": "public void remove(int idx);",
      "Junit_version": "4",
      "returnType": "void"
    },
    "Test_method": {
      "Method_body": "// First element.\nIntDoubleMap map = new IntDoubleSortedMap();\n\rmap.put(2, toDouble(22));\n\rmap.put(1, toDouble(11));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(11, toInt(map.get(1)));\n\rmap.remove(1);\n\rassertEquals(false, map.contains(1));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(1, map.size());\n\r// Middle element.\nmap = new IntDoubleSortedMap();\n\rmap.put(2, toDouble(22));\n\rmap.put(3, toDouble(33));\n\rmap.put(1, toDouble(11));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(33, toInt(map.get(3)));\n\rmap.remove(2);\n\rassertEquals(false, map.contains(2));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(33, toInt(map.get(3)));\n\rassertEquals(2, map.size());\n\r// Last element.\nmap = new IntDoubleSortedMap();\n\rmap.put(2, toDouble(22));\n\rmap.put(3, toDouble(33));\n\rmap.put(1, toDouble(11));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(33, toInt(map.get(3)));\n\rmap.remove(3);\n\rassertEquals(false, map.contains(3));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(2, map.size());",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "33",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toDouble;\nimport static edu.jhu.prim.Primitives.toInt;\nimport static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "@Test\npublic void testRemove() {\n    // First element.\n    IntDoubleMap map = new IntDoubleSortedMap();\n    map.put(2, toDouble(22));\n    map.put(1, toDouble(11));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(11, toInt(map.get(1)));\n    map.remove(1);\n    assertEquals(false, map.contains(1));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(1, map.size());\n    // Middle element.\n    map = new IntDoubleSortedMap();\n    map.put(2, toDouble(22));\n    map.put(3, toDouble(33));\n    map.put(1, toDouble(11));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(33, toInt(map.get(3)));\n    map.remove(2);\n    assertEquals(false, map.contains(2));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(33, toInt(map.get(3)));\n    assertEquals(2, map.size());\n    // Last element.\n    map = new IntDoubleSortedMap();\n    map.put(2, toDouble(22));\n    map.put(3, toDouble(33));\n    map.put(1, toDouble(11));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(33, toInt(map.get(3)));\n    map.remove(3);\n    assertEquals(false, map.contains(3));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(2, map.size());\n}",
      "Method_name": "testRemove",
      "Class_declaration": "public class IntDoubleSortedMapTest {\n",
      "constructors": "",
      "Class_name": "IntDoubleSortedMapTest",
      "methodName_paraNum": "[put(2), toDouble(1), put(2), toDouble(1), toInt(1), get(1), toInt(1), get(1), remove(1), contains(1), toInt(1), get(1), size(0), put(2), toDouble(1), put(2), toDouble(1), put(2), toDouble(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), remove(1), contains(1), toInt(1), get(1), toInt(1), get(1), size(0), put(2), toDouble(1), put(2), toDouble(1), put(2), toDouble(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), remove(1), contains(1), toInt(1), get(1), toInt(1), get(1), size(0)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntDoubleSortedMapTest###testRemove",
      "relativePath": "mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntDoubleSortedMapTest.java",
      "Signature": "public void testRemove() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toDouble;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static IntDoubleSortedVector getWithNoZeroValues(IntDoubleSortedVector row, double zeroThreshold) {\n    int[] origIndex = row.getIndices();\n    double[] origData = row.getValues();\n    int numNonZeros = 0;\n    boolean[] isNonZero = new boolean[row.getUsed()];\n    for (int i = 0; i < row.getUsed(); i++) {\n        if (!Primitives.isZero(origData[i], zeroThreshold)) {\n            isNonZero[i] = true;\n            numNonZeros++;\n        } else {\n            isNonZero[i] = false;\n        }\n    }\n    int numZeros = row.getUsed() - numNonZeros;\n    if (numZeros > 0) {\n        int[] newIndex = new int[numNonZeros];\n        double[] newData = new double[numNonZeros];\n        int newIdx = 0;\n        for (int i = 0; i < row.getUsed(); i++) {\n            if (isNonZero[i]) {\n                newIndex[newIdx] = origIndex[i];\n                newData[newIdx] = origData[i];\n                newIdx++;\n            }\n        }\n        return new IntDoubleSortedVector(newIndex, newData);\n    } else {\n        return row;\n    }\n}",
      "all_field_declaration": "private static final long serialVersionUID = 1L;\nprivate static final double ZERO = (double) 0;\nboolean norm2Cached = false;\ndouble norm2Value;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "7",
      "Filed": "",
      "Parameter_type": "IntDoubleSortedVector,double",
      "Import_statements": "import edu.jhu.prim.Primitives;\n",
      "public_method_signature": "public IntDoubleSortedVector();\npublic IntDoubleSortedVector(int initialSize);\npublic IntDoubleSortedVector(int[] index, double[] data);\npublic IntDoubleSortedVector(double[] denseRow);\npublic IntDoubleSortedVector(IntDoubleSortedVector vector);\npublic IntDoubleSortedVector(IntDoubleHashVector vector);\npublic IntDoubleSortedVector(IntDoubleDenseVector vector);\npublic IntDoubleSortedVector(IntDoubleVector other);\npublic IntDoubleVector copy();\npublic void add(int idx, double val);\npublic double set(int idx, double val);\npublic double get(int idx);\npublic void scale(double multiplier);\npublic double dot(double[] other);\npublic double dot(double[][] matrix, int col);\npublic double dot(IntDoubleVector y);\npublic static IntDoubleSortedVector getWithNoZeroValues(IntDoubleSortedVector row, double zeroThreshold);\npublic IntDoubleSortedVector zero();\npublic void set(IntDoubleSortedVector other);\npublic void add(IntDoubleVector other);\npublic void subtract(IntDoubleVector other);\npublic void product(IntDoubleVector other);\npublic IntDoubleSortedVector getSum(IntDoubleVector other);\npublic IntDoubleSortedVector getDiff(IntDoubleVector other);\npublic IntDoubleSortedVector getProd(IntDoubleVector other);\npublic void apply(IntDoubleVector other, LambdaBinOpDouble lambda, boolean skipZeros);\npublic String toString();\npublic boolean eq(IntDoubleSortedVector other, double delta);\npublic int getNumImplicitEntries();\npublic double[] toNativeArray();\npublic int hashCode();",
      "public_field": "",
      "Method_statement": "getWithNoZeroValues(IntDoubleSortedVector row, double zeroThreshold)",
      "Method_name": "getWithNoZeroValues",
      "Class_declaration": "public class IntDoubleSortedVector {\n",
      "constructors": "public IntDoubleSortedVector() {\n    super();\n}public IntDoubleSortedVector(int initialSize) {\n    super(initialSize);\n}public IntDoubleSortedVector(int[] index, double[] data) {\n    super(index, data);\n}public IntDoubleSortedVector(double[] denseRow) {\n    this(IntArrays.range(denseRow.length), denseRow);\n}public IntDoubleSortedVector(IntDoubleSortedVector vector) {\n    super(vector);\n}public IntDoubleSortedVector(IntDoubleHashVector vector) {\n    super(vector);\n}public IntDoubleSortedVector(IntDoubleDenseVector vector) {\n    this(vector.toNativeArray());\n}public IntDoubleSortedVector(IntDoubleVector other) {\n    this();\n    final IntDoubleSortedVector thisVec = this;\n    other.iterate(new FnIntDoubleToVoid() {\n\n        @Override\n        public void call(int idx, double val) {\n            thisVec.set(idx, val);\n        }\n    });\n}",
      "all_method_signature": "public IntDoubleSortedVector();\npublic IntDoubleSortedVector(int initialSize);\npublic IntDoubleSortedVector(int[] index, double[] data);\npublic IntDoubleSortedVector(double[] denseRow);\npublic IntDoubleSortedVector(IntDoubleSortedVector vector);\npublic IntDoubleSortedVector(IntDoubleHashVector vector);\npublic IntDoubleSortedVector(IntDoubleDenseVector vector);\npublic IntDoubleSortedVector(IntDoubleVector other);\npublic IntDoubleVector copy();\npublic void add(int idx, double val);\npublic double set(int idx, double val);\npublic double get(int idx);\npublic void scale(double multiplier);\npublic double dot(double[] other);\npublic double dot(double[][] matrix, int col);\npublic double dot(IntDoubleVector y);\npublic static IntDoubleSortedVector getWithNoZeroValues(IntDoubleSortedVector row, double zeroThreshold);\npublic IntDoubleSortedVector zero();\npublic void set(IntDoubleSortedVector other);\npublic void add(IntDoubleVector other);\npublic void subtract(IntDoubleVector other);\npublic void product(IntDoubleVector other);\npublic IntDoubleSortedVector getSum(IntDoubleVector other);\npublic IntDoubleSortedVector getDiff(IntDoubleVector other);\npublic IntDoubleSortedVector getProd(IntDoubleVector other);\npublic void apply(IntDoubleVector other, LambdaBinOpDouble lambda, boolean skipZeros);\nprivate void applyToSorted(final IntDoubleSortedVector other, final LambdaBinOpDouble lambda, final boolean skipZeros);\npublic String toString();\npublic boolean eq(IntDoubleSortedVector other, double delta);\npublic int getNumImplicitEntries();\npublic double[] toNativeArray();\npublic int hashCode();",
      "Class_name": "IntDoubleSortedVector",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java_generated/edu/jhu/prim/vector/IntDoubleSortedVector###getWithNoZeroValues",
      "Parameter_num": "2",
      "all_Import_statements": "import edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.arrays.DoubleArrays;\n\nimport edu.jhu.prim.arrays.IntArrays;\n\nimport edu.jhu.prim.list.DoubleArrayList;\n\nimport edu.jhu.prim.list.IntArrayList;\n\nimport edu.jhu.prim.map.IntDoubleEntry;\n\nimport edu.jhu.prim.map.IntDoubleSortedMap;\n\nimport edu.jhu.prim.util.Lambda;\n\nimport edu.jhu.prim.util.Lambda.FnIntDoubleToVoid;\n\nimport edu.jhu.prim.util.Lambda.LambdaBinOpDouble;\n\nimport edu.jhu.prim.util.SafeCast;\n",
      "comment": "\n     * @return A new vector without zeros OR the same vector if it has none.\n     ",
      "packageName": "edu.jhu.prim.vector",
      "method_signature": "public static IntDoubleSortedVector getWithNoZeroValues(IntDoubleSortedVector row, double zeroThreshold);",
      "Junit_version": "4",
      "returnType": "IntDoubleSortedVector"
    },
    "Test_method": {
      "Method_body": "IntDoubleSortedVector v1 = new IntDoubleSortedVector();\n\rv1.set(1, toDouble(11));\n\rv1.set(3, toDouble(0));\n\rv1.set(2, toDouble(22));\n\rv1.set(4, toDouble(44));\n\rv1.set(5, toDouble(0));\n\rassertEquals(11, toInt(v1.get(1)));\n\rassertEquals(22, toInt(v1.get(2)));\n\rassertEquals(0, toInt(v1.get(3)));\n\rassertEquals(44, toInt(v1.get(4)));\n\rassertEquals(0, toInt(v1.get(5)));\n\rassertEquals(5, v1.getUsed());\n\rIntDoubleSortedVector v2 = IntDoubleSortedVector.getWithNoZeroValues(v1, Primitives.DEFAULT_DOUBLE_DELTA);\n\rassertEquals(3, v2.getUsed());\n\rassertEquals(11, toInt(v2.get(1)));\n\rassertEquals(22, toInt(v2.get(2)));\n\rassertEquals(44, toInt(v2.get(4)));",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "17",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toDouble;\nimport static edu.jhu.prim.Primitives.toInt;\nimport edu.jhu.prim.Primitives;\n",
      "allMethod_info": "@Test\npublic void testGetWithNoZeroValues() {\n    IntDoubleSortedVector v1 = new IntDoubleSortedVector();\n    v1.set(1, toDouble(11));\n    v1.set(3, toDouble(0));\n    v1.set(2, toDouble(22));\n    v1.set(4, toDouble(44));\n    v1.set(5, toDouble(0));\n    assertEquals(11, toInt(v1.get(1)));\n    assertEquals(22, toInt(v1.get(2)));\n    assertEquals(0, toInt(v1.get(3)));\n    assertEquals(44, toInt(v1.get(4)));\n    assertEquals(0, toInt(v1.get(5)));\n    assertEquals(5, v1.getUsed());\n    IntDoubleSortedVector v2 = IntDoubleSortedVector.getWithNoZeroValues(v1, Primitives.DEFAULT_DOUBLE_DELTA);\n    assertEquals(3, v2.getUsed());\n    assertEquals(11, toInt(v2.get(1)));\n    assertEquals(22, toInt(v2.get(2)));\n    assertEquals(44, toInt(v2.get(4)));\n}",
      "Method_name": "testGetWithNoZeroValues",
      "Class_declaration": "public class IntDoubleSortedVectorTest {\n",
      "constructors": "",
      "Class_name": "IntDoubleSortedVectorTest",
      "methodName_paraNum": "[set(2), toDouble(1), set(2), toDouble(1), set(2), toDouble(1), set(2), toDouble(1), set(2), toDouble(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), getUsed(0), getWithNoZeroValues(2), getUsed(0), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java_generated/edu/jhu/prim/vector/IntDoubleSortedVectorTest###testGetWithNoZeroValues",
      "relativePath": "mgormley_prim/src/test/java_generated/edu/jhu/prim/vector/IntDoubleSortedVectorTest.java",
      "Signature": "public void testGetWithNoZeroValues() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toDouble;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n\nimport edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.map.IntDoubleEntry;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.vector",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic boolean equals(Object obj) {\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (this.getClass() != obj.getClass())\n        return false;\n    IntFloatHashMap other = (IntFloatHashMap) obj;\n    if (this.size() != other.size()) {\n        return false;\n    }\n    for (int i = 0; i < keys.length; i++) {\n        if (states[i] == FULL) {\n            if (!other.contains(keys[i]))\n                return false;\n            if (other.get(keys[i]) != values[i])\n                return false;\n        }\n    }\n    return true;\n}",
      "all_field_declaration": "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;\n/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;\n/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;\n/**\n * Serializable version identifier\n */\nprivate static final long serialVersionUID = -3646337053166149105L;\n/**\n * Load factor for the map.\n */\nprivate static final float LOAD_FACTOR = 0.75f;\n/**\n * Default starting size.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprotected static final int DEFAULT_EXPECTED_SIZE = 16;\n/**\n * Multiplier for size growth when map fills up.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprivate static final int RESIZE_MULTIPLIER = 2;\n/**\n * Number of bits to perturb the index when probing for collision resolution.\n */\nprivate static final int PERTURB_SHIFT = 5;\n/**\n * Keys table.\n */\nprotected int[] keys;\n/**\n * Values table.\n */\nprotected float[] values;\n/**\n * States table.\n */\nprotected byte[] states;\n/**\n * Return value for missing entries.\n */\nprivate final float missingEntries;\n/**\n * Current size of the map.\n */\nprivate int size;\n/**\n * Bit mask for hash values.\n */\nprivate int mask;\n/**\n * Modifications count.\n */\nprivate transient int count;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "7",
      "Filed": "protected static final byte FULL = 1;protected int[] keys;protected float[] values;protected byte[] states;private int size;",
      "Parameter_type": "Object",
      "Import_statements": "",
      "public_method_signature": "public IntFloatHashMap();\npublic IntFloatHashMap(final int expectedSize);\npublic IntFloatHashMap(final int expectedSize, final float missingEntries);\npublic IntFloatHashMap(final IntFloatHashMap source);\npublic IntFloatHashMap(int[] keys, float[] vals);\npublic float get(final int key);\npublic float getWithDefault(int key, float missingEntries);\npublic boolean contains(final int key);\npublic Iterator<IntFloatEntry> iterator();\npublic int size();\npublic void remove(final int key);\npublic float removeAndGet(final int key);\npublic void clear();\npublic float put(final int key, final float value);\npublic float putAndGet(final int key, final float value);\npublic void add(final int key, final float value);\npublic float addAndGet(final int key, final float value);\npublic int[] getIndices();\npublic float[] getValues();\npublic Pair<int[], float[]> getIndicesAndValues();\npublic void apply(FnIntFloatToFloat lambda);\npublic void iterate(FnIntFloatToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "public_field": "",
      "Method_statement": "equals(Object obj)",
      "Method_name": "equals",
      "Class_declaration": "public class IntFloatHashMap {\n",
      "constructors": "public IntFloatHashMap() {\n    this(DEFAULT_EXPECTED_SIZE, Primitives.DEFAULT_MISSING_ENTRY_FLOAT);\n}public IntFloatHashMap(final int expectedSize) {\n    this(expectedSize, Primitives.DEFAULT_MISSING_ENTRY_FLOAT);\n}public IntFloatHashMap(final int expectedSize, final float missingEntries) {\n    final int capacity = computeCapacity(expectedSize);\n    keys = new int[capacity];\n    values = new float[capacity];\n    states = new byte[capacity];\n    this.missingEntries = missingEntries;\n    size = 0;\n    mask = capacity - 1;\n    count = 0;\n}public IntFloatHashMap(final IntFloatHashMap source) {\n    final int length = source.keys.length;\n    keys = new int[length];\n    System.arraycopy(source.keys, 0, keys, 0, length);\n    values = new float[length];\n    System.arraycopy(source.values, 0, values, 0, length);\n    states = new byte[length];\n    System.arraycopy(source.states, 0, states, 0, length);\n    missingEntries = source.missingEntries;\n    size = source.size;\n    mask = source.mask;\n    count = source.count;\n}public IntFloatHashMap(int[] keys, float[] vals) {\n    this(keys.length, Primitives.DEFAULT_MISSING_ENTRY_FLOAT);\n    if (keys.length != vals.length) {\n        throw new IllegalStateException(\"keys and vals must be of the same length\");\n    }\n    for (int i = 0; i < keys.length; i++) {\n        this.put(keys[i], vals[i]);\n    }\n}",
      "all_method_signature": "public IntFloatHashMap();\npublic IntFloatHashMap(final int expectedSize);\npublic IntFloatHashMap(final int expectedSize, final float missingEntries);\npublic IntFloatHashMap(final IntFloatHashMap source);\npublic IntFloatHashMap(int[] keys, float[] vals);\nprivate static int computeCapacity(final int expectedSize);\nprivate static int nextPowerOfTwo(final int i);\npublic float get(final int key);\npublic float getWithDefault(int key, float missingEntries);\npublic boolean contains(final int key);\npublic Iterator<IntFloatEntry> iterator();\nprivate static int perturb(final int hash);\nprivate int findInsertionIndex(final int key);\nprivate static int findInsertionIndex(final int[] keys, final byte[] states, final int key, final int mask);\nprivate static int probe(final int perturb, final int j);\nprivate static int changeIndexSign(final int index);\npublic int size();\npublic void remove(final int key);\npublic float removeAndGet(final int key);\npublic void clear();\nprivate boolean contains(final int key, final int index);\nprivate float doRemove(int index);\npublic float put(final int key, final float value);\npublic float putAndGet(final int key, final float value);\npublic void add(final int key, final float value);\npublic float addAndGet(final int key, final float value);\nprivate void growTable();\nprivate boolean shouldGrowTable();\nprivate static int hashOf(final int key);\nprivate void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException;\npublic int[] getIndices();\npublic float[] getValues();\npublic Pair<int[], float[]> getIndicesAndValues();\npublic void apply(FnIntFloatToFloat lambda);\npublic void iterate(FnIntFloatToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "Class_name": "IntFloatHashMap",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java_generated/edu/jhu/prim/map/IntFloatHashMap###equals",
      "Parameter_num": "1",
      "all_Import_statements": "import java.io.IOException;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.Serializable;\n\nimport java.util.Arrays;\n\nimport java.util.ConcurrentModificationException;\n\nimport java.util.Iterator;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.Map.Entry;\n\nimport edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.sort.IntFloatSort;\n\nimport edu.jhu.prim.tuple.Pair;\n\nimport edu.jhu.prim.util.Lambda.FnIntFloatToFloat;\n\nimport edu.jhu.prim.util.Lambda.FnIntFloatToVoid;\n\nimport edu.jhu.prim.vector.AbstractIntFloatVector;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "method_signature": "public boolean equals(Object obj);",
      "Junit_version": "4",
      "returnType": "boolean"
    },
    "Test_method": {
      "Method_body": "IntFloatHashMap m1 = new IntFloatHashMap();\n\rIntFloatHashMap m2 = new IntFloatHashMap();\n\rassertTrue(m1.equals(m2));\n\rm1.put(2, toFloat(22));\n\rm1.put(1, toFloat(11));\n\rassertFalse(m1.equals(m2));\n\rm2.put(1, toFloat(11));\n\rm2.put(2, toFloat(22));\n\rassertTrue(m1.equals(m2));\n\rm2.put(3, toFloat(33));\n\rassertFalse(m1.equals(m2));\n\rm1.put(3, toFloat(33));\n\rassertTrue(m1.equals(m2));",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "13",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toFloat;\n",
      "allMethod_info": "@Test\npublic void testEquals() throws Exception {\n    IntFloatHashMap m1 = new IntFloatHashMap();\n    IntFloatHashMap m2 = new IntFloatHashMap();\n    assertTrue(m1.equals(m2));\n    m1.put(2, toFloat(22));\n    m1.put(1, toFloat(11));\n    assertFalse(m1.equals(m2));\n    m2.put(1, toFloat(11));\n    m2.put(2, toFloat(22));\n    assertTrue(m1.equals(m2));\n    m2.put(3, toFloat(33));\n    assertFalse(m1.equals(m2));\n    m1.put(3, toFloat(33));\n    assertTrue(m1.equals(m2));\n}",
      "Method_name": "testEquals",
      "Class_declaration": "public class IntFloatHashMapTest {\n",
      "constructors": "",
      "Class_name": "IntFloatHashMapTest",
      "methodName_paraNum": "[equals(1), put(2), toFloat(1), put(2), toFloat(1), equals(1), put(2), toFloat(1), put(2), toFloat(1), equals(1), put(2), toFloat(1), equals(1), put(2), toFloat(1), equals(1)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntFloatHashMapTest###testEquals",
      "relativePath": "mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntFloatHashMapTest.java",
      "Signature": "public void testEquals() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toFloat;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n\nimport edu.jhu.prim.Primitives;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic int hashCode() {\n    int h = 0;\n    int[] indices = getIndices();\n    float[] values = getValues();\n    IntFloatSort.sortIndexAsc(indices, values);\n    for (int i = 0; i < indices.length; i++) {\n        int result = 17;\n        result = 37 * result + Primitives.hashOfInt(indices[i]);\n        result = 37 * result + Primitives.hashOfFloat(values[i]);\n        h += result;\n    }\n    return h;\n}",
      "all_field_declaration": "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;\n/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;\n/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;\n/**\n * Serializable version identifier\n */\nprivate static final long serialVersionUID = -3646337053166149105L;\n/**\n * Load factor for the map.\n */\nprivate static final float LOAD_FACTOR = 0.75f;\n/**\n * Default starting size.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprotected static final int DEFAULT_EXPECTED_SIZE = 16;\n/**\n * Multiplier for size growth when map fills up.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprivate static final int RESIZE_MULTIPLIER = 2;\n/**\n * Number of bits to perturb the index when probing for collision resolution.\n */\nprivate static final int PERTURB_SHIFT = 5;\n/**\n * Keys table.\n */\nprotected int[] keys;\n/**\n * Values table.\n */\nprotected float[] values;\n/**\n * States table.\n */\nprotected byte[] states;\n/**\n * Return value for missing entries.\n */\nprivate final float missingEntries;\n/**\n * Current size of the map.\n */\nprivate int size;\n/**\n * Bit mask for hash values.\n */\nprivate int mask;\n/**\n * Modifications count.\n */\nprivate transient int count;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "6",
      "Filed": "protected float[] values;",
      "Parameter_type": "",
      "Import_statements": "import edu.jhu.prim.Primitives;\nimport edu.jhu.prim.sort.IntFloatSort;\n",
      "public_method_signature": "public IntFloatHashMap();\npublic IntFloatHashMap(final int expectedSize);\npublic IntFloatHashMap(final int expectedSize, final float missingEntries);\npublic IntFloatHashMap(final IntFloatHashMap source);\npublic IntFloatHashMap(int[] keys, float[] vals);\npublic float get(final int key);\npublic float getWithDefault(int key, float missingEntries);\npublic boolean contains(final int key);\npublic Iterator<IntFloatEntry> iterator();\npublic int size();\npublic void remove(final int key);\npublic float removeAndGet(final int key);\npublic void clear();\npublic float put(final int key, final float value);\npublic float putAndGet(final int key, final float value);\npublic void add(final int key, final float value);\npublic float addAndGet(final int key, final float value);\npublic int[] getIndices();\npublic float[] getValues();\npublic Pair<int[], float[]> getIndicesAndValues();\npublic void apply(FnIntFloatToFloat lambda);\npublic void iterate(FnIntFloatToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "public_field": "",
      "Method_statement": "hashCode()",
      "Method_name": "hashCode",
      "Class_declaration": "public class IntFloatHashMap {\n",
      "constructors": "public IntFloatHashMap() {\n    this(DEFAULT_EXPECTED_SIZE, Primitives.DEFAULT_MISSING_ENTRY_FLOAT);\n}public IntFloatHashMap(final int expectedSize) {\n    this(expectedSize, Primitives.DEFAULT_MISSING_ENTRY_FLOAT);\n}public IntFloatHashMap(final int expectedSize, final float missingEntries) {\n    final int capacity = computeCapacity(expectedSize);\n    keys = new int[capacity];\n    values = new float[capacity];\n    states = new byte[capacity];\n    this.missingEntries = missingEntries;\n    size = 0;\n    mask = capacity - 1;\n    count = 0;\n}public IntFloatHashMap(final IntFloatHashMap source) {\n    final int length = source.keys.length;\n    keys = new int[length];\n    System.arraycopy(source.keys, 0, keys, 0, length);\n    values = new float[length];\n    System.arraycopy(source.values, 0, values, 0, length);\n    states = new byte[length];\n    System.arraycopy(source.states, 0, states, 0, length);\n    missingEntries = source.missingEntries;\n    size = source.size;\n    mask = source.mask;\n    count = source.count;\n}public IntFloatHashMap(int[] keys, float[] vals) {\n    this(keys.length, Primitives.DEFAULT_MISSING_ENTRY_FLOAT);\n    if (keys.length != vals.length) {\n        throw new IllegalStateException(\"keys and vals must be of the same length\");\n    }\n    for (int i = 0; i < keys.length; i++) {\n        this.put(keys[i], vals[i]);\n    }\n}",
      "all_method_signature": "public IntFloatHashMap();\npublic IntFloatHashMap(final int expectedSize);\npublic IntFloatHashMap(final int expectedSize, final float missingEntries);\npublic IntFloatHashMap(final IntFloatHashMap source);\npublic IntFloatHashMap(int[] keys, float[] vals);\nprivate static int computeCapacity(final int expectedSize);\nprivate static int nextPowerOfTwo(final int i);\npublic float get(final int key);\npublic float getWithDefault(int key, float missingEntries);\npublic boolean contains(final int key);\npublic Iterator<IntFloatEntry> iterator();\nprivate static int perturb(final int hash);\nprivate int findInsertionIndex(final int key);\nprivate static int findInsertionIndex(final int[] keys, final byte[] states, final int key, final int mask);\nprivate static int probe(final int perturb, final int j);\nprivate static int changeIndexSign(final int index);\npublic int size();\npublic void remove(final int key);\npublic float removeAndGet(final int key);\npublic void clear();\nprivate boolean contains(final int key, final int index);\nprivate float doRemove(int index);\npublic float put(final int key, final float value);\npublic float putAndGet(final int key, final float value);\npublic void add(final int key, final float value);\npublic float addAndGet(final int key, final float value);\nprivate void growTable();\nprivate boolean shouldGrowTable();\nprivate static int hashOf(final int key);\nprivate void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException;\npublic int[] getIndices();\npublic float[] getValues();\npublic Pair<int[], float[]> getIndicesAndValues();\npublic void apply(FnIntFloatToFloat lambda);\npublic void iterate(FnIntFloatToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "Class_name": "IntFloatHashMap",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java_generated/edu/jhu/prim/map/IntFloatHashMap###hashCode",
      "Parameter_num": "0",
      "all_Import_statements": "import java.io.IOException;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.Serializable;\n\nimport java.util.Arrays;\n\nimport java.util.ConcurrentModificationException;\n\nimport java.util.Iterator;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.Map.Entry;\n\nimport edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.sort.IntFloatSort;\n\nimport edu.jhu.prim.tuple.Pair;\n\nimport edu.jhu.prim.util.Lambda.FnIntFloatToFloat;\n\nimport edu.jhu.prim.util.Lambda.FnIntFloatToVoid;\n\nimport edu.jhu.prim.vector.AbstractIntFloatVector;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "method_signature": "public int hashCode();",
      "Junit_version": "4",
      "returnType": "int"
    },
    "Test_method": {
      "Method_body": "IntFloatHashMap m1 = new IntFloatHashMap();\n\rIntFloatHashMap m2 = new IntFloatHashMap();\n\rassertEquals(m1.hashCode(), m2.hashCode());\n\rm1.put(2, toFloat(22));\n\rm1.put(1, toFloat(11));\n\rm2.put(1, toFloat(11));\n\rm2.put(2, toFloat(22));\n\rassertEquals(m1.hashCode(), m2.hashCode());\n\rm2.put(3, toFloat(33));\n\rm1.put(3, toFloat(33));\n\rassertEquals(m1.hashCode(), m2.hashCode());",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "11",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toFloat;\n",
      "allMethod_info": "@Test\npublic void testHashCode() throws Exception {\n    IntFloatHashMap m1 = new IntFloatHashMap();\n    IntFloatHashMap m2 = new IntFloatHashMap();\n    assertEquals(m1.hashCode(), m2.hashCode());\n    m1.put(2, toFloat(22));\n    m1.put(1, toFloat(11));\n    m2.put(1, toFloat(11));\n    m2.put(2, toFloat(22));\n    assertEquals(m1.hashCode(), m2.hashCode());\n    m2.put(3, toFloat(33));\n    m1.put(3, toFloat(33));\n    assertEquals(m1.hashCode(), m2.hashCode());\n}",
      "Method_name": "testHashCode",
      "Class_declaration": "public class IntFloatHashMapTest {\n",
      "constructors": "",
      "Class_name": "IntFloatHashMapTest",
      "methodName_paraNum": "[hashCode(0), hashCode(0), put(2), toFloat(1), put(2), toFloat(1), put(2), toFloat(1), put(2), toFloat(1), hashCode(0), hashCode(0), put(2), toFloat(1), put(2), toFloat(1), hashCode(0), hashCode(0)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntFloatHashMapTest###testHashCode",
      "relativePath": "mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntFloatHashMapTest.java",
      "Signature": "public void testHashCode() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toFloat;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n\nimport edu.jhu.prim.Primitives;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic void remove(int idx) {\n    int i = Arrays.binarySearch(indices, 0, used, idx);\n    if (i < 0) {\n        throw new IllegalArgumentException(\"This map does not contain the key: \" + idx);\n    }\n    System.arraycopy(indices, i + 1, indices, i, used - i - 1);\n    System.arraycopy(values, i + 1, values, i, used - i - 1);\n    used--;\n}",
      "all_field_declaration": "private static final long serialVersionUID = 1L;\nprotected int[] indices;\nprotected float[] values;\n// TODO: size\nprotected int used;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "5",
      "Filed": "protected int[] indices;protected float[] values;protected int used;",
      "Parameter_type": "int",
      "Import_statements": "import java.util.Arrays;\n",
      "public_method_signature": "public IntFloatSortedMap();\npublic IntFloatSortedMap(int initialSize);\npublic IntFloatSortedMap(int[] index, float[] data);\npublic IntFloatSortedMap(IntFloatSortedMap other);\npublic IntFloatSortedMap(IntFloatHashMap other);\npublic void clear();\npublic boolean contains(int idx);\npublic float get(int idx);\npublic float getWithDefault(int idx, float defaultVal);\npublic void remove(int idx);\npublic float put(int idx, float val);\npublic void add(int idx, float val);\npublic void apply(FnIntFloatToFloat lambda);\npublic void iterate(FnIntFloatToVoid lambda);\npublic Iterator<IntFloatEntry> iterator();\npublic int size();\npublic int getUsed();\npublic int[] getIndices();\npublic float[] getValues();\npublic int[] getInternalIndices();\npublic float[] getInternalValues();",
      "public_field": "",
      "Method_statement": "remove(int idx)",
      "Method_name": "remove",
      "Class_declaration": "public class IntFloatSortedMap {\n",
      "constructors": "public IntFloatSortedMap() {\n    this(0);\n}public IntFloatSortedMap(int initialSize) {\n    this.used = 0;\n    this.indices = new int[initialSize];\n    this.values = new float[initialSize];\n}public IntFloatSortedMap(int[] index, float[] data) {\n    if (!IntSort.isSortedAscAndUnique(index)) {\n        throw new IllegalStateException(\"Indices are not sorted ascending\");\n    }\n    this.used = index.length;\n    this.indices = index;\n    this.values = data;\n}public IntFloatSortedMap(IntFloatSortedMap other) {\n    this.used = other.used;\n    this.indices = IntArrays.copyOf(other.indices);\n    this.values = FloatArrays.copyOf(other.values);\n}public IntFloatSortedMap(IntFloatHashMap other) {\n    Pair<int[], float[]> pair = other.getIndicesAndValues();\n    IntFloatSort.sortIndexAsc(pair.get1(), pair.get2());\n    this.used = other.size();\n    this.indices = pair.get1();\n    this.values = pair.get2();\n}",
      "all_method_signature": "public IntFloatSortedMap();\npublic IntFloatSortedMap(int initialSize);\npublic IntFloatSortedMap(int[] index, float[] data);\npublic IntFloatSortedMap(IntFloatSortedMap other);\npublic IntFloatSortedMap(IntFloatHashMap other);\npublic void clear();\npublic boolean contains(int idx);\npublic float get(int idx);\npublic float getWithDefault(int idx, float defaultVal);\npublic void remove(int idx);\npublic float put(int idx, float val);\npublic void add(int idx, float val);\npublic void apply(FnIntFloatToFloat lambda);\npublic void iterate(FnIntFloatToVoid lambda);\nprivate final int[] insert(int[] array, int i, int val);\nprivate final float[] insert(float[] array, int i, float val);\npublic Iterator<IntFloatEntry> iterator();\npublic int size();\npublic int getUsed();\npublic int[] getIndices();\npublic float[] getValues();\npublic int[] getInternalIndices();\npublic float[] getInternalValues();",
      "Class_name": "IntFloatSortedMap",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java_generated/edu/jhu/prim/map/IntFloatSortedMap###remove",
      "Parameter_num": "1",
      "all_Import_statements": "import java.util.Arrays;\n\nimport java.util.Iterator;\n\nimport edu.jhu.prim.arrays.FloatArrays;\n\nimport edu.jhu.prim.arrays.IntArrays;\n\nimport edu.jhu.prim.list.FloatArrayList;\n\nimport edu.jhu.prim.list.IntArrayList;\n\nimport edu.jhu.prim.sort.IntFloatSort;\n\nimport edu.jhu.prim.sort.IntSort;\n\nimport edu.jhu.prim.tuple.Pair;\n\nimport edu.jhu.prim.util.Lambda.FnIntFloatToFloat;\n\nimport edu.jhu.prim.util.Lambda.FnIntFloatToVoid;\n\nimport edu.jhu.prim.vector.AbstractIntFloatVector;\n",
      "comment": " (non-Javadoc)\n     * @see edu.jhu.util.vector.IntFloatMap#remove(int)\n     ",
      "packageName": "edu.jhu.prim.map",
      "method_signature": "public void remove(int idx);",
      "Junit_version": "4",
      "returnType": "void"
    },
    "Test_method": {
      "Method_body": "// First element.\nIntFloatMap map = new IntFloatSortedMap();\n\rmap.put(2, toFloat(22));\n\rmap.put(1, toFloat(11));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(11, toInt(map.get(1)));\n\rmap.remove(1);\n\rassertEquals(false, map.contains(1));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(1, map.size());\n\r// Middle element.\nmap = new IntFloatSortedMap();\n\rmap.put(2, toFloat(22));\n\rmap.put(3, toFloat(33));\n\rmap.put(1, toFloat(11));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(33, toInt(map.get(3)));\n\rmap.remove(2);\n\rassertEquals(false, map.contains(2));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(33, toInt(map.get(3)));\n\rassertEquals(2, map.size());\n\r// Last element.\nmap = new IntFloatSortedMap();\n\rmap.put(2, toFloat(22));\n\rmap.put(3, toFloat(33));\n\rmap.put(1, toFloat(11));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(33, toInt(map.get(3)));\n\rmap.remove(3);\n\rassertEquals(false, map.contains(3));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(2, map.size());",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "33",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toFloat;\nimport static edu.jhu.prim.Primitives.toInt;\nimport static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "@Test\npublic void testRemove() {\n    // First element.\n    IntFloatMap map = new IntFloatSortedMap();\n    map.put(2, toFloat(22));\n    map.put(1, toFloat(11));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(11, toInt(map.get(1)));\n    map.remove(1);\n    assertEquals(false, map.contains(1));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(1, map.size());\n    // Middle element.\n    map = new IntFloatSortedMap();\n    map.put(2, toFloat(22));\n    map.put(3, toFloat(33));\n    map.put(1, toFloat(11));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(33, toInt(map.get(3)));\n    map.remove(2);\n    assertEquals(false, map.contains(2));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(33, toInt(map.get(3)));\n    assertEquals(2, map.size());\n    // Last element.\n    map = new IntFloatSortedMap();\n    map.put(2, toFloat(22));\n    map.put(3, toFloat(33));\n    map.put(1, toFloat(11));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(33, toInt(map.get(3)));\n    map.remove(3);\n    assertEquals(false, map.contains(3));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(2, map.size());\n}",
      "Method_name": "testRemove",
      "Class_declaration": "public class IntFloatSortedMapTest {\n",
      "constructors": "",
      "Class_name": "IntFloatSortedMapTest",
      "methodName_paraNum": "[put(2), toFloat(1), put(2), toFloat(1), toInt(1), get(1), toInt(1), get(1), remove(1), contains(1), toInt(1), get(1), size(0), put(2), toFloat(1), put(2), toFloat(1), put(2), toFloat(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), remove(1), contains(1), toInt(1), get(1), toInt(1), get(1), size(0), put(2), toFloat(1), put(2), toFloat(1), put(2), toFloat(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), remove(1), contains(1), toInt(1), get(1), toInt(1), get(1), size(0)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntFloatSortedMapTest###testRemove",
      "relativePath": "mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntFloatSortedMapTest.java",
      "Signature": "public void testRemove() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toFloat;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static IntFloatSortedVector getWithNoZeroValues(IntFloatSortedVector row, float zeroThreshold) {\n    int[] origIndex = row.getIndices();\n    float[] origData = row.getValues();\n    int numNonZeros = 0;\n    boolean[] isNonZero = new boolean[row.getUsed()];\n    for (int i = 0; i < row.getUsed(); i++) {\n        if (!Primitives.isZero(origData[i], zeroThreshold)) {\n            isNonZero[i] = true;\n            numNonZeros++;\n        } else {\n            isNonZero[i] = false;\n        }\n    }\n    int numZeros = row.getUsed() - numNonZeros;\n    if (numZeros > 0) {\n        int[] newIndex = new int[numNonZeros];\n        float[] newData = new float[numNonZeros];\n        int newIdx = 0;\n        for (int i = 0; i < row.getUsed(); i++) {\n            if (isNonZero[i]) {\n                newIndex[newIdx] = origIndex[i];\n                newData[newIdx] = origData[i];\n                newIdx++;\n            }\n        }\n        return new IntFloatSortedVector(newIndex, newData);\n    } else {\n        return row;\n    }\n}",
      "all_field_declaration": "private static final long serialVersionUID = 1L;\nprivate static final float ZERO = (float) 0;\nboolean norm2Cached = false;\nfloat norm2Value;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "7",
      "Filed": "",
      "Parameter_type": "IntFloatSortedVector,float",
      "Import_statements": "import edu.jhu.prim.Primitives;\n",
      "public_method_signature": "public IntFloatSortedVector();\npublic IntFloatSortedVector(int initialSize);\npublic IntFloatSortedVector(int[] index, float[] data);\npublic IntFloatSortedVector(float[] denseRow);\npublic IntFloatSortedVector(IntFloatSortedVector vector);\npublic IntFloatSortedVector(IntFloatHashVector vector);\npublic IntFloatSortedVector(IntFloatDenseVector vector);\npublic IntFloatSortedVector(IntFloatVector other);\npublic IntFloatVector copy();\npublic void add(int idx, float val);\npublic float set(int idx, float val);\npublic float get(int idx);\npublic void scale(float multiplier);\npublic float dot(float[] other);\npublic float dot(float[][] matrix, int col);\npublic float dot(IntFloatVector y);\npublic static IntFloatSortedVector getWithNoZeroValues(IntFloatSortedVector row, float zeroThreshold);\npublic IntFloatSortedVector zero();\npublic void set(IntFloatSortedVector other);\npublic void add(IntFloatVector other);\npublic void subtract(IntFloatVector other);\npublic void product(IntFloatVector other);\npublic IntFloatSortedVector getSum(IntFloatVector other);\npublic IntFloatSortedVector getDiff(IntFloatVector other);\npublic IntFloatSortedVector getProd(IntFloatVector other);\npublic void apply(IntFloatVector other, LambdaBinOpFloat lambda, boolean skipZeros);\npublic String toString();\npublic boolean eq(IntFloatSortedVector other, float delta);\npublic int getNumImplicitEntries();\npublic float[] toNativeArray();\npublic int hashCode();",
      "public_field": "",
      "Method_statement": "getWithNoZeroValues(IntFloatSortedVector row, float zeroThreshold)",
      "Method_name": "getWithNoZeroValues",
      "Class_declaration": "public class IntFloatSortedVector {\n",
      "constructors": "public IntFloatSortedVector() {\n    super();\n}public IntFloatSortedVector(int initialSize) {\n    super(initialSize);\n}public IntFloatSortedVector(int[] index, float[] data) {\n    super(index, data);\n}public IntFloatSortedVector(float[] denseRow) {\n    this(IntArrays.range(denseRow.length), denseRow);\n}public IntFloatSortedVector(IntFloatSortedVector vector) {\n    super(vector);\n}public IntFloatSortedVector(IntFloatHashVector vector) {\n    super(vector);\n}public IntFloatSortedVector(IntFloatDenseVector vector) {\n    this(vector.toNativeArray());\n}public IntFloatSortedVector(IntFloatVector other) {\n    this();\n    final IntFloatSortedVector thisVec = this;\n    other.iterate(new FnIntFloatToVoid() {\n\n        @Override\n        public void call(int idx, float val) {\n            thisVec.set(idx, val);\n        }\n    });\n}",
      "all_method_signature": "public IntFloatSortedVector();\npublic IntFloatSortedVector(int initialSize);\npublic IntFloatSortedVector(int[] index, float[] data);\npublic IntFloatSortedVector(float[] denseRow);\npublic IntFloatSortedVector(IntFloatSortedVector vector);\npublic IntFloatSortedVector(IntFloatHashVector vector);\npublic IntFloatSortedVector(IntFloatDenseVector vector);\npublic IntFloatSortedVector(IntFloatVector other);\npublic IntFloatVector copy();\npublic void add(int idx, float val);\npublic float set(int idx, float val);\npublic float get(int idx);\npublic void scale(float multiplier);\npublic float dot(float[] other);\npublic float dot(float[][] matrix, int col);\npublic float dot(IntFloatVector y);\npublic static IntFloatSortedVector getWithNoZeroValues(IntFloatSortedVector row, float zeroThreshold);\npublic IntFloatSortedVector zero();\npublic void set(IntFloatSortedVector other);\npublic void add(IntFloatVector other);\npublic void subtract(IntFloatVector other);\npublic void product(IntFloatVector other);\npublic IntFloatSortedVector getSum(IntFloatVector other);\npublic IntFloatSortedVector getDiff(IntFloatVector other);\npublic IntFloatSortedVector getProd(IntFloatVector other);\npublic void apply(IntFloatVector other, LambdaBinOpFloat lambda, boolean skipZeros);\nprivate void applyToSorted(final IntFloatSortedVector other, final LambdaBinOpFloat lambda, final boolean skipZeros);\npublic String toString();\npublic boolean eq(IntFloatSortedVector other, float delta);\npublic int getNumImplicitEntries();\npublic float[] toNativeArray();\npublic int hashCode();",
      "Class_name": "IntFloatSortedVector",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java_generated/edu/jhu/prim/vector/IntFloatSortedVector###getWithNoZeroValues",
      "Parameter_num": "2",
      "all_Import_statements": "import edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.arrays.FloatArrays;\n\nimport edu.jhu.prim.arrays.IntArrays;\n\nimport edu.jhu.prim.list.FloatArrayList;\n\nimport edu.jhu.prim.list.IntArrayList;\n\nimport edu.jhu.prim.map.IntFloatEntry;\n\nimport edu.jhu.prim.map.IntFloatSortedMap;\n\nimport edu.jhu.prim.util.Lambda;\n\nimport edu.jhu.prim.util.Lambda.FnIntFloatToVoid;\n\nimport edu.jhu.prim.util.Lambda.LambdaBinOpFloat;\n\nimport edu.jhu.prim.util.SafeCast;\n",
      "comment": "\n     * @return A new vector without zeros OR the same vector if it has none.\n     ",
      "packageName": "edu.jhu.prim.vector",
      "method_signature": "public static IntFloatSortedVector getWithNoZeroValues(IntFloatSortedVector row, float zeroThreshold);",
      "Junit_version": "4",
      "returnType": "IntFloatSortedVector"
    },
    "Test_method": {
      "Method_body": "IntFloatSortedVector v1 = new IntFloatSortedVector();\n\rv1.set(1, toFloat(11));\n\rv1.set(3, toFloat(0));\n\rv1.set(2, toFloat(22));\n\rv1.set(4, toFloat(44));\n\rv1.set(5, toFloat(0));\n\rassertEquals(11, toInt(v1.get(1)));\n\rassertEquals(22, toInt(v1.get(2)));\n\rassertEquals(0, toInt(v1.get(3)));\n\rassertEquals(44, toInt(v1.get(4)));\n\rassertEquals(0, toInt(v1.get(5)));\n\rassertEquals(5, v1.getUsed());\n\rIntFloatSortedVector v2 = IntFloatSortedVector.getWithNoZeroValues(v1, Primitives.DEFAULT_FLOAT_DELTA);\n\rassertEquals(3, v2.getUsed());\n\rassertEquals(11, toInt(v2.get(1)));\n\rassertEquals(22, toInt(v2.get(2)));\n\rassertEquals(44, toInt(v2.get(4)));",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "17",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toFloat;\nimport static edu.jhu.prim.Primitives.toInt;\nimport edu.jhu.prim.Primitives;\n",
      "allMethod_info": "@Test\npublic void testGetWithNoZeroValues() {\n    IntFloatSortedVector v1 = new IntFloatSortedVector();\n    v1.set(1, toFloat(11));\n    v1.set(3, toFloat(0));\n    v1.set(2, toFloat(22));\n    v1.set(4, toFloat(44));\n    v1.set(5, toFloat(0));\n    assertEquals(11, toInt(v1.get(1)));\n    assertEquals(22, toInt(v1.get(2)));\n    assertEquals(0, toInt(v1.get(3)));\n    assertEquals(44, toInt(v1.get(4)));\n    assertEquals(0, toInt(v1.get(5)));\n    assertEquals(5, v1.getUsed());\n    IntFloatSortedVector v2 = IntFloatSortedVector.getWithNoZeroValues(v1, Primitives.DEFAULT_FLOAT_DELTA);\n    assertEquals(3, v2.getUsed());\n    assertEquals(11, toInt(v2.get(1)));\n    assertEquals(22, toInt(v2.get(2)));\n    assertEquals(44, toInt(v2.get(4)));\n}",
      "Method_name": "testGetWithNoZeroValues",
      "Class_declaration": "public class IntFloatSortedVectorTest {\n",
      "constructors": "",
      "Class_name": "IntFloatSortedVectorTest",
      "methodName_paraNum": "[set(2), toFloat(1), set(2), toFloat(1), set(2), toFloat(1), set(2), toFloat(1), set(2), toFloat(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), getUsed(0), getWithNoZeroValues(2), getUsed(0), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java_generated/edu/jhu/prim/vector/IntFloatSortedVectorTest###testGetWithNoZeroValues",
      "relativePath": "mgormley_prim/src/test/java_generated/edu/jhu/prim/vector/IntFloatSortedVectorTest.java",
      "Signature": "public void testGetWithNoZeroValues() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toFloat;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n\nimport edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.map.IntFloatEntry;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.vector",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic boolean equals(Object obj) {\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (this.getClass() != obj.getClass())\n        return false;\n    IntIntHashMap other = (IntIntHashMap) obj;\n    if (this.size() != other.size()) {\n        return false;\n    }\n    for (int i = 0; i < keys.length; i++) {\n        if (states[i] == FULL) {\n            if (!other.contains(keys[i]))\n                return false;\n            if (other.get(keys[i]) != values[i])\n                return false;\n        }\n    }\n    return true;\n}",
      "all_field_declaration": "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;\n/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;\n/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;\n/**\n * Serializable version identifier\n */\nprivate static final long serialVersionUID = -3646337053166149105L;\n/**\n * Load factor for the map.\n */\nprivate static final float LOAD_FACTOR = 0.75f;\n/**\n * Default starting size.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprotected static final int DEFAULT_EXPECTED_SIZE = 16;\n/**\n * Multiplier for size growth when map fills up.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprivate static final int RESIZE_MULTIPLIER = 2;\n/**\n * Number of bits to perturb the index when probing for collision resolution.\n */\nprivate static final int PERTURB_SHIFT = 5;\n/**\n * Keys table.\n */\nprotected int[] keys;\n/**\n * Values table.\n */\nprotected int[] values;\n/**\n * States table.\n */\nprotected byte[] states;\n/**\n * Return value for missing entries.\n */\nprivate final int missingEntries;\n/**\n * Current size of the map.\n */\nprivate int size;\n/**\n * Bit mask for hash values.\n */\nprivate int mask;\n/**\n * Modifications count.\n */\nprivate transient int count;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "7",
      "Filed": "protected static final byte FULL = 1;protected int[] keys;protected int[] values;protected byte[] states;private int size;",
      "Parameter_type": "Object",
      "Import_statements": "",
      "public_method_signature": "public IntIntHashMap();\npublic IntIntHashMap(final int expectedSize, final int missingEntries);\npublic IntIntHashMap(final IntIntHashMap source);\npublic IntIntHashMap(int[] keys, int[] vals);\npublic int get(final int key);\npublic int getWithDefault(int key, int missingEntries);\npublic boolean contains(final int key);\npublic Iterator<IntIntEntry> iterator();\npublic int size();\npublic void remove(final int key);\npublic int removeAndGet(final int key);\npublic void clear();\npublic int put(final int key, final int value);\npublic int putAndGet(final int key, final int value);\npublic void add(final int key, final int value);\npublic int addAndGet(final int key, final int value);\npublic int[] getIndices();\npublic int[] getValues();\npublic Pair<int[], int[]> getIndicesAndValues();\npublic void apply(FnIntIntToInt lambda);\npublic void iterate(FnIntIntToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "public_field": "",
      "Method_statement": "equals(Object obj)",
      "Method_name": "equals",
      "Class_declaration": "public class IntIntHashMap {\n",
      "constructors": "public IntIntHashMap() {\n    this(DEFAULT_EXPECTED_SIZE, Primitives.DEFAULT_MISSING_ENTRY_INT);\n}public IntIntHashMap(final int expectedSize, final int missingEntries) {\n    final int capacity = computeCapacity(expectedSize);\n    keys = new int[capacity];\n    values = new int[capacity];\n    states = new byte[capacity];\n    this.missingEntries = missingEntries;\n    size = 0;\n    mask = capacity - 1;\n    count = 0;\n}public IntIntHashMap(final IntIntHashMap source) {\n    final int length = source.keys.length;\n    keys = new int[length];\n    System.arraycopy(source.keys, 0, keys, 0, length);\n    values = new int[length];\n    System.arraycopy(source.values, 0, values, 0, length);\n    states = new byte[length];\n    System.arraycopy(source.states, 0, states, 0, length);\n    missingEntries = source.missingEntries;\n    size = source.size;\n    mask = source.mask;\n    count = source.count;\n}public IntIntHashMap(int[] keys, int[] vals) {\n    this(keys.length, Primitives.DEFAULT_MISSING_ENTRY_INT);\n    if (keys.length != vals.length) {\n        throw new IllegalStateException(\"keys and vals must be of the same length\");\n    }\n    for (int i = 0; i < keys.length; i++) {\n        this.put(keys[i], vals[i]);\n    }\n}",
      "all_method_signature": "public IntIntHashMap();\npublic IntIntHashMap(final int expectedSize, final int missingEntries);\npublic IntIntHashMap(final IntIntHashMap source);\npublic IntIntHashMap(int[] keys, int[] vals);\nprivate static int computeCapacity(final int expectedSize);\nprivate static int nextPowerOfTwo(final int i);\npublic int get(final int key);\npublic int getWithDefault(int key, int missingEntries);\npublic boolean contains(final int key);\npublic Iterator<IntIntEntry> iterator();\nprivate static int perturb(final int hash);\nprivate int findInsertionIndex(final int key);\nprivate static int findInsertionIndex(final int[] keys, final byte[] states, final int key, final int mask);\nprivate static int probe(final int perturb, final int j);\nprivate static int changeIndexSign(final int index);\npublic int size();\npublic void remove(final int key);\npublic int removeAndGet(final int key);\npublic void clear();\nprivate boolean contains(final int key, final int index);\nprivate int doRemove(int index);\npublic int put(final int key, final int value);\npublic int putAndGet(final int key, final int value);\npublic void add(final int key, final int value);\npublic int addAndGet(final int key, final int value);\nprivate void growTable();\nprivate boolean shouldGrowTable();\nprivate static int hashOf(final int key);\nprivate void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException;\npublic int[] getIndices();\npublic int[] getValues();\npublic Pair<int[], int[]> getIndicesAndValues();\npublic void apply(FnIntIntToInt lambda);\npublic void iterate(FnIntIntToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "Class_name": "IntIntHashMap",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java_generated/edu/jhu/prim/map/IntIntHashMap###equals",
      "Parameter_num": "1",
      "all_Import_statements": "import java.io.IOException;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.Serializable;\n\nimport java.util.Arrays;\n\nimport java.util.ConcurrentModificationException;\n\nimport java.util.Iterator;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.Map.Entry;\n\nimport edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.sort.IntIntSort;\n\nimport edu.jhu.prim.tuple.Pair;\n\nimport edu.jhu.prim.util.Lambda.FnIntIntToInt;\n\nimport edu.jhu.prim.util.Lambda.FnIntIntToVoid;\n\nimport edu.jhu.prim.vector.AbstractIntIntVector;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "method_signature": "public boolean equals(Object obj);",
      "Junit_version": "4",
      "returnType": "boolean"
    },
    "Test_method": {
      "Method_body": "IntIntHashMap m1 = new IntIntHashMap();\n\rIntIntHashMap m2 = new IntIntHashMap();\n\rassertTrue(m1.equals(m2));\n\rm1.put(2, toInt(22));\n\rm1.put(1, toInt(11));\n\rassertFalse(m1.equals(m2));\n\rm2.put(1, toInt(11));\n\rm2.put(2, toInt(22));\n\rassertTrue(m1.equals(m2));\n\rm2.put(3, toInt(33));\n\rassertFalse(m1.equals(m2));\n\rm1.put(3, toInt(33));\n\rassertTrue(m1.equals(m2));",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "13",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toInt;\nimport static edu.jhu.prim.Primitives.toInt;\nimport static edu.jhu.prim.Primitives.toInt;\n",
      "allMethod_info": "@Test\npublic void testEquals() throws Exception {\n    IntIntHashMap m1 = new IntIntHashMap();\n    IntIntHashMap m2 = new IntIntHashMap();\n    assertTrue(m1.equals(m2));\n    m1.put(2, toInt(22));\n    m1.put(1, toInt(11));\n    assertFalse(m1.equals(m2));\n    m2.put(1, toInt(11));\n    m2.put(2, toInt(22));\n    assertTrue(m1.equals(m2));\n    m2.put(3, toInt(33));\n    assertFalse(m1.equals(m2));\n    m1.put(3, toInt(33));\n    assertTrue(m1.equals(m2));\n}",
      "Method_name": "testEquals",
      "Class_declaration": "public class IntIntHashMapTest {\n",
      "constructors": "",
      "Class_name": "IntIntHashMapTest",
      "methodName_paraNum": "[equals(1), put(2), toInt(1), put(2), toInt(1), equals(1), put(2), toInt(1), put(2), toInt(1), equals(1), put(2), toInt(1), equals(1), put(2), toInt(1), equals(1)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntIntHashMapTest###testEquals",
      "relativePath": "mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntIntHashMapTest.java",
      "Signature": "public void testEquals() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toInt;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n\nimport edu.jhu.prim.Primitives;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic int hashCode() {\n    int h = 0;\n    int[] indices = getIndices();\n    int[] values = getValues();\n    IntIntSort.sortIndexAsc(indices, values);\n    for (int i = 0; i < indices.length; i++) {\n        int result = 17;\n        result = 37 * result + Primitives.hashOfInt(indices[i]);\n        result = 37 * result + Primitives.hashOfInt(values[i]);\n        h += result;\n    }\n    return h;\n}",
      "all_field_declaration": "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;\n/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;\n/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;\n/**\n * Serializable version identifier\n */\nprivate static final long serialVersionUID = -3646337053166149105L;\n/**\n * Load factor for the map.\n */\nprivate static final float LOAD_FACTOR = 0.75f;\n/**\n * Default starting size.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprotected static final int DEFAULT_EXPECTED_SIZE = 16;\n/**\n * Multiplier for size growth when map fills up.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprivate static final int RESIZE_MULTIPLIER = 2;\n/**\n * Number of bits to perturb the index when probing for collision resolution.\n */\nprivate static final int PERTURB_SHIFT = 5;\n/**\n * Keys table.\n */\nprotected int[] keys;\n/**\n * Values table.\n */\nprotected int[] values;\n/**\n * States table.\n */\nprotected byte[] states;\n/**\n * Return value for missing entries.\n */\nprivate final int missingEntries;\n/**\n * Current size of the map.\n */\nprivate int size;\n/**\n * Bit mask for hash values.\n */\nprivate int mask;\n/**\n * Modifications count.\n */\nprivate transient int count;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "6",
      "Filed": "protected int[] values;",
      "Parameter_type": "",
      "Import_statements": "import edu.jhu.prim.Primitives;\nimport edu.jhu.prim.sort.IntIntSort;\n",
      "public_method_signature": "public IntIntHashMap();\npublic IntIntHashMap(final int expectedSize, final int missingEntries);\npublic IntIntHashMap(final IntIntHashMap source);\npublic IntIntHashMap(int[] keys, int[] vals);\npublic int get(final int key);\npublic int getWithDefault(int key, int missingEntries);\npublic boolean contains(final int key);\npublic Iterator<IntIntEntry> iterator();\npublic int size();\npublic void remove(final int key);\npublic int removeAndGet(final int key);\npublic void clear();\npublic int put(final int key, final int value);\npublic int putAndGet(final int key, final int value);\npublic void add(final int key, final int value);\npublic int addAndGet(final int key, final int value);\npublic int[] getIndices();\npublic int[] getValues();\npublic Pair<int[], int[]> getIndicesAndValues();\npublic void apply(FnIntIntToInt lambda);\npublic void iterate(FnIntIntToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "public_field": "",
      "Method_statement": "hashCode()",
      "Method_name": "hashCode",
      "Class_declaration": "public class IntIntHashMap {\n",
      "constructors": "public IntIntHashMap() {\n    this(DEFAULT_EXPECTED_SIZE, Primitives.DEFAULT_MISSING_ENTRY_INT);\n}public IntIntHashMap(final int expectedSize, final int missingEntries) {\n    final int capacity = computeCapacity(expectedSize);\n    keys = new int[capacity];\n    values = new int[capacity];\n    states = new byte[capacity];\n    this.missingEntries = missingEntries;\n    size = 0;\n    mask = capacity - 1;\n    count = 0;\n}public IntIntHashMap(final IntIntHashMap source) {\n    final int length = source.keys.length;\n    keys = new int[length];\n    System.arraycopy(source.keys, 0, keys, 0, length);\n    values = new int[length];\n    System.arraycopy(source.values, 0, values, 0, length);\n    states = new byte[length];\n    System.arraycopy(source.states, 0, states, 0, length);\n    missingEntries = source.missingEntries;\n    size = source.size;\n    mask = source.mask;\n    count = source.count;\n}public IntIntHashMap(int[] keys, int[] vals) {\n    this(keys.length, Primitives.DEFAULT_MISSING_ENTRY_INT);\n    if (keys.length != vals.length) {\n        throw new IllegalStateException(\"keys and vals must be of the same length\");\n    }\n    for (int i = 0; i < keys.length; i++) {\n        this.put(keys[i], vals[i]);\n    }\n}",
      "all_method_signature": "public IntIntHashMap();\npublic IntIntHashMap(final int expectedSize, final int missingEntries);\npublic IntIntHashMap(final IntIntHashMap source);\npublic IntIntHashMap(int[] keys, int[] vals);\nprivate static int computeCapacity(final int expectedSize);\nprivate static int nextPowerOfTwo(final int i);\npublic int get(final int key);\npublic int getWithDefault(int key, int missingEntries);\npublic boolean contains(final int key);\npublic Iterator<IntIntEntry> iterator();\nprivate static int perturb(final int hash);\nprivate int findInsertionIndex(final int key);\nprivate static int findInsertionIndex(final int[] keys, final byte[] states, final int key, final int mask);\nprivate static int probe(final int perturb, final int j);\nprivate static int changeIndexSign(final int index);\npublic int size();\npublic void remove(final int key);\npublic int removeAndGet(final int key);\npublic void clear();\nprivate boolean contains(final int key, final int index);\nprivate int doRemove(int index);\npublic int put(final int key, final int value);\npublic int putAndGet(final int key, final int value);\npublic void add(final int key, final int value);\npublic int addAndGet(final int key, final int value);\nprivate void growTable();\nprivate boolean shouldGrowTable();\nprivate static int hashOf(final int key);\nprivate void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException;\npublic int[] getIndices();\npublic int[] getValues();\npublic Pair<int[], int[]> getIndicesAndValues();\npublic void apply(FnIntIntToInt lambda);\npublic void iterate(FnIntIntToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "Class_name": "IntIntHashMap",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java_generated/edu/jhu/prim/map/IntIntHashMap###hashCode",
      "Parameter_num": "0",
      "all_Import_statements": "import java.io.IOException;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.Serializable;\n\nimport java.util.Arrays;\n\nimport java.util.ConcurrentModificationException;\n\nimport java.util.Iterator;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.Map.Entry;\n\nimport edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.sort.IntIntSort;\n\nimport edu.jhu.prim.tuple.Pair;\n\nimport edu.jhu.prim.util.Lambda.FnIntIntToInt;\n\nimport edu.jhu.prim.util.Lambda.FnIntIntToVoid;\n\nimport edu.jhu.prim.vector.AbstractIntIntVector;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "method_signature": "public int hashCode();",
      "Junit_version": "4",
      "returnType": "int"
    },
    "Test_method": {
      "Method_body": "IntIntHashMap m1 = new IntIntHashMap();\n\rIntIntHashMap m2 = new IntIntHashMap();\n\rassertEquals(m1.hashCode(), m2.hashCode());\n\rm1.put(2, toInt(22));\n\rm1.put(1, toInt(11));\n\rm2.put(1, toInt(11));\n\rm2.put(2, toInt(22));\n\rassertEquals(m1.hashCode(), m2.hashCode());\n\rm2.put(3, toInt(33));\n\rm1.put(3, toInt(33));\n\rassertEquals(m1.hashCode(), m2.hashCode());",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "11",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toInt;\nimport static edu.jhu.prim.Primitives.toInt;\nimport static edu.jhu.prim.Primitives.toInt;\n",
      "allMethod_info": "@Test\npublic void testHashCode() throws Exception {\n    IntIntHashMap m1 = new IntIntHashMap();\n    IntIntHashMap m2 = new IntIntHashMap();\n    assertEquals(m1.hashCode(), m2.hashCode());\n    m1.put(2, toInt(22));\n    m1.put(1, toInt(11));\n    m2.put(1, toInt(11));\n    m2.put(2, toInt(22));\n    assertEquals(m1.hashCode(), m2.hashCode());\n    m2.put(3, toInt(33));\n    m1.put(3, toInt(33));\n    assertEquals(m1.hashCode(), m2.hashCode());\n}",
      "Method_name": "testHashCode",
      "Class_declaration": "public class IntIntHashMapTest {\n",
      "constructors": "",
      "Class_name": "IntIntHashMapTest",
      "methodName_paraNum": "[hashCode(0), hashCode(0), put(2), toInt(1), put(2), toInt(1), put(2), toInt(1), put(2), toInt(1), hashCode(0), hashCode(0), put(2), toInt(1), put(2), toInt(1), hashCode(0), hashCode(0)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntIntHashMapTest###testHashCode",
      "relativePath": "mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntIntHashMapTest.java",
      "Signature": "public void testHashCode() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toInt;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n\nimport edu.jhu.prim.Primitives;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic void remove(int idx) {\n    int i = Arrays.binarySearch(indices, 0, used, idx);\n    if (i < 0) {\n        throw new IllegalArgumentException(\"This map does not contain the key: \" + idx);\n    }\n    System.arraycopy(indices, i + 1, indices, i, used - i - 1);\n    System.arraycopy(values, i + 1, values, i, used - i - 1);\n    used--;\n}",
      "all_field_declaration": "private static final long serialVersionUID = 1L;\nprotected int[] indices;\nprotected int[] values;\n// TODO: size\nprotected int used;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "5",
      "Filed": "protected int[] indices;protected int[] values;protected int used;",
      "Parameter_type": "int",
      "Import_statements": "import java.util.Arrays;\n",
      "public_method_signature": "public IntIntSortedMap();\npublic IntIntSortedMap(int initialSize);\npublic IntIntSortedMap(int[] index, int[] data);\npublic IntIntSortedMap(IntIntSortedMap other);\npublic IntIntSortedMap(IntIntHashMap other);\npublic void clear();\npublic boolean contains(int idx);\npublic int get(int idx);\npublic int getWithDefault(int idx, int defaultVal);\npublic void remove(int idx);\npublic int put(int idx, int val);\npublic void add(int idx, int val);\npublic void apply(FnIntIntToInt lambda);\npublic void iterate(FnIntIntToVoid lambda);\npublic Iterator<IntIntEntry> iterator();\npublic int size();\npublic int getUsed();\npublic int[] getIndices();\npublic int[] getValues();\npublic int[] getInternalIndices();\npublic int[] getInternalValues();",
      "public_field": "",
      "Method_statement": "remove(int idx)",
      "Method_name": "remove",
      "Class_declaration": "public class IntIntSortedMap {\n",
      "constructors": "public IntIntSortedMap() {\n    this(0);\n}public IntIntSortedMap(int initialSize) {\n    this.used = 0;\n    this.indices = new int[initialSize];\n    this.values = new int[initialSize];\n}public IntIntSortedMap(int[] index, int[] data) {\n    if (!IntSort.isSortedAscAndUnique(index)) {\n        throw new IllegalStateException(\"Indices are not sorted ascending\");\n    }\n    this.used = index.length;\n    this.indices = index;\n    this.values = data;\n}public IntIntSortedMap(IntIntSortedMap other) {\n    this.used = other.used;\n    this.indices = IntArrays.copyOf(other.indices);\n    this.values = IntArrays.copyOf(other.values);\n}public IntIntSortedMap(IntIntHashMap other) {\n    Pair<int[], int[]> pair = other.getIndicesAndValues();\n    IntIntSort.sortIndexAsc(pair.get1(), pair.get2());\n    this.used = other.size();\n    this.indices = pair.get1();\n    this.values = pair.get2();\n}",
      "all_method_signature": "public IntIntSortedMap();\npublic IntIntSortedMap(int initialSize);\npublic IntIntSortedMap(int[] index, int[] data);\npublic IntIntSortedMap(IntIntSortedMap other);\npublic IntIntSortedMap(IntIntHashMap other);\npublic void clear();\npublic boolean contains(int idx);\npublic int get(int idx);\npublic int getWithDefault(int idx, int defaultVal);\npublic void remove(int idx);\npublic int put(int idx, int val);\npublic void add(int idx, int val);\npublic void apply(FnIntIntToInt lambda);\npublic void iterate(FnIntIntToVoid lambda);\nprivate final int[] insert(int[] array, int i, int val);\npublic Iterator<IntIntEntry> iterator();\npublic int size();\npublic int getUsed();\npublic int[] getIndices();\npublic int[] getValues();\npublic int[] getInternalIndices();\npublic int[] getInternalValues();",
      "Class_name": "IntIntSortedMap",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java_generated/edu/jhu/prim/map/IntIntSortedMap###remove",
      "Parameter_num": "1",
      "all_Import_statements": "import java.util.Arrays;\n\nimport java.util.Iterator;\n\nimport edu.jhu.prim.arrays.IntArrays;\n\nimport edu.jhu.prim.arrays.IntArrays;\n\nimport edu.jhu.prim.list.IntArrayList;\n\nimport edu.jhu.prim.list.IntArrayList;\n\nimport edu.jhu.prim.sort.IntIntSort;\n\nimport edu.jhu.prim.sort.IntSort;\n\nimport edu.jhu.prim.tuple.Pair;\n\nimport edu.jhu.prim.util.Lambda.FnIntIntToInt;\n\nimport edu.jhu.prim.util.Lambda.FnIntIntToVoid;\n\nimport edu.jhu.prim.vector.AbstractIntIntVector;\n",
      "comment": " (non-Javadoc)\n     * @see edu.jhu.util.vector.IntIntMap#remove(int)\n     ",
      "packageName": "edu.jhu.prim.map",
      "method_signature": "public void remove(int idx);",
      "Junit_version": "4",
      "returnType": "void"
    },
    "Test_method": {
      "Method_body": "// First element.\nIntIntMap map = new IntIntSortedMap();\n\rmap.put(2, toInt(22));\n\rmap.put(1, toInt(11));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(11, toInt(map.get(1)));\n\rmap.remove(1);\n\rassertEquals(false, map.contains(1));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(1, map.size());\n\r// Middle element.\nmap = new IntIntSortedMap();\n\rmap.put(2, toInt(22));\n\rmap.put(3, toInt(33));\n\rmap.put(1, toInt(11));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(33, toInt(map.get(3)));\n\rmap.remove(2);\n\rassertEquals(false, map.contains(2));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(33, toInt(map.get(3)));\n\rassertEquals(2, map.size());\n\r// Last element.\nmap = new IntIntSortedMap();\n\rmap.put(2, toInt(22));\n\rmap.put(3, toInt(33));\n\rmap.put(1, toInt(11));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(33, toInt(map.get(3)));\n\rmap.remove(3);\n\rassertEquals(false, map.contains(3));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(2, map.size());",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "33",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toInt;\nimport static edu.jhu.prim.Primitives.toInt;\nimport static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "@Test\npublic void testRemove() {\n    // First element.\n    IntIntMap map = new IntIntSortedMap();\n    map.put(2, toInt(22));\n    map.put(1, toInt(11));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(11, toInt(map.get(1)));\n    map.remove(1);\n    assertEquals(false, map.contains(1));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(1, map.size());\n    // Middle element.\n    map = new IntIntSortedMap();\n    map.put(2, toInt(22));\n    map.put(3, toInt(33));\n    map.put(1, toInt(11));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(33, toInt(map.get(3)));\n    map.remove(2);\n    assertEquals(false, map.contains(2));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(33, toInt(map.get(3)));\n    assertEquals(2, map.size());\n    // Last element.\n    map = new IntIntSortedMap();\n    map.put(2, toInt(22));\n    map.put(3, toInt(33));\n    map.put(1, toInt(11));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(33, toInt(map.get(3)));\n    map.remove(3);\n    assertEquals(false, map.contains(3));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(2, map.size());\n}",
      "Method_name": "testRemove",
      "Class_declaration": "public class IntIntSortedMapTest {\n",
      "constructors": "",
      "Class_name": "IntIntSortedMapTest",
      "methodName_paraNum": "[put(2), toInt(1), put(2), toInt(1), toInt(1), get(1), toInt(1), get(1), remove(1), contains(1), toInt(1), get(1), size(0), put(2), toInt(1), put(2), toInt(1), put(2), toInt(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), remove(1), contains(1), toInt(1), get(1), toInt(1), get(1), size(0), put(2), toInt(1), put(2), toInt(1), put(2), toInt(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), remove(1), contains(1), toInt(1), get(1), toInt(1), get(1), size(0)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntIntSortedMapTest###testRemove",
      "relativePath": "mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntIntSortedMapTest.java",
      "Signature": "public void testRemove() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toInt;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static IntIntSortedVector getWithNoZeroValues(IntIntSortedVector row) {\n    int[] origIndex = row.getIndices();\n    int[] origData = row.getValues();\n    int numNonZeros = 0;\n    boolean[] isNonZero = new boolean[row.getUsed()];\n    for (int i = 0; i < row.getUsed(); i++) {\n        if (!Primitives.isZero(origData[i])) {\n            isNonZero[i] = true;\n            numNonZeros++;\n        } else {\n            isNonZero[i] = false;\n        }\n    }\n    int numZeros = row.getUsed() - numNonZeros;\n    if (numZeros > 0) {\n        int[] newIndex = new int[numNonZeros];\n        int[] newData = new int[numNonZeros];\n        int newIdx = 0;\n        for (int i = 0; i < row.getUsed(); i++) {\n            if (isNonZero[i]) {\n                newIndex[newIdx] = origIndex[i];\n                newData[newIdx] = origData[i];\n                newIdx++;\n            }\n        }\n        return new IntIntSortedVector(newIndex, newData);\n    } else {\n        return row;\n    }\n}",
      "all_field_declaration": "private static final long serialVersionUID = 1L;\nprivate static final int ZERO = (int) 0;\nboolean norm2Cached = false;\nint norm2Value;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "7",
      "Filed": "",
      "Parameter_type": "IntIntSortedVector",
      "Import_statements": "import edu.jhu.prim.Primitives;\n",
      "public_method_signature": "public IntIntSortedVector();\npublic IntIntSortedVector(int initialSize);\npublic IntIntSortedVector(int[] index, int[] data);\npublic IntIntSortedVector(int[] denseRow);\npublic IntIntSortedVector(IntIntSortedVector vector);\npublic IntIntSortedVector(IntIntHashVector vector);\npublic IntIntSortedVector(IntIntDenseVector vector);\npublic IntIntSortedVector(IntIntVector other);\npublic IntIntVector copy();\npublic void add(int idx, int val);\npublic int set(int idx, int val);\npublic int get(int idx);\npublic void scale(int multiplier);\npublic int dot(int[] other);\npublic int dot(int[][] matrix, int col);\npublic int dot(IntIntVector y);\npublic static IntIntSortedVector getWithNoZeroValues(IntIntSortedVector row);\npublic IntIntSortedVector zero();\npublic void set(IntIntSortedVector other);\npublic void add(IntIntVector other);\npublic void subtract(IntIntVector other);\npublic void product(IntIntVector other);\npublic IntIntSortedVector getSum(IntIntVector other);\npublic IntIntSortedVector getDiff(IntIntVector other);\npublic IntIntSortedVector getProd(IntIntVector other);\npublic void apply(IntIntVector other, LambdaBinOpInt lambda, boolean skipZeros);\npublic String toString();\npublic boolean eq(IntIntSortedVector other);\npublic int getNumImplicitEntries();\npublic int[] toNativeArray();\npublic int hashCode();",
      "public_field": "",
      "Method_statement": "getWithNoZeroValues(IntIntSortedVector row)",
      "Method_name": "getWithNoZeroValues",
      "Class_declaration": "public class IntIntSortedVector {\n",
      "constructors": "public IntIntSortedVector() {\n    super();\n}public IntIntSortedVector(int initialSize) {\n    super(initialSize);\n}public IntIntSortedVector(int[] index, int[] data) {\n    super(index, data);\n}public IntIntSortedVector(int[] denseRow) {\n    this(IntArrays.range(denseRow.length), denseRow);\n}public IntIntSortedVector(IntIntSortedVector vector) {\n    super(vector);\n}public IntIntSortedVector(IntIntHashVector vector) {\n    super(vector);\n}public IntIntSortedVector(IntIntDenseVector vector) {\n    this(vector.toNativeArray());\n}public IntIntSortedVector(IntIntVector other) {\n    this();\n    final IntIntSortedVector thisVec = this;\n    other.iterate(new FnIntIntToVoid() {\n\n        @Override\n        public void call(int idx, int val) {\n            thisVec.set(idx, val);\n        }\n    });\n}",
      "all_method_signature": "public IntIntSortedVector();\npublic IntIntSortedVector(int initialSize);\npublic IntIntSortedVector(int[] index, int[] data);\npublic IntIntSortedVector(int[] denseRow);\npublic IntIntSortedVector(IntIntSortedVector vector);\npublic IntIntSortedVector(IntIntHashVector vector);\npublic IntIntSortedVector(IntIntDenseVector vector);\npublic IntIntSortedVector(IntIntVector other);\npublic IntIntVector copy();\npublic void add(int idx, int val);\npublic int set(int idx, int val);\npublic int get(int idx);\npublic void scale(int multiplier);\npublic int dot(int[] other);\npublic int dot(int[][] matrix, int col);\npublic int dot(IntIntVector y);\npublic static IntIntSortedVector getWithNoZeroValues(IntIntSortedVector row);\npublic IntIntSortedVector zero();\npublic void set(IntIntSortedVector other);\npublic void add(IntIntVector other);\npublic void subtract(IntIntVector other);\npublic void product(IntIntVector other);\npublic IntIntSortedVector getSum(IntIntVector other);\npublic IntIntSortedVector getDiff(IntIntVector other);\npublic IntIntSortedVector getProd(IntIntVector other);\npublic void apply(IntIntVector other, LambdaBinOpInt lambda, boolean skipZeros);\nprivate void applyToSorted(final IntIntSortedVector other, final LambdaBinOpInt lambda, final boolean skipZeros);\npublic String toString();\npublic boolean eq(IntIntSortedVector other);\npublic int getNumImplicitEntries();\npublic int[] toNativeArray();\npublic int hashCode();",
      "Class_name": "IntIntSortedVector",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java_generated/edu/jhu/prim/vector/IntIntSortedVector###getWithNoZeroValues",
      "Parameter_num": "1",
      "all_Import_statements": "import edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.arrays.IntArrays;\n\nimport edu.jhu.prim.arrays.IntArrays;\n\nimport edu.jhu.prim.list.IntArrayList;\n\nimport edu.jhu.prim.list.IntArrayList;\n\nimport edu.jhu.prim.map.IntIntEntry;\n\nimport edu.jhu.prim.map.IntIntSortedMap;\n\nimport edu.jhu.prim.util.Lambda;\n\nimport edu.jhu.prim.util.Lambda.FnIntIntToVoid;\n\nimport edu.jhu.prim.util.Lambda.LambdaBinOpInt;\n\nimport edu.jhu.prim.util.SafeCast;\n",
      "comment": "\n     * @return A new vector without zeros OR the same vector if it has none.\n     ",
      "packageName": "edu.jhu.prim.vector",
      "method_signature": "public static IntIntSortedVector getWithNoZeroValues(IntIntSortedVector row);",
      "Junit_version": "4",
      "returnType": "IntIntSortedVector"
    },
    "Test_method": {
      "Method_body": "IntIntSortedVector v1 = new IntIntSortedVector();\n\rv1.set(1, toInt(11));\n\rv1.set(3, toInt(0));\n\rv1.set(2, toInt(22));\n\rv1.set(4, toInt(44));\n\rv1.set(5, toInt(0));\n\rassertEquals(11, toInt(v1.get(1)));\n\rassertEquals(22, toInt(v1.get(2)));\n\rassertEquals(0, toInt(v1.get(3)));\n\rassertEquals(44, toInt(v1.get(4)));\n\rassertEquals(0, toInt(v1.get(5)));\n\rassertEquals(5, v1.getUsed());\n\rIntIntSortedVector v2 = IntIntSortedVector.getWithNoZeroValues(v1);\n\rassertEquals(3, v2.getUsed());\n\rassertEquals(11, toInt(v2.get(1)));\n\rassertEquals(22, toInt(v2.get(2)));\n\rassertEquals(44, toInt(v2.get(4)));",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "17",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toInt;\nimport static edu.jhu.prim.Primitives.toInt;\n",
      "allMethod_info": "@Test\npublic void testGetWithNoZeroValues() {\n    IntIntSortedVector v1 = new IntIntSortedVector();\n    v1.set(1, toInt(11));\n    v1.set(3, toInt(0));\n    v1.set(2, toInt(22));\n    v1.set(4, toInt(44));\n    v1.set(5, toInt(0));\n    assertEquals(11, toInt(v1.get(1)));\n    assertEquals(22, toInt(v1.get(2)));\n    assertEquals(0, toInt(v1.get(3)));\n    assertEquals(44, toInt(v1.get(4)));\n    assertEquals(0, toInt(v1.get(5)));\n    assertEquals(5, v1.getUsed());\n    IntIntSortedVector v2 = IntIntSortedVector.getWithNoZeroValues(v1);\n    assertEquals(3, v2.getUsed());\n    assertEquals(11, toInt(v2.get(1)));\n    assertEquals(22, toInt(v2.get(2)));\n    assertEquals(44, toInt(v2.get(4)));\n}",
      "Method_name": "testGetWithNoZeroValues",
      "Class_declaration": "public class IntIntSortedVectorTest {\n",
      "constructors": "",
      "Class_name": "IntIntSortedVectorTest",
      "methodName_paraNum": "[set(2), toInt(1), set(2), toInt(1), set(2), toInt(1), set(2), toInt(1), set(2), toInt(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), getUsed(0), getWithNoZeroValues(1), getUsed(0), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java_generated/edu/jhu/prim/vector/IntIntSortedVectorTest###testGetWithNoZeroValues",
      "relativePath": "mgormley_prim/src/test/java_generated/edu/jhu/prim/vector/IntIntSortedVectorTest.java",
      "Signature": "public void testGetWithNoZeroValues() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toInt;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n\nimport edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.map.IntIntEntry;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.vector",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic boolean equals(Object obj) {\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (this.getClass() != obj.getClass())\n        return false;\n    IntLongHashMap other = (IntLongHashMap) obj;\n    if (this.size() != other.size()) {\n        return false;\n    }\n    for (int i = 0; i < keys.length; i++) {\n        if (states[i] == FULL) {\n            if (!other.contains(keys[i]))\n                return false;\n            if (other.get(keys[i]) != values[i])\n                return false;\n        }\n    }\n    return true;\n}",
      "all_field_declaration": "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;\n/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;\n/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;\n/**\n * Serializable version identifier\n */\nprivate static final long serialVersionUID = -3646337053166149105L;\n/**\n * Load factor for the map.\n */\nprivate static final float LOAD_FACTOR = 0.75f;\n/**\n * Default starting size.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprotected static final int DEFAULT_EXPECTED_SIZE = 16;\n/**\n * Multiplier for size growth when map fills up.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprivate static final int RESIZE_MULTIPLIER = 2;\n/**\n * Number of bits to perturb the index when probing for collision resolution.\n */\nprivate static final int PERTURB_SHIFT = 5;\n/**\n * Keys table.\n */\nprotected int[] keys;\n/**\n * Values table.\n */\nprotected long[] values;\n/**\n * States table.\n */\nprotected byte[] states;\n/**\n * Return value for missing entries.\n */\nprivate final long missingEntries;\n/**\n * Current size of the map.\n */\nprivate int size;\n/**\n * Bit mask for hash values.\n */\nprivate int mask;\n/**\n * Modifications count.\n */\nprivate transient int count;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "7",
      "Filed": "protected static final byte FULL = 1;protected int[] keys;protected long[] values;protected byte[] states;private int size;",
      "Parameter_type": "Object",
      "Import_statements": "",
      "public_method_signature": "public IntLongHashMap();\npublic IntLongHashMap(final int expectedSize, final long missingEntries);\npublic IntLongHashMap(final IntLongHashMap source);\npublic IntLongHashMap(int[] keys, long[] vals);\npublic long get(final int key);\npublic long getWithDefault(int key, long missingEntries);\npublic boolean contains(final int key);\npublic Iterator<IntLongEntry> iterator();\npublic int size();\npublic void remove(final int key);\npublic long removeAndGet(final int key);\npublic void clear();\npublic long put(final int key, final long value);\npublic long putAndGet(final int key, final long value);\npublic void add(final int key, final long value);\npublic long addAndGet(final int key, final long value);\npublic int[] getIndices();\npublic long[] getValues();\npublic Pair<int[], long[]> getIndicesAndValues();\npublic void apply(FnIntLongToLong lambda);\npublic void iterate(FnIntLongToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "public_field": "",
      "Method_statement": "equals(Object obj)",
      "Method_name": "equals",
      "Class_declaration": "public class IntLongHashMap {\n",
      "constructors": "public IntLongHashMap() {\n    this(DEFAULT_EXPECTED_SIZE, Primitives.DEFAULT_MISSING_ENTRY_LONG);\n}public IntLongHashMap(final int expectedSize, final long missingEntries) {\n    final int capacity = computeCapacity(expectedSize);\n    keys = new int[capacity];\n    values = new long[capacity];\n    states = new byte[capacity];\n    this.missingEntries = missingEntries;\n    size = 0;\n    mask = capacity - 1;\n    count = 0;\n}public IntLongHashMap(final IntLongHashMap source) {\n    final int length = source.keys.length;\n    keys = new int[length];\n    System.arraycopy(source.keys, 0, keys, 0, length);\n    values = new long[length];\n    System.arraycopy(source.values, 0, values, 0, length);\n    states = new byte[length];\n    System.arraycopy(source.states, 0, states, 0, length);\n    missingEntries = source.missingEntries;\n    size = source.size;\n    mask = source.mask;\n    count = source.count;\n}public IntLongHashMap(int[] keys, long[] vals) {\n    this(keys.length, Primitives.DEFAULT_MISSING_ENTRY_LONG);\n    if (keys.length != vals.length) {\n        throw new IllegalStateException(\"keys and vals must be of the same length\");\n    }\n    for (int i = 0; i < keys.length; i++) {\n        this.put(keys[i], vals[i]);\n    }\n}",
      "all_method_signature": "public IntLongHashMap();\npublic IntLongHashMap(final int expectedSize, final long missingEntries);\npublic IntLongHashMap(final IntLongHashMap source);\npublic IntLongHashMap(int[] keys, long[] vals);\nprivate static int computeCapacity(final int expectedSize);\nprivate static int nextPowerOfTwo(final int i);\npublic long get(final int key);\npublic long getWithDefault(int key, long missingEntries);\npublic boolean contains(final int key);\npublic Iterator<IntLongEntry> iterator();\nprivate static int perturb(final int hash);\nprivate int findInsertionIndex(final int key);\nprivate static int findInsertionIndex(final int[] keys, final byte[] states, final int key, final int mask);\nprivate static int probe(final int perturb, final int j);\nprivate static int changeIndexSign(final int index);\npublic int size();\npublic void remove(final int key);\npublic long removeAndGet(final int key);\npublic void clear();\nprivate boolean contains(final int key, final int index);\nprivate long doRemove(int index);\npublic long put(final int key, final long value);\npublic long putAndGet(final int key, final long value);\npublic void add(final int key, final long value);\npublic long addAndGet(final int key, final long value);\nprivate void growTable();\nprivate boolean shouldGrowTable();\nprivate static int hashOf(final int key);\nprivate void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException;\npublic int[] getIndices();\npublic long[] getValues();\npublic Pair<int[], long[]> getIndicesAndValues();\npublic void apply(FnIntLongToLong lambda);\npublic void iterate(FnIntLongToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "Class_name": "IntLongHashMap",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java_generated/edu/jhu/prim/map/IntLongHashMap###equals",
      "Parameter_num": "1",
      "all_Import_statements": "import java.io.IOException;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.Serializable;\n\nimport java.util.Arrays;\n\nimport java.util.ConcurrentModificationException;\n\nimport java.util.Iterator;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.Map.Entry;\n\nimport edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.sort.IntLongSort;\n\nimport edu.jhu.prim.tuple.Pair;\n\nimport edu.jhu.prim.util.Lambda.FnIntLongToLong;\n\nimport edu.jhu.prim.util.Lambda.FnIntLongToVoid;\n\nimport edu.jhu.prim.vector.AbstractIntLongVector;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "method_signature": "public boolean equals(Object obj);",
      "Junit_version": "4",
      "returnType": "boolean"
    },
    "Test_method": {
      "Method_body": "IntLongHashMap m1 = new IntLongHashMap();\n\rIntLongHashMap m2 = new IntLongHashMap();\n\rassertTrue(m1.equals(m2));\n\rm1.put(2, toLong(22));\n\rm1.put(1, toLong(11));\n\rassertFalse(m1.equals(m2));\n\rm2.put(1, toLong(11));\n\rm2.put(2, toLong(22));\n\rassertTrue(m1.equals(m2));\n\rm2.put(3, toLong(33));\n\rassertFalse(m1.equals(m2));\n\rm1.put(3, toLong(33));\n\rassertTrue(m1.equals(m2));",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "13",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toLong;\n",
      "allMethod_info": "@Test\npublic void testEquals() throws Exception {\n    IntLongHashMap m1 = new IntLongHashMap();\n    IntLongHashMap m2 = new IntLongHashMap();\n    assertTrue(m1.equals(m2));\n    m1.put(2, toLong(22));\n    m1.put(1, toLong(11));\n    assertFalse(m1.equals(m2));\n    m2.put(1, toLong(11));\n    m2.put(2, toLong(22));\n    assertTrue(m1.equals(m2));\n    m2.put(3, toLong(33));\n    assertFalse(m1.equals(m2));\n    m1.put(3, toLong(33));\n    assertTrue(m1.equals(m2));\n}",
      "Method_name": "testEquals",
      "Class_declaration": "public class IntLongHashMapTest {\n",
      "constructors": "",
      "Class_name": "IntLongHashMapTest",
      "methodName_paraNum": "[equals(1), put(2), toLong(1), put(2), toLong(1), equals(1), put(2), toLong(1), put(2), toLong(1), equals(1), put(2), toLong(1), equals(1), put(2), toLong(1), equals(1)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntLongHashMapTest###testEquals",
      "relativePath": "mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntLongHashMapTest.java",
      "Signature": "public void testEquals() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toLong;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n\nimport edu.jhu.prim.Primitives;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic int hashCode() {\n    int h = 0;\n    int[] indices = getIndices();\n    long[] values = getValues();\n    IntLongSort.sortIndexAsc(indices, values);\n    for (int i = 0; i < indices.length; i++) {\n        int result = 17;\n        result = 37 * result + Primitives.hashOfInt(indices[i]);\n        result = 37 * result + Primitives.hashOfLong(values[i]);\n        h += result;\n    }\n    return h;\n}",
      "all_field_declaration": "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;\n/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;\n/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;\n/**\n * Serializable version identifier\n */\nprivate static final long serialVersionUID = -3646337053166149105L;\n/**\n * Load factor for the map.\n */\nprivate static final float LOAD_FACTOR = 0.75f;\n/**\n * Default starting size.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprotected static final int DEFAULT_EXPECTED_SIZE = 16;\n/**\n * Multiplier for size growth when map fills up.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprivate static final int RESIZE_MULTIPLIER = 2;\n/**\n * Number of bits to perturb the index when probing for collision resolution.\n */\nprivate static final int PERTURB_SHIFT = 5;\n/**\n * Keys table.\n */\nprotected int[] keys;\n/**\n * Values table.\n */\nprotected long[] values;\n/**\n * States table.\n */\nprotected byte[] states;\n/**\n * Return value for missing entries.\n */\nprivate final long missingEntries;\n/**\n * Current size of the map.\n */\nprivate int size;\n/**\n * Bit mask for hash values.\n */\nprivate int mask;\n/**\n * Modifications count.\n */\nprivate transient int count;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "6",
      "Filed": "protected long[] values;",
      "Parameter_type": "",
      "Import_statements": "import edu.jhu.prim.Primitives;\nimport edu.jhu.prim.sort.IntLongSort;\n",
      "public_method_signature": "public IntLongHashMap();\npublic IntLongHashMap(final int expectedSize, final long missingEntries);\npublic IntLongHashMap(final IntLongHashMap source);\npublic IntLongHashMap(int[] keys, long[] vals);\npublic long get(final int key);\npublic long getWithDefault(int key, long missingEntries);\npublic boolean contains(final int key);\npublic Iterator<IntLongEntry> iterator();\npublic int size();\npublic void remove(final int key);\npublic long removeAndGet(final int key);\npublic void clear();\npublic long put(final int key, final long value);\npublic long putAndGet(final int key, final long value);\npublic void add(final int key, final long value);\npublic long addAndGet(final int key, final long value);\npublic int[] getIndices();\npublic long[] getValues();\npublic Pair<int[], long[]> getIndicesAndValues();\npublic void apply(FnIntLongToLong lambda);\npublic void iterate(FnIntLongToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "public_field": "",
      "Method_statement": "hashCode()",
      "Method_name": "hashCode",
      "Class_declaration": "public class IntLongHashMap {\n",
      "constructors": "public IntLongHashMap() {\n    this(DEFAULT_EXPECTED_SIZE, Primitives.DEFAULT_MISSING_ENTRY_LONG);\n}public IntLongHashMap(final int expectedSize, final long missingEntries) {\n    final int capacity = computeCapacity(expectedSize);\n    keys = new int[capacity];\n    values = new long[capacity];\n    states = new byte[capacity];\n    this.missingEntries = missingEntries;\n    size = 0;\n    mask = capacity - 1;\n    count = 0;\n}public IntLongHashMap(final IntLongHashMap source) {\n    final int length = source.keys.length;\n    keys = new int[length];\n    System.arraycopy(source.keys, 0, keys, 0, length);\n    values = new long[length];\n    System.arraycopy(source.values, 0, values, 0, length);\n    states = new byte[length];\n    System.arraycopy(source.states, 0, states, 0, length);\n    missingEntries = source.missingEntries;\n    size = source.size;\n    mask = source.mask;\n    count = source.count;\n}public IntLongHashMap(int[] keys, long[] vals) {\n    this(keys.length, Primitives.DEFAULT_MISSING_ENTRY_LONG);\n    if (keys.length != vals.length) {\n        throw new IllegalStateException(\"keys and vals must be of the same length\");\n    }\n    for (int i = 0; i < keys.length; i++) {\n        this.put(keys[i], vals[i]);\n    }\n}",
      "all_method_signature": "public IntLongHashMap();\npublic IntLongHashMap(final int expectedSize, final long missingEntries);\npublic IntLongHashMap(final IntLongHashMap source);\npublic IntLongHashMap(int[] keys, long[] vals);\nprivate static int computeCapacity(final int expectedSize);\nprivate static int nextPowerOfTwo(final int i);\npublic long get(final int key);\npublic long getWithDefault(int key, long missingEntries);\npublic boolean contains(final int key);\npublic Iterator<IntLongEntry> iterator();\nprivate static int perturb(final int hash);\nprivate int findInsertionIndex(final int key);\nprivate static int findInsertionIndex(final int[] keys, final byte[] states, final int key, final int mask);\nprivate static int probe(final int perturb, final int j);\nprivate static int changeIndexSign(final int index);\npublic int size();\npublic void remove(final int key);\npublic long removeAndGet(final int key);\npublic void clear();\nprivate boolean contains(final int key, final int index);\nprivate long doRemove(int index);\npublic long put(final int key, final long value);\npublic long putAndGet(final int key, final long value);\npublic void add(final int key, final long value);\npublic long addAndGet(final int key, final long value);\nprivate void growTable();\nprivate boolean shouldGrowTable();\nprivate static int hashOf(final int key);\nprivate void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException;\npublic int[] getIndices();\npublic long[] getValues();\npublic Pair<int[], long[]> getIndicesAndValues();\npublic void apply(FnIntLongToLong lambda);\npublic void iterate(FnIntLongToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "Class_name": "IntLongHashMap",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java_generated/edu/jhu/prim/map/IntLongHashMap###hashCode",
      "Parameter_num": "0",
      "all_Import_statements": "import java.io.IOException;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.Serializable;\n\nimport java.util.Arrays;\n\nimport java.util.ConcurrentModificationException;\n\nimport java.util.Iterator;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.Map.Entry;\n\nimport edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.sort.IntLongSort;\n\nimport edu.jhu.prim.tuple.Pair;\n\nimport edu.jhu.prim.util.Lambda.FnIntLongToLong;\n\nimport edu.jhu.prim.util.Lambda.FnIntLongToVoid;\n\nimport edu.jhu.prim.vector.AbstractIntLongVector;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "method_signature": "public int hashCode();",
      "Junit_version": "4",
      "returnType": "int"
    },
    "Test_method": {
      "Method_body": "IntLongHashMap m1 = new IntLongHashMap();\n\rIntLongHashMap m2 = new IntLongHashMap();\n\rassertEquals(m1.hashCode(), m2.hashCode());\n\rm1.put(2, toLong(22));\n\rm1.put(1, toLong(11));\n\rm2.put(1, toLong(11));\n\rm2.put(2, toLong(22));\n\rassertEquals(m1.hashCode(), m2.hashCode());\n\rm2.put(3, toLong(33));\n\rm1.put(3, toLong(33));\n\rassertEquals(m1.hashCode(), m2.hashCode());",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "11",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toLong;\n",
      "allMethod_info": "@Test\npublic void testHashCode() throws Exception {\n    IntLongHashMap m1 = new IntLongHashMap();\n    IntLongHashMap m2 = new IntLongHashMap();\n    assertEquals(m1.hashCode(), m2.hashCode());\n    m1.put(2, toLong(22));\n    m1.put(1, toLong(11));\n    m2.put(1, toLong(11));\n    m2.put(2, toLong(22));\n    assertEquals(m1.hashCode(), m2.hashCode());\n    m2.put(3, toLong(33));\n    m1.put(3, toLong(33));\n    assertEquals(m1.hashCode(), m2.hashCode());\n}",
      "Method_name": "testHashCode",
      "Class_declaration": "public class IntLongHashMapTest {\n",
      "constructors": "",
      "Class_name": "IntLongHashMapTest",
      "methodName_paraNum": "[hashCode(0), hashCode(0), put(2), toLong(1), put(2), toLong(1), put(2), toLong(1), put(2), toLong(1), hashCode(0), hashCode(0), put(2), toLong(1), put(2), toLong(1), hashCode(0), hashCode(0)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntLongHashMapTest###testHashCode",
      "relativePath": "mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntLongHashMapTest.java",
      "Signature": "public void testHashCode() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toLong;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n\nimport edu.jhu.prim.Primitives;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic void remove(int idx) {\n    int i = Arrays.binarySearch(indices, 0, used, idx);\n    if (i < 0) {\n        throw new IllegalArgumentException(\"This map does not contain the key: \" + idx);\n    }\n    System.arraycopy(indices, i + 1, indices, i, used - i - 1);\n    System.arraycopy(values, i + 1, values, i, used - i - 1);\n    used--;\n}",
      "all_field_declaration": "private static final long serialVersionUID = 1L;\nprotected int[] indices;\nprotected long[] values;\n// TODO: size\nprotected int used;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "5",
      "Filed": "protected int[] indices;protected long[] values;protected int used;",
      "Parameter_type": "int",
      "Import_statements": "import java.util.Arrays;\n",
      "public_method_signature": "public IntLongSortedMap();\npublic IntLongSortedMap(int initialSize);\npublic IntLongSortedMap(int[] index, long[] data);\npublic IntLongSortedMap(IntLongSortedMap other);\npublic IntLongSortedMap(IntLongHashMap other);\npublic void clear();\npublic boolean contains(int idx);\npublic long get(int idx);\npublic long getWithDefault(int idx, long defaultVal);\npublic void remove(int idx);\npublic long put(int idx, long val);\npublic void add(int idx, long val);\npublic void apply(FnIntLongToLong lambda);\npublic void iterate(FnIntLongToVoid lambda);\npublic Iterator<IntLongEntry> iterator();\npublic int size();\npublic int getUsed();\npublic int[] getIndices();\npublic long[] getValues();\npublic int[] getInternalIndices();\npublic long[] getInternalValues();",
      "public_field": "",
      "Method_statement": "remove(int idx)",
      "Method_name": "remove",
      "Class_declaration": "public class IntLongSortedMap {\n",
      "constructors": "public IntLongSortedMap() {\n    this(0);\n}public IntLongSortedMap(int initialSize) {\n    this.used = 0;\n    this.indices = new int[initialSize];\n    this.values = new long[initialSize];\n}public IntLongSortedMap(int[] index, long[] data) {\n    if (!IntSort.isSortedAscAndUnique(index)) {\n        throw new IllegalStateException(\"Indices are not sorted ascending\");\n    }\n    this.used = index.length;\n    this.indices = index;\n    this.values = data;\n}public IntLongSortedMap(IntLongSortedMap other) {\n    this.used = other.used;\n    this.indices = IntArrays.copyOf(other.indices);\n    this.values = LongArrays.copyOf(other.values);\n}public IntLongSortedMap(IntLongHashMap other) {\n    Pair<int[], long[]> pair = other.getIndicesAndValues();\n    IntLongSort.sortIndexAsc(pair.get1(), pair.get2());\n    this.used = other.size();\n    this.indices = pair.get1();\n    this.values = pair.get2();\n}",
      "all_method_signature": "public IntLongSortedMap();\npublic IntLongSortedMap(int initialSize);\npublic IntLongSortedMap(int[] index, long[] data);\npublic IntLongSortedMap(IntLongSortedMap other);\npublic IntLongSortedMap(IntLongHashMap other);\npublic void clear();\npublic boolean contains(int idx);\npublic long get(int idx);\npublic long getWithDefault(int idx, long defaultVal);\npublic void remove(int idx);\npublic long put(int idx, long val);\npublic void add(int idx, long val);\npublic void apply(FnIntLongToLong lambda);\npublic void iterate(FnIntLongToVoid lambda);\nprivate final int[] insert(int[] array, int i, int val);\nprivate final long[] insert(long[] array, int i, long val);\npublic Iterator<IntLongEntry> iterator();\npublic int size();\npublic int getUsed();\npublic int[] getIndices();\npublic long[] getValues();\npublic int[] getInternalIndices();\npublic long[] getInternalValues();",
      "Class_name": "IntLongSortedMap",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java_generated/edu/jhu/prim/map/IntLongSortedMap###remove",
      "Parameter_num": "1",
      "all_Import_statements": "import java.util.Arrays;\n\nimport java.util.Iterator;\n\nimport edu.jhu.prim.arrays.LongArrays;\n\nimport edu.jhu.prim.arrays.IntArrays;\n\nimport edu.jhu.prim.list.LongArrayList;\n\nimport edu.jhu.prim.list.IntArrayList;\n\nimport edu.jhu.prim.sort.IntLongSort;\n\nimport edu.jhu.prim.sort.IntSort;\n\nimport edu.jhu.prim.tuple.Pair;\n\nimport edu.jhu.prim.util.Lambda.FnIntLongToLong;\n\nimport edu.jhu.prim.util.Lambda.FnIntLongToVoid;\n\nimport edu.jhu.prim.vector.AbstractIntLongVector;\n",
      "comment": " (non-Javadoc)\n     * @see edu.jhu.util.vector.IntLongMap#remove(int)\n     ",
      "packageName": "edu.jhu.prim.map",
      "method_signature": "public void remove(int idx);",
      "Junit_version": "4",
      "returnType": "void"
    },
    "Test_method": {
      "Method_body": "// First element.\nIntLongMap map = new IntLongSortedMap();\n\rmap.put(2, toLong(22));\n\rmap.put(1, toLong(11));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(11, toInt(map.get(1)));\n\rmap.remove(1);\n\rassertEquals(false, map.contains(1));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(1, map.size());\n\r// Middle element.\nmap = new IntLongSortedMap();\n\rmap.put(2, toLong(22));\n\rmap.put(3, toLong(33));\n\rmap.put(1, toLong(11));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(33, toInt(map.get(3)));\n\rmap.remove(2);\n\rassertEquals(false, map.contains(2));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(33, toInt(map.get(3)));\n\rassertEquals(2, map.size());\n\r// Last element.\nmap = new IntLongSortedMap();\n\rmap.put(2, toLong(22));\n\rmap.put(3, toLong(33));\n\rmap.put(1, toLong(11));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(33, toInt(map.get(3)));\n\rmap.remove(3);\n\rassertEquals(false, map.contains(3));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(2, map.size());",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "33",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toLong;\nimport static edu.jhu.prim.Primitives.toInt;\nimport static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "@Test\npublic void testRemove() {\n    // First element.\n    IntLongMap map = new IntLongSortedMap();\n    map.put(2, toLong(22));\n    map.put(1, toLong(11));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(11, toInt(map.get(1)));\n    map.remove(1);\n    assertEquals(false, map.contains(1));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(1, map.size());\n    // Middle element.\n    map = new IntLongSortedMap();\n    map.put(2, toLong(22));\n    map.put(3, toLong(33));\n    map.put(1, toLong(11));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(33, toInt(map.get(3)));\n    map.remove(2);\n    assertEquals(false, map.contains(2));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(33, toInt(map.get(3)));\n    assertEquals(2, map.size());\n    // Last element.\n    map = new IntLongSortedMap();\n    map.put(2, toLong(22));\n    map.put(3, toLong(33));\n    map.put(1, toLong(11));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(33, toInt(map.get(3)));\n    map.remove(3);\n    assertEquals(false, map.contains(3));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(2, map.size());\n}",
      "Method_name": "testRemove",
      "Class_declaration": "public class IntLongSortedMapTest {\n",
      "constructors": "",
      "Class_name": "IntLongSortedMapTest",
      "methodName_paraNum": "[put(2), toLong(1), put(2), toLong(1), toInt(1), get(1), toInt(1), get(1), remove(1), contains(1), toInt(1), get(1), size(0), put(2), toLong(1), put(2), toLong(1), put(2), toLong(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), remove(1), contains(1), toInt(1), get(1), toInt(1), get(1), size(0), put(2), toLong(1), put(2), toLong(1), put(2), toLong(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), remove(1), contains(1), toInt(1), get(1), toInt(1), get(1), size(0)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntLongSortedMapTest###testRemove",
      "relativePath": "mgormley_prim/src/test/java_generated/edu/jhu/prim/map/IntLongSortedMapTest.java",
      "Signature": "public void testRemove() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toLong;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static IntLongSortedVector getWithNoZeroValues(IntLongSortedVector row) {\n    int[] origIndex = row.getIndices();\n    long[] origData = row.getValues();\n    int numNonZeros = 0;\n    boolean[] isNonZero = new boolean[row.getUsed()];\n    for (int i = 0; i < row.getUsed(); i++) {\n        if (!Primitives.isZero(origData[i])) {\n            isNonZero[i] = true;\n            numNonZeros++;\n        } else {\n            isNonZero[i] = false;\n        }\n    }\n    int numZeros = row.getUsed() - numNonZeros;\n    if (numZeros > 0) {\n        int[] newIndex = new int[numNonZeros];\n        long[] newData = new long[numNonZeros];\n        int newIdx = 0;\n        for (int i = 0; i < row.getUsed(); i++) {\n            if (isNonZero[i]) {\n                newIndex[newIdx] = origIndex[i];\n                newData[newIdx] = origData[i];\n                newIdx++;\n            }\n        }\n        return new IntLongSortedVector(newIndex, newData);\n    } else {\n        return row;\n    }\n}",
      "all_field_declaration": "private static final long serialVersionUID = 1L;\nprivate static final long ZERO = (long) 0;\nboolean norm2Cached = false;\nlong norm2Value;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "7",
      "Filed": "",
      "Parameter_type": "IntLongSortedVector",
      "Import_statements": "import edu.jhu.prim.Primitives;\n",
      "public_method_signature": "public IntLongSortedVector();\npublic IntLongSortedVector(int initialSize);\npublic IntLongSortedVector(int[] index, long[] data);\npublic IntLongSortedVector(long[] denseRow);\npublic IntLongSortedVector(IntLongSortedVector vector);\npublic IntLongSortedVector(IntLongHashVector vector);\npublic IntLongSortedVector(IntLongDenseVector vector);\npublic IntLongSortedVector(IntLongVector other);\npublic IntLongVector copy();\npublic void add(int idx, long val);\npublic long set(int idx, long val);\npublic long get(int idx);\npublic void scale(long multiplier);\npublic long dot(long[] other);\npublic long dot(long[][] matrix, int col);\npublic long dot(IntLongVector y);\npublic static IntLongSortedVector getWithNoZeroValues(IntLongSortedVector row);\npublic IntLongSortedVector zero();\npublic void set(IntLongSortedVector other);\npublic void add(IntLongVector other);\npublic void subtract(IntLongVector other);\npublic void product(IntLongVector other);\npublic IntLongSortedVector getSum(IntLongVector other);\npublic IntLongSortedVector getDiff(IntLongVector other);\npublic IntLongSortedVector getProd(IntLongVector other);\npublic void apply(IntLongVector other, LambdaBinOpLong lambda, boolean skipZeros);\npublic String toString();\npublic boolean eq(IntLongSortedVector other);\npublic int getNumImplicitEntries();\npublic long[] toNativeArray();\npublic int hashCode();",
      "public_field": "",
      "Method_statement": "getWithNoZeroValues(IntLongSortedVector row)",
      "Method_name": "getWithNoZeroValues",
      "Class_declaration": "public class IntLongSortedVector {\n",
      "constructors": "public IntLongSortedVector() {\n    super();\n}public IntLongSortedVector(int initialSize) {\n    super(initialSize);\n}public IntLongSortedVector(int[] index, long[] data) {\n    super(index, data);\n}public IntLongSortedVector(long[] denseRow) {\n    this(IntArrays.range(denseRow.length), denseRow);\n}public IntLongSortedVector(IntLongSortedVector vector) {\n    super(vector);\n}public IntLongSortedVector(IntLongHashVector vector) {\n    super(vector);\n}public IntLongSortedVector(IntLongDenseVector vector) {\n    this(vector.toNativeArray());\n}public IntLongSortedVector(IntLongVector other) {\n    this();\n    final IntLongSortedVector thisVec = this;\n    other.iterate(new FnIntLongToVoid() {\n\n        @Override\n        public void call(int idx, long val) {\n            thisVec.set(idx, val);\n        }\n    });\n}",
      "all_method_signature": "public IntLongSortedVector();\npublic IntLongSortedVector(int initialSize);\npublic IntLongSortedVector(int[] index, long[] data);\npublic IntLongSortedVector(long[] denseRow);\npublic IntLongSortedVector(IntLongSortedVector vector);\npublic IntLongSortedVector(IntLongHashVector vector);\npublic IntLongSortedVector(IntLongDenseVector vector);\npublic IntLongSortedVector(IntLongVector other);\npublic IntLongVector copy();\npublic void add(int idx, long val);\npublic long set(int idx, long val);\npublic long get(int idx);\npublic void scale(long multiplier);\npublic long dot(long[] other);\npublic long dot(long[][] matrix, int col);\npublic long dot(IntLongVector y);\npublic static IntLongSortedVector getWithNoZeroValues(IntLongSortedVector row);\npublic IntLongSortedVector zero();\npublic void set(IntLongSortedVector other);\npublic void add(IntLongVector other);\npublic void subtract(IntLongVector other);\npublic void product(IntLongVector other);\npublic IntLongSortedVector getSum(IntLongVector other);\npublic IntLongSortedVector getDiff(IntLongVector other);\npublic IntLongSortedVector getProd(IntLongVector other);\npublic void apply(IntLongVector other, LambdaBinOpLong lambda, boolean skipZeros);\nprivate void applyToSorted(final IntLongSortedVector other, final LambdaBinOpLong lambda, final boolean skipZeros);\npublic String toString();\npublic boolean eq(IntLongSortedVector other);\npublic int getNumImplicitEntries();\npublic long[] toNativeArray();\npublic int hashCode();",
      "Class_name": "IntLongSortedVector",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java_generated/edu/jhu/prim/vector/IntLongSortedVector###getWithNoZeroValues",
      "Parameter_num": "1",
      "all_Import_statements": "import edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.arrays.LongArrays;\n\nimport edu.jhu.prim.arrays.IntArrays;\n\nimport edu.jhu.prim.list.LongArrayList;\n\nimport edu.jhu.prim.list.IntArrayList;\n\nimport edu.jhu.prim.map.IntLongEntry;\n\nimport edu.jhu.prim.map.IntLongSortedMap;\n\nimport edu.jhu.prim.util.Lambda;\n\nimport edu.jhu.prim.util.Lambda.FnIntLongToVoid;\n\nimport edu.jhu.prim.util.Lambda.LambdaBinOpLong;\n\nimport edu.jhu.prim.util.SafeCast;\n",
      "comment": "\n     * @return A new vector without zeros OR the same vector if it has none.\n     ",
      "packageName": "edu.jhu.prim.vector",
      "method_signature": "public static IntLongSortedVector getWithNoZeroValues(IntLongSortedVector row);",
      "Junit_version": "4",
      "returnType": "IntLongSortedVector"
    },
    "Test_method": {
      "Method_body": "IntLongSortedVector v1 = new IntLongSortedVector();\n\rv1.set(1, toLong(11));\n\rv1.set(3, toLong(0));\n\rv1.set(2, toLong(22));\n\rv1.set(4, toLong(44));\n\rv1.set(5, toLong(0));\n\rassertEquals(11, toInt(v1.get(1)));\n\rassertEquals(22, toInt(v1.get(2)));\n\rassertEquals(0, toInt(v1.get(3)));\n\rassertEquals(44, toInt(v1.get(4)));\n\rassertEquals(0, toInt(v1.get(5)));\n\rassertEquals(5, v1.getUsed());\n\rIntLongSortedVector v2 = IntLongSortedVector.getWithNoZeroValues(v1);\n\rassertEquals(3, v2.getUsed());\n\rassertEquals(11, toInt(v2.get(1)));\n\rassertEquals(22, toInt(v2.get(2)));\n\rassertEquals(44, toInt(v2.get(4)));",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "17",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toLong;\nimport static edu.jhu.prim.Primitives.toInt;\n",
      "allMethod_info": "@Test\npublic void testGetWithNoZeroValues() {\n    IntLongSortedVector v1 = new IntLongSortedVector();\n    v1.set(1, toLong(11));\n    v1.set(3, toLong(0));\n    v1.set(2, toLong(22));\n    v1.set(4, toLong(44));\n    v1.set(5, toLong(0));\n    assertEquals(11, toInt(v1.get(1)));\n    assertEquals(22, toInt(v1.get(2)));\n    assertEquals(0, toInt(v1.get(3)));\n    assertEquals(44, toInt(v1.get(4)));\n    assertEquals(0, toInt(v1.get(5)));\n    assertEquals(5, v1.getUsed());\n    IntLongSortedVector v2 = IntLongSortedVector.getWithNoZeroValues(v1);\n    assertEquals(3, v2.getUsed());\n    assertEquals(11, toInt(v2.get(1)));\n    assertEquals(22, toInt(v2.get(2)));\n    assertEquals(44, toInt(v2.get(4)));\n}",
      "Method_name": "testGetWithNoZeroValues",
      "Class_declaration": "public class IntLongSortedVectorTest {\n",
      "constructors": "",
      "Class_name": "IntLongSortedVectorTest",
      "methodName_paraNum": "[set(2), toLong(1), set(2), toLong(1), set(2), toLong(1), set(2), toLong(1), set(2), toLong(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), getUsed(0), getWithNoZeroValues(1), getUsed(0), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java_generated/edu/jhu/prim/vector/IntLongSortedVectorTest###testGetWithNoZeroValues",
      "relativePath": "mgormley_prim/src/test/java_generated/edu/jhu/prim/vector/IntLongSortedVectorTest.java",
      "Signature": "public void testGetWithNoZeroValues() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toLong;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n\nimport edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.map.IntLongEntry;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.vector",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public int[] keys() {\n    int[] ks = new int[size()];\n    int i = 0;\n    Iterator iter = this.iterator();\n    while (iter.hasNext()) {\n        iter.advance();\n        ks[i++] = iter.key();\n    }\n    return ks;\n}",
      "all_field_declaration": "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;\n/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;\n/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;\n/**\n * Serializable version identifier\n */\nprivate static final long serialVersionUID = -3646337053166149105L;\n/**\n * Load factor for the map.\n */\nprivate static final float LOAD_FACTOR = 0.5f;\n/**\n * Default starting size.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprivate static final int DEFAULT_EXPECTED_SIZE = 16;\n/**\n * Multiplier for size growth when map fills up.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprivate static final int RESIZE_MULTIPLIER = 2;\n/**\n * Number of bits to perturb the index when probing for collision resolution.\n */\nprivate static final int PERTURB_SHIFT = 5;\n/**\n * Keys table.\n */\nprivate int[] keys;\n/**\n * Values table.\n */\nprivate Object[] values;\n/**\n * States table.\n */\nprivate byte[] states;\n/**\n * Return value for missing entries.\n */\nprivate final T missingEntries;\n/**\n * Current size of the map.\n */\nprivate int size;\n/**\n * Bit mask for hash values.\n */\nprivate int mask;\n/**\n * Modifications count.\n */\nprivate transient int count;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "5",
      "Filed": "private int[] keys;private int size;",
      "Parameter_type": "",
      "Import_statements": "",
      "public_method_signature": "public IntObjectHashMap();\npublic IntObjectHashMap(final T missingEntries);\npublic IntObjectHashMap(final int expectedSize);\npublic IntObjectHashMap(final int expectedSize, final T missingEntries);\npublic IntObjectHashMap(final IntObjectHashMap source);\npublic T get(final int key);\npublic boolean containsKey(final int key);\npublic Iterator iterator();\npublic int size();\npublic T remove(final int key);\npublic void clear();\npublic T put(final int key, final Object value);\npublic int[] keys();",
      "public_field": "",
      "Method_statement": "keys()",
      "Method_name": "keys",
      "Class_declaration": "public class IntObjectHashMap {\n",
      "constructors": "public IntObjectHashMap() {\n    this(DEFAULT_EXPECTED_SIZE, null);\n}public IntObjectHashMap(final T missingEntries) {\n    this(DEFAULT_EXPECTED_SIZE, missingEntries);\n}public IntObjectHashMap(final int expectedSize) {\n    this(expectedSize, null);\n}public IntObjectHashMap(final int expectedSize, final T missingEntries) {\n    final int capacity = computeCapacity(expectedSize);\n    keys = new int[capacity];\n    values = new Object[capacity];\n    states = new byte[capacity];\n    this.missingEntries = missingEntries;\n    size = 0;\n    mask = capacity - 1;\n    count = 0;\n}public IntObjectHashMap(final IntObjectHashMap source) {\n    final int length = source.keys.length;\n    keys = new int[length];\n    System.arraycopy(source.keys, 0, keys, 0, length);\n    values = new Object[length];\n    System.arraycopy(source.values, 0, values, 0, length);\n    states = new byte[length];\n    System.arraycopy(source.states, 0, states, 0, length);\n    missingEntries = (T) source.missingEntries;\n    size = source.size;\n    mask = source.mask;\n    count = source.count;\n}",
      "all_method_signature": "public IntObjectHashMap();\npublic IntObjectHashMap(final T missingEntries);\npublic IntObjectHashMap(final int expectedSize);\npublic IntObjectHashMap(final int expectedSize, final T missingEntries);\npublic IntObjectHashMap(final IntObjectHashMap source);\nprivate static int computeCapacity(final int expectedSize);\nprivate static int nextPowerOfTwo(final int i);\npublic T get(final int key);\npublic boolean containsKey(final int key);\npublic Iterator iterator();\nprivate static int perturb(final int hash);\nprivate int findInsertionIndex(final int key);\nprivate static int findInsertionIndex(final int[] keys, final byte[] states, final int key, final int mask);\nprivate static int probe(final int perturb, final int j);\nprivate static int changeIndexSign(final int index);\npublic int size();\npublic T remove(final int key);\npublic void clear();\nprivate boolean containsKey(final int key, final int index);\nprivate T doRemove(int index);\npublic T put(final int key, final Object value);\nprivate void growTable();\nprivate boolean shouldGrowTable();\nprivate static int hashOf(final int key);\nprivate void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException;\npublic int[] keys();",
      "Class_name": "IntObjectHashMap",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java/edu/jhu/prim/map/IntObjectHashMap###keys",
      "Parameter_num": "0",
      "all_Import_statements": "import java.io.IOException;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.Serializable;\n\nimport java.util.Arrays;\n\nimport java.util.ConcurrentModificationException;\n\nimport java.util.NoSuchElementException;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "method_signature": "public int[] keys();",
      "Junit_version": "4",
      "returnType": "int[]"
    },
    "Test_method": {
      "Method_body": "IntObjectHashMap<Integer> map = new IntObjectHashMap<Integer>();\n\rmap.put(2, 22);\n\rmap.put(5, 55);\n\rmap.put(7, 77);\n\rIntJUnitUtils.assertArrayEquals(new int[] { 2, 5, 7 }, map.keys());",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "5",
      "Filed": "",
      "Import_statements": "import edu.jhu.prim.util.IntJUnitUtils;\n",
      "allMethod_info": "@Test\npublic void testKeys() {\n    IntObjectHashMap<Integer> map = new IntObjectHashMap<Integer>();\n    map.put(2, 22);\n    map.put(5, 55);\n    map.put(7, 77);\n    IntJUnitUtils.assertArrayEquals(new int[] { 2, 5, 7 }, map.keys());\n}",
      "Method_name": "testKeys",
      "Class_declaration": "public class IntObjectHashMapTest {\n",
      "constructors": "",
      "Class_name": "IntObjectHashMapTest",
      "methodName_paraNum": "[put(2), put(2), put(2), keys(0)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java/edu/jhu/prim/map/IntObjectHashMapTest###testKeys",
      "relativePath": "mgormley_prim/src/test/java/edu/jhu/prim/map/IntObjectHashMapTest.java",
      "Signature": "public void testKeys() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\nimport edu.jhu.prim.util.IntJUnitUtils;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic boolean release(Integer e) {\n    int i = e;\n    if (i >= start && i < next && (i - start) % step == 0) {\n        return released.add(i);\n    }\n    return false;\n}",
      "all_field_declaration": "private final IntList released;\nprivate final int start, step;\nprivate int next;",
      "sub_project_name": "XDean_Java-EX",
      "lineNumbers": "3",
      "Filed": "private final IntList released;private final int start, step;private int next;",
      "Parameter_type": "Integer",
      "Import_statements": "",
      "public_method_signature": "public static IntSequence create(int start, int step);\npublic boolean hasNext();\npublic Integer next();\npublic boolean release(Integer e);",
      "public_field": "",
      "Method_statement": "release(Integer e)",
      "Method_name": "release",
      "Class_declaration": "public class IntSequence {\n",
      "constructors": "private IntSequence(int start, int step) {\n    this.released = IntList.create();\n    this.start = start;\n    this.step = step;\n    this.next = start;\n}",
      "all_method_signature": "public static IntSequence create(int start, int step);\nprivate IntSequence(int start, int step);\npublic boolean hasNext();\npublic Integer next();\npublic boolean release(Integer e);",
      "Class_name": "IntSequence",
      "project_path": "XDean_Java-EX###XDean_Java-EX/src/main/java/cn/xdean/jex/lang/collection/sequence/IntSequence###release",
      "Parameter_num": "1",
      "all_Import_statements": "import cn.xdean.jex.lang.collection.IntList;\n",
      "comment": "",
      "packageName": "cn.xdean.jex.lang.collection.sequence",
      "method_signature": "public boolean release(Integer e);",
      "Junit_version": "4",
      "returnType": "boolean"
    },
    "Test_method": {
      "Method_body": "IntSequence is = IntSequence.create(0, 1);\n\rassertEquals(0, is.next().intValue());\n\rassertEquals(1, is.next().intValue());\n\rassertEquals(2, is.next().intValue());\n\rassertEquals(3, is.next().intValue());\n\ris.release(0);\n\ris.release(3);\n\rassertEquals(0, is.next().intValue());\n\rassertEquals(3, is.next().intValue());\n\rassertEquals(4, is.next().intValue());",
      "sub_project_name": "XDean_Java-EX",
      "lineNumbers": "10",
      "Filed": "",
      "Import_statements": "",
      "allMethod_info": "@Test\npublic void testRelease() throws Exception {\n    IntSequence is = IntSequence.create(0, 1);\n    assertEquals(0, is.next().intValue());\n    assertEquals(1, is.next().intValue());\n    assertEquals(2, is.next().intValue());\n    assertEquals(3, is.next().intValue());\n    is.release(0);\n    is.release(3);\n    assertEquals(0, is.next().intValue());\n    assertEquals(3, is.next().intValue());\n    assertEquals(4, is.next().intValue());\n}",
      "Method_name": "testRelease",
      "Class_declaration": "public class IntSequenceTest {\n",
      "constructors": "",
      "Class_name": "IntSequenceTest",
      "methodName_paraNum": "[create(2), intValue(0), next(0), intValue(0), next(0), intValue(0), next(0), intValue(0), next(0), release(1), release(1), intValue(0), next(0), intValue(0), next(0), intValue(0), next(0)]",
      "project_path": "XDean_Java-EX###XDean_Java-EX/src/test/java/cn/xdean/jex/lang/collection/sequence/IntSequenceTest###testRelease",
      "relativePath": "XDean_Java-EX/src/test/java/cn/xdean/jex/lang/collection/sequence/IntSequenceTest.java",
      "Signature": "public void testRelease() {\n",
      "all_Import_statements": "import io.reactivex.Flowable;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n",
      "comment": "",
      "packageName": "cn.xdean.jex.lang.collection.sequence",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static Key generateKey(final SecureRandom random) {\n    final byte[] signingKey = new byte[signingKeyBytes];\n    random.nextBytes(signingKey);\n    final byte[] encryptionKey = new byte[encryptionKeyBytes];\n    random.nextBytes(encryptionKey);\n    return new Key(signingKey, encryptionKey);\n}",
      "all_field_declaration": "private final byte[] signingKey;\nprivate final byte[] encryptionKey;",
      "sub_project_name": "fernet-java8",
      "lineNumbers": "5",
      "Filed": "private final byte[] signingKey;private final byte[] encryptionKey;",
      "Parameter_type": "SecureRandom",
      "Import_statements": "import static com.macasaet.fernet.Constants.encryptionKeyBytes;\nimport static com.macasaet.fernet.Constants.signingKeyBytes;\nimport java.security.SecureRandom;\n",
      "public_method_signature": "public Key(final byte[] signingKey, final byte[] encryptionKey);\npublic Key(final byte[] concatenatedKeys);\npublic Key(final String string);\npublic static Key generateKey();\npublic static Key generateKey(final SecureRandom random);\npublic byte[] sign(final byte version, final Instant timestamp, final IvParameterSpec initializationVector, final byte[] cipherText);\npublic byte[] encrypt(final byte[] payload, final IvParameterSpec initializationVector);\npublic String serialise();\npublic void writeTo(final OutputStream outputStream) throws IOException;\npublic int hashCode();\npublic boolean equals(final Object obj);",
      "public_field": "",
      "Method_statement": "generateKey(final SecureRandom random)",
      "Method_name": "generateKey",
      "Class_declaration": "public class Key {\n",
      "constructors": "public Key(final byte[] signingKey, final byte[] encryptionKey) {\n    if (signingKey == null || signingKey.length != signingKeyBytes) {\n        throw new IllegalArgumentException(\"Signing key must be 128 bits\");\n    }\n    if (encryptionKey == null || encryptionKey.length != encryptionKeyBytes) {\n        throw new IllegalArgumentException(\"Encryption key must be 128 bits\");\n    }\n    this.signingKey = copyOf(signingKey, signingKeyBytes);\n    this.encryptionKey = copyOf(encryptionKey, encryptionKeyBytes);\n}public Key(final byte[] concatenatedKeys) {\n    this(copyOfRange(concatenatedKeys, 0, signingKeyBytes), copyOfRange(concatenatedKeys, signingKeyBytes, fernetKeyBytes));\n}public Key(final String string) {\n    this(decoder.decode(string));\n}",
      "all_method_signature": "public Key(final byte[] signingKey, final byte[] encryptionKey);\npublic Key(final byte[] concatenatedKeys);\npublic Key(final String string);\npublic static Key generateKey();\npublic static Key generateKey(final SecureRandom random);\npublic byte[] sign(final byte version, final Instant timestamp, final IvParameterSpec initializationVector, final byte[] cipherText);\npublic byte[] encrypt(final byte[] payload, final IvParameterSpec initializationVector);\nprotected byte[] decrypt(final byte[] cipherText, final IvParameterSpec initializationVector);\npublic String serialise();\npublic void writeTo(final OutputStream outputStream) throws IOException;\npublic int hashCode();\npublic boolean equals(final Object obj);\nprotected byte[] sign(final byte version, final Instant timestamp, final IvParameterSpec initializationVector, final byte[] cipherText, final ByteArrayOutputStream byteStream) throws IOException;\nprotected java.security.Key getSigningKeySpec();\nprotected SecretKeySpec getEncryptionKeySpec();\nprotected byte[] getSigningKey();\nprotected byte[] getEncryptionKey();\nprotected int getTokenPrefixBytes();\nprotected String getSigningAlgorithm();\nprotected String getEncryptionAlgorithm();\nprotected Encoder getEncoder();\nprotected String getCipherTransformation();",
      "Class_name": "Key",
      "project_path": "l0s_fernet-java8###l0s_fernet-java8/fernet-java8/src/main/java/com/macasaet/fernet/Key###generateKey",
      "Parameter_num": "1",
      "all_Import_statements": "import static com.macasaet.fernet.Constants.cipherTransformation;\n\nimport static com.macasaet.fernet.Constants.decoder;\n\nimport static com.macasaet.fernet.Constants.encoder;\n\nimport static com.macasaet.fernet.Constants.encryptionAlgorithm;\n\nimport static com.macasaet.fernet.Constants.encryptionKeyBytes;\n\nimport static com.macasaet.fernet.Constants.fernetKeyBytes;\n\nimport static com.macasaet.fernet.Constants.signingAlgorithm;\n\nimport static com.macasaet.fernet.Constants.signingKeyBytes;\n\nimport static com.macasaet.fernet.Constants.tokenPrefixBytes;\n\nimport static java.util.Arrays.copyOf;\n\nimport static java.util.Arrays.copyOfRange;\n\nimport static javax.crypto.Cipher.DECRYPT_MODE;\n\nimport static javax.crypto.Cipher.ENCRYPT_MODE;\n\nimport java.io.ByteArrayOutputStream;\n\nimport java.io.DataOutputStream;\n\nimport java.io.IOException;\n\nimport java.io.OutputStream;\n\nimport java.security.InvalidAlgorithmParameterException;\n\nimport java.security.InvalidKeyException;\n\nimport java.security.MessageDigest;\n\nimport java.security.NoSuchAlgorithmException;\n\nimport java.security.SecureRandom;\n\nimport java.time.Instant;\n\nimport java.util.Arrays;\n\nimport java.util.Base64.Encoder;\n\nimport javax.crypto.BadPaddingException;\n\nimport javax.crypto.Cipher;\n\nimport javax.crypto.IllegalBlockSizeException;\n\nimport javax.crypto.Mac;\n\nimport javax.crypto.NoSuchPaddingException;\n\nimport javax.crypto.spec.IvParameterSpec;\n\nimport javax.crypto.spec.SecretKeySpec;\n",
      "comment": "\n     * Generate a random key\n     *\n     * @param random\n     *            source of entropy\n     * @return a new shared secret key\n     ",
      "packageName": "com.macasaet.fernet",
      "method_signature": "public static Key generateKey(final SecureRandom random);",
      "Junit_version": "4",
      "returnType": "Key"
    },
    "Test_method": {
      "Method_body": "// given\nfinal SecureRandom deterministicRandom = new SecureRandom() {\n\n    private static final long serialVersionUID = 6548702184401342900L;\n\n    public void nextBytes(final byte[] bytes) {\n        for (int i = signingKeyBytes; --i >= 0; bytes[i] = 1) ;\n    }\n};\n\r// when\nfinal Key result = Key.generateKey(deterministicRandom);\n\r// then\nfinal byte[] signingKey = result.getSigningKeySpec().getEncoded();\n\rfor (int i = signingKeyBytes; --i >= 0; ) {\n    assertEquals(1, signingKey[i]);\n}\n\rfinal byte[] encryptionKey = result.getEncryptionKeySpec().getEncoded();\n\rfor (int i = encryptionKeyBytes; --i >= 0; ) {\n    assertEquals(1, encryptionKey[i]);\n}",
      "sub_project_name": "fernet-java8",
      "lineNumbers": "6",
      "Filed": "",
      "Import_statements": "import static com.macasaet.fernet.Constants.encryptionKeyBytes;\nimport static com.macasaet.fernet.Constants.signingKeyBytes;\nimport static org.junit.Assert.assertEquals;\nimport java.security.SecureRandom;\n",
      "allMethod_info": "@Test\npublic void testGenerateKey() {\n    // given\n    final SecureRandom deterministicRandom = new SecureRandom() {\n\n        private static final long serialVersionUID = 6548702184401342900L;\n\n        public void nextBytes(final byte[] bytes) {\n            for (int i = signingKeyBytes; --i >= 0; bytes[i] = 1) ;\n        }\n    };\n    // when\n    final Key result = Key.generateKey(deterministicRandom);\n    // then\n    final byte[] signingKey = result.getSigningKeySpec().getEncoded();\n    for (int i = signingKeyBytes; --i >= 0; ) {\n        assertEquals(1, signingKey[i]);\n    }\n    final byte[] encryptionKey = result.getEncryptionKeySpec().getEncoded();\n    for (int i = encryptionKeyBytes; --i >= 0; ) {\n        assertEquals(1, encryptionKey[i]);\n    }\n}",
      "Method_name": "testGenerateKey",
      "Class_declaration": "public class KeyTest {\n",
      "constructors": "",
      "Class_name": "KeyTest",
      "methodName_paraNum": "[generateKey(1), getEncoded(0), getSigningKeySpec(0), getEncoded(0), getEncryptionKeySpec(0)]",
      "project_path": "l0s_fernet-java8###l0s_fernet-java8/fernet-java8/src/test/java/com/macasaet/fernet/KeyTest###testGenerateKey",
      "relativePath": "l0s_fernet-java8/fernet-java8/src/test/java/com/macasaet/fernet/KeyTest.java",
      "Signature": "public void testGenerateKey() {\n",
      "all_Import_statements": "import static com.macasaet.fernet.Constants.encoder;\n\nimport static com.macasaet.fernet.Constants.encryptionKeyBytes;\n\nimport static com.macasaet.fernet.Constants.signingKeyBytes;\n\nimport static nl.jqno.equalsverifier.Warning.ALL_FIELDS_SHOULD_BE_USED;\n\nimport static nl.jqno.equalsverifier.Warning.STRICT_INHERITANCE;\n\nimport static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport static org.mutabilitydetector.unittesting.AllowedReason.allowingForSubclassing;\n\nimport static org.mutabilitydetector.unittesting.AllowedReason.assumingFields;\n\nimport static org.mutabilitydetector.unittesting.MutabilityAssert.assertInstancesOf;\n\nimport static org.mutabilitydetector.unittesting.MutabilityMatchers.areImmutable;\n\nimport java.security.SecureRandom;\n\nimport java.time.Instant;\n\nimport javax.crypto.spec.IvParameterSpec;\n\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.junit.Test;\n\nimport nl.jqno.equalsverifier.EqualsVerifier;\n\nimport nl.jqno.equalsverifier.api.SingleTypeEqualsVerifierApi;\n",
      "comment": "",
      "packageName": "com.macasaet.fernet",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static Location fromCoordinates(String coordinates) {\n    if (coordinates == null) {\n        throw new IllegalArgumentException(\"Cannot create Location from null input.\");\n    }\n    Matcher m = P.matcher(coordinates);\n    if (!m.matches()) {\n        throw new IllegalArgumentException(coordinates + \" must be on the pattern (longitude,latitude,altitude) : \" + P.pattern());\n    }\n    try {\n        Double longitude = Double.valueOf(m.group(1));\n        Double latitude = Double.valueOf(m.group(2));\n        Integer altitude = 0;\n        if (m.group(3) != null) {\n            altitude = Integer.valueOf(m.group(3).substring(1));\n        }\n        return new Location(longitude, latitude, altitude, \"\");\n    } catch (NumberFormatException e) {\n        throw new IllegalArgumentException(coordinates + \" must be on the pattern (longitude,latitude,altitude) : \" + P.pattern());\n    }\n}",
      "all_field_declaration": "private static Pattern P = Pattern.compile(\"(\\\\d{1,3}\\\\.\\\\d{1,3}),(\\\\d{1,3}\\\\.\\\\d{1,3})(,\\\\d{1,4})?\");\n@JsonProperty\nprivate final String name;\n@NotNull\n@NotNegative\n@JsonProperty\nprivate final Double longitude;\n@NotNull\n@NotNegative\n@JsonProperty\nprivate final Double latitude;\n@NotNegative\n@JsonProperty\nprivate final Integer altitude;",
      "sub_project_name": "meteo-core",
      "lineNumbers": "4",
      "Filed": "private static Pattern P = Pattern.compile(\"(\\\\d{1,3}\\\\.\\\\d{1,3}),(\\\\d{1,3}\\\\.\\\\d{1,3})(,\\\\d{1,4})?\");@NotNull\n@NotNegative\n@JsonProperty\nprivate final Double longitude;@NotNull\n@NotNegative\n@JsonProperty\nprivate final Double latitude;@NotNegative\n@JsonProperty\nprivate final Integer altitude;",
      "Parameter_type": "String",
      "Import_statements": "import java.util.regex.Matcher;\n",
      "public_method_signature": "public Location(@JsonProperty(\"longitude\") Double longitude, @JsonProperty(\"latitude\") Double latitude, @JsonProperty(\"altitude\") Integer altitude, @JsonProperty(\"name\") String name);\npublic static Location fromCoordinates(String coordinates);",
      "public_field": "",
      "Method_statement": "fromCoordinates(String coordinates)",
      "Method_name": "fromCoordinates",
      "Class_declaration": "public class Location {\n",
      "constructors": "@JsonCreator\npublic Location(@JsonProperty(\"longitude\") Double longitude, @JsonProperty(\"latitude\") Double latitude, @JsonProperty(\"altitude\") Integer altitude, @JsonProperty(\"name\") String name) {\n    this.longitude = longitude;\n    this.latitude = latitude;\n    this.altitude = altitude;\n    this.name = name;\n}",
      "all_method_signature": "public Location(@JsonProperty(\"longitude\") Double longitude, @JsonProperty(\"latitude\") Double latitude, @JsonProperty(\"altitude\") Integer altitude, @JsonProperty(\"name\") String name);\npublic static Location fromCoordinates(String coordinates);",
      "Class_name": "Location",
      "project_path": "lazee_meteo###lazee_meteo/meteo-core/src/main/java/no/api/meteo/entity/core/Location###fromCoordinates",
      "Parameter_num": "1",
      "all_Import_statements": "import com.fasterxml.jackson.annotation.JsonCreator;\n\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\nimport lombok.Data;\n\nimport net.sf.oval.constraint.NotNegative;\n\nimport net.sf.oval.constraint.NotNull;\n\nimport java.util.regex.Matcher;\n\nimport java.util.regex.Pattern;\n",
      "comment": "\n     * Create an untitled Location from coordinate string.\n     *\n     * @param coordinates Coordinate string on the format longitude,latitude,altitude. Eg: 20.3,123.3,123 or 20.3,123.3\n     * @return Instance of the location with the coordinates from the input string.\n     ",
      "packageName": "no.api.meteo.entity.core",
      "method_signature": "public static Location fromCoordinates(String coordinates);",
      "Junit_version": "4",
      "returnType": "Location"
    },
    "Test_method": {
      "Method_body": "Location location = Location.fromCoordinates(\"12.2,34.8,120\");\n\rAssert.assertEquals(12.2, location.getLongitude(), 0.0);\n\rAssert.assertEquals(34.8, location.getLatitude(), 0.0);\n\rAssert.assertEquals(new Integer(120), location.getAltitude());",
      "sub_project_name": "meteo-core",
      "lineNumbers": "4",
      "Filed": "",
      "Import_statements": "import org.junit.Assert;\n",
      "allMethod_info": "@Test\npublic void testFromCoordinates() throws Exception {\n    Location location = Location.fromCoordinates(\"12.2,34.8,120\");\n    Assert.assertEquals(12.2, location.getLongitude(), 0.0);\n    Assert.assertEquals(34.8, location.getLatitude(), 0.0);\n    Assert.assertEquals(new Integer(120), location.getAltitude());\n}",
      "Method_name": "testFromCoordinates",
      "Class_declaration": "public class LocationTest {\n",
      "constructors": "",
      "Class_name": "LocationTest",
      "methodName_paraNum": "[fromCoordinates(1), getLongitude(0), getLatitude(0), getAltitude(0)]",
      "project_path": "lazee_meteo###lazee_meteo/meteo-core/src/test/java/no/api/meteo/entity/core/LocationTest###testFromCoordinates",
      "relativePath": "lazee_meteo/meteo-core/src/test/java/no/api/meteo/entity/core/LocationTest.java",
      "Signature": "public void testFromCoordinates() {\n",
      "all_Import_statements": "import org.junit.Assert;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "no.api.meteo.entity.core",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public void uniq() {\n    if (size <= 1) {\n        return;\n    }\n    int cursor = 0;\n    for (int i = 1; i < size; i++) {\n        if (elements[cursor] != elements[i]) {\n            cursor++;\n            elements[cursor] = elements[i];\n        }\n    }\n    size = cursor + 1;\n}",
      "all_field_declaration": "private static final long serialVersionUID = 1L;\n/**\n * The internal array representing this list.\n */\nprotected long[] elements;\n/**\n * The number of elements in the list.\n */\nprotected int size;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "4",
      "Filed": "protected long[] elements;protected int size;",
      "Parameter_type": "",
      "Import_statements": "",
      "public_method_signature": "public LongArrayList();\npublic LongArrayList(long[] elements);\npublic LongArrayList(int initialCapacity);\npublic LongArrayList(LongArrayList other);\npublic void add(long value);\npublic long get(int i);\npublic void set(int i, long value);\npublic void add(long[] values);\npublic void add(LongArrayList values);\npublic int lookupIndex(long value);\npublic long[] toNativeArray();\npublic long[] elements();\npublic long[] getInternalElements();\npublic void trimToSize();\npublic static long[] ensureCapacity(long[] elements, int size);\npublic int size();\npublic boolean isEmpty();\npublic void clear();\npublic String toString();\npublic void sortAsc();\npublic void sortDesc();\npublic void uniq();\npublic int hashCode();\npublic boolean equals(Object obj);",
      "public_field": "",
      "Method_statement": "uniq()",
      "Method_name": "uniq",
      "Class_declaration": "public class LongArrayList {\n",
      "constructors": "public LongArrayList() {\n    this(8);\n}public LongArrayList(long[] elements) {\n    this.elements = elements;\n    this.size = elements.length;\n}public LongArrayList(int initialCapacity) {\n    elements = new long[initialCapacity];\n    size = 0;\n}public LongArrayList(LongArrayList other) {\n    this(other.size);\n    add(other);\n}",
      "all_method_signature": "public LongArrayList();\npublic LongArrayList(long[] elements);\npublic LongArrayList(int initialCapacity);\npublic LongArrayList(LongArrayList other);\npublic void add(long value);\npublic long get(int i);\npublic void set(int i, long value);\npublic void add(long[] values);\npublic void add(LongArrayList values);\npublic int lookupIndex(long value);\npublic long[] toNativeArray();\npublic long[] elements();\npublic long[] getInternalElements();\npublic void trimToSize();\nprivate void ensureCapacity(int size);\npublic static long[] ensureCapacity(long[] elements, int size);\npublic int size();\npublic boolean isEmpty();\npublic void clear();\npublic String toString();\npublic void sortAsc();\npublic void sortDesc();\npublic void uniq();\npublic int hashCode();\npublic boolean equals(Object obj);",
      "Class_name": "LongArrayList",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java/edu/jhu/prim/list/LongArrayList###uniq",
      "Parameter_num": "0",
      "all_Import_statements": "import java.io.Serializable;\n\nimport java.util.Arrays;\n\nimport edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.sort.LongSort;\n",
      "comment": " Removes all identical neighboring elements, resizing the array list accordingly. ",
      "packageName": "edu.jhu.prim.list",
      "method_signature": "public void uniq();",
      "Junit_version": "4",
      "returnType": "void"
    },
    "Test_method": {
      "Method_body": "LongArrayList list = new LongArrayList();\n\rlist.add(1);\n\rlist.add(1);\n\rlist.add(2);\n\rlist.add(2);\n\rlist.add(2);\n\rlist.add(3);\n\rlist.add(4);\n\rlist.add(4);\n\rlist.add(4);\n\rSystem.out.println(list);\n\rlist.uniq();\n\rSystem.out.println(list);\n\rassertEquals(4, list.size());\n\rassertEquals(list.get(0), 1);\n\rassertEquals(list.get(1), 2);\n\rassertEquals(list.get(2), 3);\n\rassertEquals(list.get(3), 4);",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "18",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "// Tests a list with multiple non-unique values.\n@Test\npublic void testUniq() throws Exception {\n    LongArrayList list = new LongArrayList();\n    list.add(1);\n    list.add(1);\n    list.add(2);\n    list.add(2);\n    list.add(2);\n    list.add(3);\n    list.add(4);\n    list.add(4);\n    list.add(4);\n    System.out.println(list);\n    list.uniq();\n    System.out.println(list);\n    assertEquals(4, list.size());\n    assertEquals(list.get(0), 1);\n    assertEquals(list.get(1), 2);\n    assertEquals(list.get(2), 3);\n    assertEquals(list.get(3), 4);\n}",
      "Method_name": "testUniq",
      "Class_declaration": "public class LongArrayListTest {\n",
      "constructors": "",
      "Class_name": "LongArrayListTest",
      "methodName_paraNum": "[add(1), add(1), add(1), add(1), add(1), add(1), add(1), add(1), add(1), println(1), uniq(0), println(1), size(0), get(1), get(1), get(1), get(1)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java/edu/jhu/prim/list/LongArrayListTest###testUniq",
      "relativePath": "mgormley_prim/src/test/java/edu/jhu/prim/list/LongArrayListTest.java",
      "Signature": "public void testUniq() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport org.junit.Test;\n",
      "comment": " Tests a list with multiple non-unique values.",
      "packageName": "edu.jhu.prim.list",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic boolean equals(Object obj) {\n    if (this == obj)\n        return true;\n    if (obj == null)\n        return false;\n    if (this.getClass() != obj.getClass())\n        return false;\n    LongDoubleHashMap other = (LongDoubleHashMap) obj;\n    if (this.size() != other.size()) {\n        return false;\n    }\n    for (int i = 0; i < keys.length; i++) {\n        if (states[i] == FULL) {\n            if (!other.contains(keys[i]))\n                return false;\n            if (other.get(keys[i]) != values[i])\n                return false;\n        }\n    }\n    return true;\n}",
      "all_field_declaration": "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;\n/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;\n/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;\n/**\n * Serializable version identifier\n */\nprivate static final long serialVersionUID = -3646337053166149105L;\n/**\n * Load factor for the map.\n */\nprivate static final float LOAD_FACTOR = 0.75f;\n/**\n * Default starting size.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprotected static final int DEFAULT_EXPECTED_SIZE = 16;\n/**\n * Multiplier for size growth when map fills up.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprivate static final int RESIZE_MULTIPLIER = 2;\n/**\n * Number of bits to perturb the index when probing for collision resolution.\n */\nprivate static final int PERTURB_SHIFT = 5;\n/**\n * Keys table.\n */\nprotected long[] keys;\n/**\n * Values table.\n */\nprotected double[] values;\n/**\n * States table.\n */\nprotected byte[] states;\n/**\n * Return value for missing entries.\n */\nprivate final double missingEntries;\n/**\n * Current size of the map.\n */\nprivate int size;\n/**\n * Bit mask for hash values.\n */\nprivate int mask;\n/**\n * Modifications count.\n */\nprivate transient int count;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "7",
      "Filed": "protected static final byte FULL = 1;protected long[] keys;protected double[] values;protected byte[] states;private int size;",
      "Parameter_type": "Object",
      "Import_statements": "",
      "public_method_signature": "public LongDoubleHashMap();\npublic LongDoubleHashMap(final int expectedSize);\npublic LongDoubleHashMap(final int expectedSize, final double missingEntries);\npublic LongDoubleHashMap(final LongDoubleHashMap source);\npublic LongDoubleHashMap(long[] keys, double[] vals);\npublic double get(final long key);\npublic double getWithDefault(long key, double missingEntries);\npublic boolean contains(final long key);\npublic Iterator<LongDoubleEntry> iterator();\npublic int size();\npublic void remove(final long key);\npublic double removeAndGet(final long key);\npublic void clear();\npublic double put(final long key, final double value);\npublic double putAndGet(final long key, final double value);\npublic void add(final long key, final double value);\npublic double addAndGet(final long key, final double value);\npublic long[] getIndices();\npublic double[] getValues();\npublic Pair<long[], double[]> getIndicesAndValues();\npublic void apply(FnLongDoubleToDouble lambda);\npublic void iterate(FnLongDoubleToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "public_field": "",
      "Method_statement": "equals(Object obj)",
      "Method_name": "equals",
      "Class_declaration": "public class LongDoubleHashMap {\n",
      "constructors": "public LongDoubleHashMap() {\n    this(DEFAULT_EXPECTED_SIZE, Primitives.DEFAULT_MISSING_ENTRY_DOUBLE);\n}public LongDoubleHashMap(final int expectedSize) {\n    this(expectedSize, Primitives.DEFAULT_MISSING_ENTRY_DOUBLE);\n}public LongDoubleHashMap(final int expectedSize, final double missingEntries) {\n    final int capacity = computeCapacity(expectedSize);\n    keys = new long[capacity];\n    values = new double[capacity];\n    states = new byte[capacity];\n    this.missingEntries = missingEntries;\n    size = 0;\n    mask = capacity - 1;\n    count = 0;\n}public LongDoubleHashMap(final LongDoubleHashMap source) {\n    final int length = source.keys.length;\n    keys = new long[length];\n    System.arraycopy(source.keys, 0, keys, 0, length);\n    values = new double[length];\n    System.arraycopy(source.values, 0, values, 0, length);\n    states = new byte[length];\n    System.arraycopy(source.states, 0, states, 0, length);\n    missingEntries = source.missingEntries;\n    size = source.size;\n    mask = source.mask;\n    count = source.count;\n}public LongDoubleHashMap(long[] keys, double[] vals) {\n    this(keys.length, Primitives.DEFAULT_MISSING_ENTRY_DOUBLE);\n    if (keys.length != vals.length) {\n        throw new IllegalStateException(\"keys and vals must be of the same length\");\n    }\n    for (int i = 0; i < keys.length; i++) {\n        this.put(keys[i], vals[i]);\n    }\n}",
      "all_method_signature": "public LongDoubleHashMap();\npublic LongDoubleHashMap(final int expectedSize);\npublic LongDoubleHashMap(final int expectedSize, final double missingEntries);\npublic LongDoubleHashMap(final LongDoubleHashMap source);\npublic LongDoubleHashMap(long[] keys, double[] vals);\nprivate static int computeCapacity(final int expectedSize);\nprivate static int nextPowerOfTwo(final int i);\npublic double get(final long key);\npublic double getWithDefault(long key, double missingEntries);\npublic boolean contains(final long key);\npublic Iterator<LongDoubleEntry> iterator();\nprivate static int perturb(final int hash);\nprivate int findInsertionIndex(final long key);\nprivate static int findInsertionIndex(final long[] keys, final byte[] states, final long key, final int mask);\nprivate static int probe(final int perturb, final int j);\nprivate static int changeIndexSign(final int index);\npublic int size();\npublic void remove(final long key);\npublic double removeAndGet(final long key);\npublic void clear();\nprivate boolean contains(final long key, final int index);\nprivate double doRemove(int index);\npublic double put(final long key, final double value);\npublic double putAndGet(final long key, final double value);\npublic void add(final long key, final double value);\npublic double addAndGet(final long key, final double value);\nprivate void growTable();\nprivate boolean shouldGrowTable();\nprivate static int hashOf(final long key);\nprivate void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException;\npublic long[] getIndices();\npublic double[] getValues();\npublic Pair<long[], double[]> getIndicesAndValues();\npublic void apply(FnLongDoubleToDouble lambda);\npublic void iterate(FnLongDoubleToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "Class_name": "LongDoubleHashMap",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java/edu/jhu/prim/map/LongDoubleHashMap###equals",
      "Parameter_num": "1",
      "all_Import_statements": "import java.io.IOException;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.Serializable;\n\nimport java.util.Arrays;\n\nimport java.util.ConcurrentModificationException;\n\nimport java.util.Iterator;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.Map.Entry;\n\nimport edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.sort.LongDoubleSort;\n\nimport edu.jhu.prim.tuple.Pair;\n\nimport edu.jhu.prim.util.Lambda.FnLongDoubleToDouble;\n\nimport edu.jhu.prim.util.Lambda.FnLongDoubleToVoid;\n\nimport edu.jhu.prim.vector.AbstractLongDoubleVector;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "method_signature": "public boolean equals(Object obj);",
      "Junit_version": "4",
      "returnType": "boolean"
    },
    "Test_method": {
      "Method_body": "LongDoubleHashMap m1 = new LongDoubleHashMap();\n\rLongDoubleHashMap m2 = new LongDoubleHashMap();\n\rassertTrue(m1.equals(m2));\n\rm1.put(2, toDouble(22));\n\rm1.put(1, toDouble(11));\n\rassertFalse(m1.equals(m2));\n\rm2.put(1, toDouble(11));\n\rm2.put(2, toDouble(22));\n\rassertTrue(m1.equals(m2));\n\rm2.put(3, toDouble(33));\n\rassertFalse(m1.equals(m2));\n\rm1.put(3, toDouble(33));\n\rassertTrue(m1.equals(m2));",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "13",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toDouble;\n",
      "allMethod_info": "@Test\npublic void testEquals() throws Exception {\n    LongDoubleHashMap m1 = new LongDoubleHashMap();\n    LongDoubleHashMap m2 = new LongDoubleHashMap();\n    assertTrue(m1.equals(m2));\n    m1.put(2, toDouble(22));\n    m1.put(1, toDouble(11));\n    assertFalse(m1.equals(m2));\n    m2.put(1, toDouble(11));\n    m2.put(2, toDouble(22));\n    assertTrue(m1.equals(m2));\n    m2.put(3, toDouble(33));\n    assertFalse(m1.equals(m2));\n    m1.put(3, toDouble(33));\n    assertTrue(m1.equals(m2));\n}",
      "Method_name": "testEquals",
      "Class_declaration": "public class LongDoubleHashMapTest {\n",
      "constructors": "",
      "Class_name": "LongDoubleHashMapTest",
      "methodName_paraNum": "[equals(1), put(2), toDouble(1), put(2), toDouble(1), equals(1), put(2), toDouble(1), put(2), toDouble(1), equals(1), put(2), toDouble(1), equals(1), put(2), toDouble(1), equals(1)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java/edu/jhu/prim/map/LongDoubleHashMapTest###testEquals",
      "relativePath": "mgormley_prim/src/test/java/edu/jhu/prim/map/LongDoubleHashMapTest.java",
      "Signature": "public void testEquals() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toDouble;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static edu.jhu.prim.Primitives.toLong;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n\nimport edu.jhu.prim.Primitives;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic int hashCode() {\n    int h = 0;\n    long[] indices = getIndices();\n    double[] values = getValues();\n    LongDoubleSort.sortIndexAsc(indices, values);\n    for (int i = 0; i < indices.length; i++) {\n        int result = 17;\n        result = 37 * result + Primitives.hashOfLong(indices[i]);\n        result = 37 * result + Primitives.hashOfDouble(values[i]);\n        h += result;\n    }\n    return h;\n}",
      "all_field_declaration": "/**\n * Status indicator for free table entries.\n */\nprotected static final byte FREE = 0;\n/**\n * Status indicator for full table entries.\n */\nprotected static final byte FULL = 1;\n/**\n * Status indicator for removed table entries.\n */\nprotected static final byte REMOVED = 2;\n/**\n * Serializable version identifier\n */\nprivate static final long serialVersionUID = -3646337053166149105L;\n/**\n * Load factor for the map.\n */\nprivate static final float LOAD_FACTOR = 0.75f;\n/**\n * Default starting size.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprotected static final int DEFAULT_EXPECTED_SIZE = 16;\n/**\n * Multiplier for size growth when map fills up.\n * <p>This must be a power of two for bit mask to work properly. </p>\n */\nprivate static final int RESIZE_MULTIPLIER = 2;\n/**\n * Number of bits to perturb the index when probing for collision resolution.\n */\nprivate static final int PERTURB_SHIFT = 5;\n/**\n * Keys table.\n */\nprotected long[] keys;\n/**\n * Values table.\n */\nprotected double[] values;\n/**\n * States table.\n */\nprotected byte[] states;\n/**\n * Return value for missing entries.\n */\nprivate final double missingEntries;\n/**\n * Current size of the map.\n */\nprivate int size;\n/**\n * Bit mask for hash values.\n */\nprivate int mask;\n/**\n * Modifications count.\n */\nprivate transient int count;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "6",
      "Filed": "protected double[] values;",
      "Parameter_type": "",
      "Import_statements": "import edu.jhu.prim.Primitives;\nimport edu.jhu.prim.sort.LongDoubleSort;\n",
      "public_method_signature": "public LongDoubleHashMap();\npublic LongDoubleHashMap(final int expectedSize);\npublic LongDoubleHashMap(final int expectedSize, final double missingEntries);\npublic LongDoubleHashMap(final LongDoubleHashMap source);\npublic LongDoubleHashMap(long[] keys, double[] vals);\npublic double get(final long key);\npublic double getWithDefault(long key, double missingEntries);\npublic boolean contains(final long key);\npublic Iterator<LongDoubleEntry> iterator();\npublic int size();\npublic void remove(final long key);\npublic double removeAndGet(final long key);\npublic void clear();\npublic double put(final long key, final double value);\npublic double putAndGet(final long key, final double value);\npublic void add(final long key, final double value);\npublic double addAndGet(final long key, final double value);\npublic long[] getIndices();\npublic double[] getValues();\npublic Pair<long[], double[]> getIndicesAndValues();\npublic void apply(FnLongDoubleToDouble lambda);\npublic void iterate(FnLongDoubleToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "public_field": "",
      "Method_statement": "hashCode()",
      "Method_name": "hashCode",
      "Class_declaration": "public class LongDoubleHashMap {\n",
      "constructors": "public LongDoubleHashMap() {\n    this(DEFAULT_EXPECTED_SIZE, Primitives.DEFAULT_MISSING_ENTRY_DOUBLE);\n}public LongDoubleHashMap(final int expectedSize) {\n    this(expectedSize, Primitives.DEFAULT_MISSING_ENTRY_DOUBLE);\n}public LongDoubleHashMap(final int expectedSize, final double missingEntries) {\n    final int capacity = computeCapacity(expectedSize);\n    keys = new long[capacity];\n    values = new double[capacity];\n    states = new byte[capacity];\n    this.missingEntries = missingEntries;\n    size = 0;\n    mask = capacity - 1;\n    count = 0;\n}public LongDoubleHashMap(final LongDoubleHashMap source) {\n    final int length = source.keys.length;\n    keys = new long[length];\n    System.arraycopy(source.keys, 0, keys, 0, length);\n    values = new double[length];\n    System.arraycopy(source.values, 0, values, 0, length);\n    states = new byte[length];\n    System.arraycopy(source.states, 0, states, 0, length);\n    missingEntries = source.missingEntries;\n    size = source.size;\n    mask = source.mask;\n    count = source.count;\n}public LongDoubleHashMap(long[] keys, double[] vals) {\n    this(keys.length, Primitives.DEFAULT_MISSING_ENTRY_DOUBLE);\n    if (keys.length != vals.length) {\n        throw new IllegalStateException(\"keys and vals must be of the same length\");\n    }\n    for (int i = 0; i < keys.length; i++) {\n        this.put(keys[i], vals[i]);\n    }\n}",
      "all_method_signature": "public LongDoubleHashMap();\npublic LongDoubleHashMap(final int expectedSize);\npublic LongDoubleHashMap(final int expectedSize, final double missingEntries);\npublic LongDoubleHashMap(final LongDoubleHashMap source);\npublic LongDoubleHashMap(long[] keys, double[] vals);\nprivate static int computeCapacity(final int expectedSize);\nprivate static int nextPowerOfTwo(final int i);\npublic double get(final long key);\npublic double getWithDefault(long key, double missingEntries);\npublic boolean contains(final long key);\npublic Iterator<LongDoubleEntry> iterator();\nprivate static int perturb(final int hash);\nprivate int findInsertionIndex(final long key);\nprivate static int findInsertionIndex(final long[] keys, final byte[] states, final long key, final int mask);\nprivate static int probe(final int perturb, final int j);\nprivate static int changeIndexSign(final int index);\npublic int size();\npublic void remove(final long key);\npublic double removeAndGet(final long key);\npublic void clear();\nprivate boolean contains(final long key, final int index);\nprivate double doRemove(int index);\npublic double put(final long key, final double value);\npublic double putAndGet(final long key, final double value);\npublic void add(final long key, final double value);\npublic double addAndGet(final long key, final double value);\nprivate void growTable();\nprivate boolean shouldGrowTable();\nprivate static int hashOf(final long key);\nprivate void readObject(final ObjectInputStream stream) throws IOException, ClassNotFoundException;\npublic long[] getIndices();\npublic double[] getValues();\npublic Pair<long[], double[]> getIndicesAndValues();\npublic void apply(FnLongDoubleToDouble lambda);\npublic void iterate(FnLongDoubleToVoid lambda);\npublic int hashCode();\npublic boolean equals(Object obj);",
      "Class_name": "LongDoubleHashMap",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java/edu/jhu/prim/map/LongDoubleHashMap###hashCode",
      "Parameter_num": "0",
      "all_Import_statements": "import java.io.IOException;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.Serializable;\n\nimport java.util.Arrays;\n\nimport java.util.ConcurrentModificationException;\n\nimport java.util.Iterator;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.Map.Entry;\n\nimport edu.jhu.prim.Primitives;\n\nimport edu.jhu.prim.sort.LongDoubleSort;\n\nimport edu.jhu.prim.tuple.Pair;\n\nimport edu.jhu.prim.util.Lambda.FnLongDoubleToDouble;\n\nimport edu.jhu.prim.util.Lambda.FnLongDoubleToVoid;\n\nimport edu.jhu.prim.vector.AbstractLongDoubleVector;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "method_signature": "public int hashCode();",
      "Junit_version": "4",
      "returnType": "int"
    },
    "Test_method": {
      "Method_body": "LongDoubleHashMap m1 = new LongDoubleHashMap();\n\rLongDoubleHashMap m2 = new LongDoubleHashMap();\n\rassertEquals(m1.hashCode(), m2.hashCode());\n\rm1.put(2, toDouble(22));\n\rm1.put(1, toDouble(11));\n\rm2.put(1, toDouble(11));\n\rm2.put(2, toDouble(22));\n\rassertEquals(m1.hashCode(), m2.hashCode());\n\rm2.put(3, toDouble(33));\n\rm1.put(3, toDouble(33));\n\rassertEquals(m1.hashCode(), m2.hashCode());",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "11",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toDouble;\n",
      "allMethod_info": "@Test\npublic void testHashCode() throws Exception {\n    LongDoubleHashMap m1 = new LongDoubleHashMap();\n    LongDoubleHashMap m2 = new LongDoubleHashMap();\n    assertEquals(m1.hashCode(), m2.hashCode());\n    m1.put(2, toDouble(22));\n    m1.put(1, toDouble(11));\n    m2.put(1, toDouble(11));\n    m2.put(2, toDouble(22));\n    assertEquals(m1.hashCode(), m2.hashCode());\n    m2.put(3, toDouble(33));\n    m1.put(3, toDouble(33));\n    assertEquals(m1.hashCode(), m2.hashCode());\n}",
      "Method_name": "testHashCode",
      "Class_declaration": "public class LongDoubleHashMapTest {\n",
      "constructors": "",
      "Class_name": "LongDoubleHashMapTest",
      "methodName_paraNum": "[hashCode(0), hashCode(0), put(2), toDouble(1), put(2), toDouble(1), put(2), toDouble(1), put(2), toDouble(1), hashCode(0), hashCode(0), put(2), toDouble(1), put(2), toDouble(1), hashCode(0), hashCode(0)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java/edu/jhu/prim/map/LongDoubleHashMapTest###testHashCode",
      "relativePath": "mgormley_prim/src/test/java/edu/jhu/prim/map/LongDoubleHashMapTest.java",
      "Signature": "public void testHashCode() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toDouble;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static edu.jhu.prim.Primitives.toLong;\n\nimport static org.junit.Assert.*;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n\nimport edu.jhu.prim.Primitives;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic void remove(long idx) {\n    int i = Arrays.binarySearch(indices, 0, used, idx);\n    if (i < 0) {\n        throw new IllegalArgumentException(\"This map does not contain the key: \" + idx);\n    }\n    System.arraycopy(indices, i + 1, indices, i, used - i - 1);\n    System.arraycopy(values, i + 1, values, i, used - i - 1);\n    used--;\n}",
      "all_field_declaration": "private static final long serialVersionUID = 1L;\nprotected long[] indices;\nprotected double[] values;\n// TODO: size\nprotected int used;",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "5",
      "Filed": "protected long[] indices;protected double[] values;protected int used;",
      "Parameter_type": "long",
      "Import_statements": "import java.util.Arrays;\n",
      "public_method_signature": "public LongDoubleSortedMap();\npublic LongDoubleSortedMap(int initialSize);\npublic LongDoubleSortedMap(long[] index, double[] data);\npublic LongDoubleSortedMap(LongDoubleSortedMap other);\npublic LongDoubleSortedMap(LongDoubleHashMap other);\npublic void clear();\npublic boolean contains(long idx);\npublic double get(long idx);\npublic double getWithDefault(long idx, double defaultVal);\npublic void remove(long idx);\npublic double put(long idx, double val);\npublic void add(long idx, double val);\npublic void apply(FnLongDoubleToDouble lambda);\npublic void iterate(FnLongDoubleToVoid lambda);\npublic Iterator<LongDoubleEntry> iterator();\npublic int size();\npublic int getUsed();\npublic long[] getIndices();\npublic double[] getValues();\npublic long[] getInternalIndices();\npublic double[] getInternalValues();",
      "public_field": "",
      "Method_statement": "remove(long idx)",
      "Method_name": "remove",
      "Class_declaration": "public class LongDoubleSortedMap {\n",
      "constructors": "public LongDoubleSortedMap() {\n    this(0);\n}public LongDoubleSortedMap(int initialSize) {\n    this.used = 0;\n    this.indices = new long[initialSize];\n    this.values = new double[initialSize];\n}public LongDoubleSortedMap(long[] index, double[] data) {\n    if (!LongSort.isSortedAscAndUnique(index)) {\n        throw new IllegalStateException(\"Indices are not sorted ascending\");\n    }\n    this.used = index.length;\n    this.indices = index;\n    this.values = data;\n}public LongDoubleSortedMap(LongDoubleSortedMap other) {\n    this.used = other.used;\n    this.indices = LongArrays.copyOf(other.indices);\n    this.values = DoubleArrays.copyOf(other.values);\n}public LongDoubleSortedMap(LongDoubleHashMap other) {\n    Pair<long[], double[]> pair = other.getIndicesAndValues();\n    LongDoubleSort.sortIndexAsc(pair.get1(), pair.get2());\n    this.used = other.size();\n    this.indices = pair.get1();\n    this.values = pair.get2();\n}",
      "all_method_signature": "public LongDoubleSortedMap();\npublic LongDoubleSortedMap(int initialSize);\npublic LongDoubleSortedMap(long[] index, double[] data);\npublic LongDoubleSortedMap(LongDoubleSortedMap other);\npublic LongDoubleSortedMap(LongDoubleHashMap other);\npublic void clear();\npublic boolean contains(long idx);\npublic double get(long idx);\npublic double getWithDefault(long idx, double defaultVal);\npublic void remove(long idx);\npublic double put(long idx, double val);\npublic void add(long idx, double val);\npublic void apply(FnLongDoubleToDouble lambda);\npublic void iterate(FnLongDoubleToVoid lambda);\nprivate final long[] insert(long[] array, int i, long val);\nprivate final double[] insert(double[] array, int i, double val);\npublic Iterator<LongDoubleEntry> iterator();\npublic int size();\npublic int getUsed();\npublic long[] getIndices();\npublic double[] getValues();\npublic long[] getInternalIndices();\npublic double[] getInternalValues();",
      "Class_name": "LongDoubleSortedMap",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java/edu/jhu/prim/map/LongDoubleSortedMap###remove",
      "Parameter_num": "1",
      "all_Import_statements": "import java.util.Arrays;\n\nimport java.util.Iterator;\n\nimport edu.jhu.prim.arrays.DoubleArrays;\n\nimport edu.jhu.prim.arrays.LongArrays;\n\nimport edu.jhu.prim.list.DoubleArrayList;\n\nimport edu.jhu.prim.list.LongArrayList;\n\nimport edu.jhu.prim.sort.LongDoubleSort;\n\nimport edu.jhu.prim.sort.LongSort;\n\nimport edu.jhu.prim.tuple.Pair;\n\nimport edu.jhu.prim.util.Lambda.FnLongDoubleToDouble;\n\nimport edu.jhu.prim.util.Lambda.FnLongDoubleToVoid;\n\nimport edu.jhu.prim.vector.AbstractLongDoubleVector;\n",
      "comment": " (non-Javadoc)\n     * @see edu.jhu.util.vector.LongDoubleMap#remove(long)\n     ",
      "packageName": "edu.jhu.prim.map",
      "method_signature": "public void remove(long idx);",
      "Junit_version": "4",
      "returnType": "void"
    },
    "Test_method": {
      "Method_body": "// First element.\nLongDoubleMap map = new LongDoubleSortedMap();\n\rmap.put(2, toDouble(22));\n\rmap.put(1, toDouble(11));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(11, toInt(map.get(1)));\n\rmap.remove(1);\n\rassertEquals(false, map.contains(1));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(1, map.size());\n\r// Middle element.\nmap = new LongDoubleSortedMap();\n\rmap.put(2, toDouble(22));\n\rmap.put(3, toDouble(33));\n\rmap.put(1, toDouble(11));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(33, toInt(map.get(3)));\n\rmap.remove(2);\n\rassertEquals(false, map.contains(2));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(33, toInt(map.get(3)));\n\rassertEquals(2, map.size());\n\r// Last element.\nmap = new LongDoubleSortedMap();\n\rmap.put(2, toDouble(22));\n\rmap.put(3, toDouble(33));\n\rmap.put(1, toDouble(11));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(33, toInt(map.get(3)));\n\rmap.remove(3);\n\rassertEquals(false, map.contains(3));\n\rassertEquals(11, toInt(map.get(1)));\n\rassertEquals(22, toInt(map.get(2)));\n\rassertEquals(2, map.size());",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "33",
      "Filed": "",
      "Import_statements": "import static edu.jhu.prim.Primitives.toDouble;\nimport static edu.jhu.prim.Primitives.toInt;\nimport static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "@Test\npublic void testRemove() {\n    // First element.\n    LongDoubleMap map = new LongDoubleSortedMap();\n    map.put(2, toDouble(22));\n    map.put(1, toDouble(11));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(11, toInt(map.get(1)));\n    map.remove(1);\n    assertEquals(false, map.contains(1));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(1, map.size());\n    // Middle element.\n    map = new LongDoubleSortedMap();\n    map.put(2, toDouble(22));\n    map.put(3, toDouble(33));\n    map.put(1, toDouble(11));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(33, toInt(map.get(3)));\n    map.remove(2);\n    assertEquals(false, map.contains(2));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(33, toInt(map.get(3)));\n    assertEquals(2, map.size());\n    // Last element.\n    map = new LongDoubleSortedMap();\n    map.put(2, toDouble(22));\n    map.put(3, toDouble(33));\n    map.put(1, toDouble(11));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(33, toInt(map.get(3)));\n    map.remove(3);\n    assertEquals(false, map.contains(3));\n    assertEquals(11, toInt(map.get(1)));\n    assertEquals(22, toInt(map.get(2)));\n    assertEquals(2, map.size());\n}",
      "Method_name": "testRemove",
      "Class_declaration": "public class LongDoubleSortedMapTest {\n",
      "constructors": "",
      "Class_name": "LongDoubleSortedMapTest",
      "methodName_paraNum": "[put(2), toDouble(1), put(2), toDouble(1), toInt(1), get(1), toInt(1), get(1), remove(1), contains(1), toInt(1), get(1), size(0), put(2), toDouble(1), put(2), toDouble(1), put(2), toDouble(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), remove(1), contains(1), toInt(1), get(1), toInt(1), get(1), size(0), put(2), toDouble(1), put(2), toDouble(1), put(2), toDouble(1), toInt(1), get(1), toInt(1), get(1), toInt(1), get(1), remove(1), contains(1), toInt(1), get(1), toInt(1), get(1), size(0)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java/edu/jhu/prim/map/LongDoubleSortedMapTest###testRemove",
      "relativePath": "mgormley_prim/src/test/java/edu/jhu/prim/map/LongDoubleSortedMapTest.java",
      "Signature": "public void testRemove() {\n",
      "all_Import_statements": "import static edu.jhu.prim.Primitives.toDouble;\n\nimport static edu.jhu.prim.Primitives.toInt;\n\nimport static org.junit.Assert.assertEquals;\n\nimport java.util.Iterator;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.map",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public byte getAndDecrement() {\n    final byte last = value;\n    value--;\n    return last;\n}",
      "all_field_declaration": "/**\n * Required for serialization support.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = -1585823265L;\n/**\n * The mutable value.\n */\nprivate byte value;",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "3",
      "Filed": "private byte value;",
      "Parameter_type": "",
      "Import_statements": "",
      "public_method_signature": "public MutableByte();\npublic MutableByte(final byte value);\npublic MutableByte(final Number value);\npublic MutableByte(final String value) throws NumberFormatException;\npublic Byte getValue();\npublic void setValue(final byte value);\npublic void setValue(final Number value);\npublic void increment();\npublic byte getAndIncrement();\npublic byte incrementAndGet();\npublic void decrement();\npublic byte getAndDecrement();\npublic byte decrementAndGet();\npublic void add(final byte operand);\npublic void add(final Number operand);\npublic void subtract(final byte operand);\npublic void subtract(final Number operand);\npublic byte addAndGet(final byte operand);\npublic byte addAndGet(final Number operand);\npublic byte getAndAdd(final byte operand);\npublic byte getAndAdd(final Number operand);\npublic byte byteValue();\npublic int intValue();\npublic long longValue();\npublic float floatValue();\npublic double doubleValue();\npublic Byte toByte();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic int compareTo(final MutableByte other);\npublic String toString();",
      "public_field": "",
      "Method_statement": "getAndDecrement()",
      "Method_name": "getAndDecrement",
      "Class_declaration": "public class MutableByte {\n",
      "constructors": "public MutableByte() {\n    super();\n}public MutableByte(final byte value) {\n    super();\n    this.value = value;\n}public MutableByte(final Number value) {\n    super();\n    this.value = value.byteValue();\n}public MutableByte(final String value) throws NumberFormatException {\n    super();\n    this.value = Byte.parseByte(value);\n}",
      "all_method_signature": "public MutableByte();\npublic MutableByte(final byte value);\npublic MutableByte(final Number value);\npublic MutableByte(final String value) throws NumberFormatException;\npublic Byte getValue();\npublic void setValue(final byte value);\npublic void setValue(final Number value);\npublic void increment();\npublic byte getAndIncrement();\npublic byte incrementAndGet();\npublic void decrement();\npublic byte getAndDecrement();\npublic byte decrementAndGet();\npublic void add(final byte operand);\npublic void add(final Number operand);\npublic void subtract(final byte operand);\npublic void subtract(final Number operand);\npublic byte addAndGet(final byte operand);\npublic byte addAndGet(final Number operand);\npublic byte getAndAdd(final byte operand);\npublic byte getAndAdd(final Number operand);\npublic byte byteValue();\npublic int intValue();\npublic long longValue();\npublic float floatValue();\npublic double doubleValue();\npublic Byte toByte();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic int compareTo(final MutableByte other);\npublic String toString();",
      "Class_name": "MutableByte",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/mutable/MutableByte###getAndDecrement",
      "Parameter_num": "0",
      "all_Import_statements": "import org.apache.commons.lang3.math.NumberUtils;\n",
      "comment": "\n     * Decrements this instance's value by 1; this method returns the value associated with the instance\n     * immediately prior to the decrement operation. This method is not thread safe.\n     *\n     * @return the value associated with the instance before it was decremented\n     * @since 3.5\n     ",
      "packageName": "org.apache.commons.lang3.mutable",
      "method_signature": "public byte getAndDecrement();",
      "Junit_version": "4",
      "returnType": "byte"
    },
    "Test_method": {
      "Method_body": "final MutableByte mutNum = new MutableByte((byte) 1);\n\rfinal byte result = mutNum.getAndDecrement();\n\rassertEquals(1, result);\n\rassertEquals(0, mutNum.intValue());\n\rassertEquals(0L, mutNum.longValue());",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "@Test\npublic void testGetAndDecrement() {\n    final MutableByte mutNum = new MutableByte((byte) 1);\n    final byte result = mutNum.getAndDecrement();\n    assertEquals(1, result);\n    assertEquals(0, mutNum.intValue());\n    assertEquals(0L, mutNum.longValue());\n}",
      "Method_name": "testGetAndDecrement",
      "Class_declaration": "public class MutableByteTest {\n",
      "constructors": "",
      "Class_name": "MutableByteTest",
      "methodName_paraNum": "[getAndDecrement(0), intValue(0), longValue(0)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/mutable/MutableByteTest###testGetAndDecrement",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/mutable/MutableByteTest.java",
      "Signature": "public void testGetAndDecrement() {\n",
      "all_Import_statements": "import org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertTrue;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3.mutable",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public int getAndDecrement() {\n    final int last = value;\n    value--;\n    return last;\n}",
      "all_field_declaration": "/**\n * Required for serialization support.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 512176391864L;\n/**\n * The mutable value.\n */\nprivate int value;",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "3",
      "Filed": "private int value;",
      "Parameter_type": "",
      "Import_statements": "",
      "public_method_signature": "public MutableInt();\npublic MutableInt(final int value);\npublic MutableInt(final Number value);\npublic MutableInt(final String value) throws NumberFormatException;\npublic Integer getValue();\npublic void setValue(final int value);\npublic void setValue(final Number value);\npublic void increment();\npublic int getAndIncrement();\npublic int incrementAndGet();\npublic void decrement();\npublic int getAndDecrement();\npublic int decrementAndGet();\npublic void add(final int operand);\npublic void add(final Number operand);\npublic void subtract(final int operand);\npublic void subtract(final Number operand);\npublic int addAndGet(final int operand);\npublic int addAndGet(final Number operand);\npublic int getAndAdd(final int operand);\npublic int getAndAdd(final Number operand);\npublic int intValue();\npublic long longValue();\npublic float floatValue();\npublic double doubleValue();\npublic Integer toInteger();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic int compareTo(final MutableInt other);\npublic String toString();",
      "public_field": "",
      "Method_statement": "getAndDecrement()",
      "Method_name": "getAndDecrement",
      "Class_declaration": "public class MutableInt {\n",
      "constructors": "public MutableInt() {\n    super();\n}public MutableInt(final int value) {\n    super();\n    this.value = value;\n}public MutableInt(final Number value) {\n    super();\n    this.value = value.intValue();\n}public MutableInt(final String value) throws NumberFormatException {\n    super();\n    this.value = Integer.parseInt(value);\n}",
      "all_method_signature": "public MutableInt();\npublic MutableInt(final int value);\npublic MutableInt(final Number value);\npublic MutableInt(final String value) throws NumberFormatException;\npublic Integer getValue();\npublic void setValue(final int value);\npublic void setValue(final Number value);\npublic void increment();\npublic int getAndIncrement();\npublic int incrementAndGet();\npublic void decrement();\npublic int getAndDecrement();\npublic int decrementAndGet();\npublic void add(final int operand);\npublic void add(final Number operand);\npublic void subtract(final int operand);\npublic void subtract(final Number operand);\npublic int addAndGet(final int operand);\npublic int addAndGet(final Number operand);\npublic int getAndAdd(final int operand);\npublic int getAndAdd(final Number operand);\npublic int intValue();\npublic long longValue();\npublic float floatValue();\npublic double doubleValue();\npublic Integer toInteger();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic int compareTo(final MutableInt other);\npublic String toString();",
      "Class_name": "MutableInt",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/mutable/MutableInt###getAndDecrement",
      "Parameter_num": "0",
      "all_Import_statements": "import org.apache.commons.lang3.math.NumberUtils;\n",
      "comment": "\n     * Decrements this instance's value by 1; this method returns the value associated with the instance\n     * immediately prior to the decrement operation. This method is not thread safe.\n     *\n     * @return the value associated with the instance before it was decremented\n     * @since 3.5\n     ",
      "packageName": "org.apache.commons.lang3.mutable",
      "method_signature": "public int getAndDecrement();",
      "Junit_version": "4",
      "returnType": "int"
    },
    "Test_method": {
      "Method_body": "final MutableInt mutNum = new MutableInt(1);\n\rfinal int result = mutNum.getAndDecrement();\n\rassertEquals(1, result);\n\rassertEquals(0, mutNum.intValue());\n\rassertEquals(0L, mutNum.longValue());",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "@Test\npublic void testGetAndDecrement() {\n    final MutableInt mutNum = new MutableInt(1);\n    final int result = mutNum.getAndDecrement();\n    assertEquals(1, result);\n    assertEquals(0, mutNum.intValue());\n    assertEquals(0L, mutNum.longValue());\n}",
      "Method_name": "testGetAndDecrement",
      "Class_declaration": "public class MutableIntTest {\n",
      "constructors": "",
      "Class_name": "MutableIntTest",
      "methodName_paraNum": "[getAndDecrement(0), intValue(0), longValue(0)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/mutable/MutableIntTest###testGetAndDecrement",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/mutable/MutableIntTest.java",
      "Signature": "public void testGetAndDecrement() {\n",
      "all_Import_statements": "import org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertTrue;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3.mutable",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static BigInteger createBigInteger(final String str) {\n    if (str == null) {\n        return null;\n    }\n    int pos = 0;\n    int radix = 10;\n    boolean negate = false;\n    if (str.startsWith(\"-\")) {\n        negate = true;\n        pos = 1;\n    }\n    if (str.startsWith(\"0x\", pos) || str.startsWith(\"0X\", pos)) {\n        radix = 16;\n        pos += 2;\n    } else if (str.startsWith(\"#\", pos)) {\n        radix = 16;\n        pos++;\n    } else if (str.startsWith(\"0\", pos) && str.length() > pos + 1) {\n        radix = 8;\n        pos++;\n    }\n    final BigInteger value = new BigInteger(str.substring(pos), radix);\n    return negate ? value.negate() : value;\n}",
      "all_field_declaration": "/**\n * Reusable Long constant for zero.\n */\npublic static final Long LONG_ZERO = Long.valueOf(0L);\n/**\n * Reusable Long constant for one.\n */\npublic static final Long LONG_ONE = Long.valueOf(1L);\n/**\n * Reusable Long constant for minus one.\n */\npublic static final Long LONG_MINUS_ONE = Long.valueOf(-1L);\n/**\n * Reusable Integer constant for zero.\n */\npublic static final Integer INTEGER_ZERO = Integer.valueOf(0);\n/**\n * Reusable Integer constant for one.\n */\npublic static final Integer INTEGER_ONE = Integer.valueOf(1);\n/**\n * Reusable Integer constant for minus one.\n */\npublic static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1);\n/**\n * Reusable Short constant for zero.\n */\npublic static final Short SHORT_ZERO = Short.valueOf((short) 0);\n/**\n * Reusable Short constant for one.\n */\npublic static final Short SHORT_ONE = Short.valueOf((short) 1);\n/**\n * Reusable Short constant for minus one.\n */\npublic static final Short SHORT_MINUS_ONE = Short.valueOf((short) -1);\n/**\n * Reusable Byte constant for zero.\n */\npublic static final Byte BYTE_ZERO = Byte.valueOf((byte) 0);\n/**\n * Reusable Byte constant for one.\n */\npublic static final Byte BYTE_ONE = Byte.valueOf((byte) 1);\n/**\n * Reusable Byte constant for minus one.\n */\npublic static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);\n/**\n * Reusable Double constant for zero.\n */\npublic static final Double DOUBLE_ZERO = Double.valueOf(0.0d);\n/**\n * Reusable Double constant for one.\n */\npublic static final Double DOUBLE_ONE = Double.valueOf(1.0d);\n/**\n * Reusable Double constant for minus one.\n */\npublic static final Double DOUBLE_MINUS_ONE = Double.valueOf(-1.0d);\n/**\n * Reusable Float constant for zero.\n */\npublic static final Float FLOAT_ZERO = Float.valueOf(0.0f);\n/**\n * Reusable Float constant for one.\n */\npublic static final Float FLOAT_ONE = Float.valueOf(1.0f);\n/**\n * Reusable Float constant for minus one.\n */\npublic static final Float FLOAT_MINUS_ONE = Float.valueOf(-1.0f);",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "8",
      "Filed": "",
      "Parameter_type": "String",
      "Import_statements": "import java.math.BigInteger;\n",
      "public_method_signature": "public NumberUtils();\npublic static int toInt(final String str);\npublic static int toInt(final String str, final int defaultValue);\npublic static long toLong(final String str);\npublic static long toLong(final String str, final long defaultValue);\npublic static float toFloat(final String str);\npublic static float toFloat(final String str, final float defaultValue);\npublic static double toDouble(final String str);\npublic static double toDouble(final String str, final double defaultValue);\npublic static byte toByte(final String str);\npublic static byte toByte(final String str, final byte defaultValue);\npublic static short toShort(final String str);\npublic static short toShort(final String str, final short defaultValue);\npublic static Number createNumber(final String str) throws NumberFormatException;\npublic static Float createFloat(final String str);\npublic static Double createDouble(final String str);\npublic static Integer createInteger(final String str);\npublic static Long createLong(final String str);\npublic static BigInteger createBigInteger(final String str);\npublic static BigDecimal createBigDecimal(final String str);\npublic static long min(final long... array);\npublic static int min(final int... array);\npublic static short min(final short... array);\npublic static byte min(final byte... array);\npublic static double min(final double... array);\npublic static float min(final float... array);\npublic static long max(final long... array);\npublic static int max(final int... array);\npublic static short max(final short... array);\npublic static byte max(final byte... array);\npublic static double max(final double... array);\npublic static float max(final float... array);\npublic static long min(long a, final long b, final long c);\npublic static int min(int a, final int b, final int c);\npublic static short min(short a, final short b, final short c);\npublic static byte min(byte a, final byte b, final byte c);\npublic static double min(final double a, final double b, final double c);\npublic static float min(final float a, final float b, final float c);\npublic static long max(long a, final long b, final long c);\npublic static int max(int a, final int b, final int c);\npublic static short max(short a, final short b, final short c);\npublic static byte max(byte a, final byte b, final byte c);\npublic static double max(final double a, final double b, final double c);\npublic static float max(final float a, final float b, final float c);\npublic static boolean isDigits(final String str);\npublic static boolean isNumber(final String str);\npublic static boolean isCreatable(final String str);\npublic static boolean isParsable(final String str);\npublic static int compare(final int x, final int y);\npublic static int compare(final long x, final long y);\npublic static int compare(final short x, final short y);\npublic static int compare(final byte x, final byte y);",
      "public_field": "/**\n * Reusable Long constant for zero.\n */\npublic static final Long LONG_ZERO = Long.valueOf(0L);\n/**\n * Reusable Long constant for one.\n */\npublic static final Long LONG_ONE = Long.valueOf(1L);\n/**\n * Reusable Long constant for minus one.\n */\npublic static final Long LONG_MINUS_ONE = Long.valueOf(-1L);\n/**\n * Reusable Integer constant for zero.\n */\npublic static final Integer INTEGER_ZERO = Integer.valueOf(0);\n/**\n * Reusable Integer constant for one.\n */\npublic static final Integer INTEGER_ONE = Integer.valueOf(1);\n/**\n * Reusable Integer constant for minus one.\n */\npublic static final Integer INTEGER_MINUS_ONE = Integer.valueOf(-1);\n/**\n * Reusable Short constant for zero.\n */\npublic static final Short SHORT_ZERO = Short.valueOf((short) 0);\n/**\n * Reusable Short constant for one.\n */\npublic static final Short SHORT_ONE = Short.valueOf((short) 1);\n/**\n * Reusable Short constant for minus one.\n */\npublic static final Short SHORT_MINUS_ONE = Short.valueOf((short) -1);\n/**\n * Reusable Byte constant for zero.\n */\npublic static final Byte BYTE_ZERO = Byte.valueOf((byte) 0);\n/**\n * Reusable Byte constant for one.\n */\npublic static final Byte BYTE_ONE = Byte.valueOf((byte) 1);\n/**\n * Reusable Byte constant for minus one.\n */\npublic static final Byte BYTE_MINUS_ONE = Byte.valueOf((byte) -1);\n/**\n * Reusable Double constant for zero.\n */\npublic static final Double DOUBLE_ZERO = Double.valueOf(0.0d);\n/**\n * Reusable Double constant for one.\n */\npublic static final Double DOUBLE_ONE = Double.valueOf(1.0d);\n/**\n * Reusable Double constant for minus one.\n */\npublic static final Double DOUBLE_MINUS_ONE = Double.valueOf(-1.0d);\n/**\n * Reusable Float constant for zero.\n */\npublic static final Float FLOAT_ZERO = Float.valueOf(0.0f);\n/**\n * Reusable Float constant for one.\n */\npublic static final Float FLOAT_ONE = Float.valueOf(1.0f);\n/**\n * Reusable Float constant for minus one.\n */\npublic static final Float FLOAT_MINUS_ONE = Float.valueOf(-1.0f);",
      "Method_statement": "createBigInteger(final String str)",
      "Method_name": "createBigInteger",
      "Class_declaration": "public class NumberUtils {\n",
      "constructors": "public NumberUtils() {\n    super();\n}",
      "all_method_signature": "public NumberUtils();\npublic static int toInt(final String str);\npublic static int toInt(final String str, final int defaultValue);\npublic static long toLong(final String str);\npublic static long toLong(final String str, final long defaultValue);\npublic static float toFloat(final String str);\npublic static float toFloat(final String str, final float defaultValue);\npublic static double toDouble(final String str);\npublic static double toDouble(final String str, final double defaultValue);\npublic static byte toByte(final String str);\npublic static byte toByte(final String str, final byte defaultValue);\npublic static short toShort(final String str);\npublic static short toShort(final String str, final short defaultValue);\npublic static Number createNumber(final String str) throws NumberFormatException;\nprivate static String getMantissa(final String str);\nprivate static String getMantissa(final String str, final int stopPos);\nprivate static boolean isAllZeros(final String str);\npublic static Float createFloat(final String str);\npublic static Double createDouble(final String str);\npublic static Integer createInteger(final String str);\npublic static Long createLong(final String str);\npublic static BigInteger createBigInteger(final String str);\npublic static BigDecimal createBigDecimal(final String str);\npublic static long min(final long... array);\npublic static int min(final int... array);\npublic static short min(final short... array);\npublic static byte min(final byte... array);\npublic static double min(final double... array);\npublic static float min(final float... array);\npublic static long max(final long... array);\npublic static int max(final int... array);\npublic static short max(final short... array);\npublic static byte max(final byte... array);\npublic static double max(final double... array);\npublic static float max(final float... array);\nprivate static void validateArray(final long[] array);\nprivate static void validateArray(final int[] array);\nprivate static void validateArray(final short[] array);\nprivate static void validateArray(final byte[] array);\nprivate static void validateArray(final double[] array);\nprivate static void validateArray(final float[] array);\npublic static long min(long a, final long b, final long c);\npublic static int min(int a, final int b, final int c);\npublic static short min(short a, final short b, final short c);\npublic static byte min(byte a, final byte b, final byte c);\npublic static double min(final double a, final double b, final double c);\npublic static float min(final float a, final float b, final float c);\npublic static long max(long a, final long b, final long c);\npublic static int max(int a, final int b, final int c);\npublic static short max(short a, final short b, final short c);\npublic static byte max(byte a, final byte b, final byte c);\npublic static double max(final double a, final double b, final double c);\npublic static float max(final float a, final float b, final float c);\npublic static boolean isDigits(final String str);\npublic static boolean isNumber(final String str);\npublic static boolean isCreatable(final String str);\npublic static boolean isParsable(final String str);\nprivate static boolean withDecimalsParsing(final String str, final int beginIdx);\npublic static int compare(final int x, final int y);\npublic static int compare(final long x, final long y);\npublic static int compare(final short x, final short y);\npublic static int compare(final byte x, final byte y);",
      "Class_name": "NumberUtils",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/math/NumberUtils###createBigInteger",
      "Parameter_num": "1",
      "all_Import_statements": "import java.lang.reflect.Array;\n\nimport java.math.BigDecimal;\n\nimport java.math.BigInteger;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport org.apache.commons.lang3.Validate;\n",
      "comment": "\n     * <p>Convert a <code>String</code> to a <code>BigInteger</code>;\n     * since 3.2 it handles hex (0x or #) and octal (0) notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigInteger</code> (or null if the input is null)\n     * @throws NumberFormatException if the value cannot be converted\n     ",
      "packageName": "org.apache.commons.lang3.math",
      "method_signature": "public static BigInteger createBigInteger(final String str);",
      "Junit_version": "4",
      "returnType": "BigInteger"
    },
    "Test_method": {
      "Method_body": "assertEquals(\"createBigInteger(String) failed\", new BigInteger(\"12345\"), NumberUtils.createBigInteger(\"12345\"));\n\rassertEquals(\"createBigInteger(null) failed\", null, NumberUtils.createBigInteger(null));\n\rthis.testCreateBigIntegerFailure(\"\");\n\rthis.testCreateBigIntegerFailure(\" \");\n\rthis.testCreateBigIntegerFailure(\"\\b\\t\\n\\f\\r\");\n\r// Funky whitespaces\nthis.testCreateBigIntegerFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n\rassertEquals(\"createBigInteger(String) failed\", new BigInteger(\"255\"), NumberUtils.createBigInteger(\"0xff\"));\n\rassertEquals(\"createBigInteger(String) failed\", new BigInteger(\"255\"), NumberUtils.createBigInteger(\"0Xff\"));\n\rassertEquals(\"createBigInteger(String) failed\", new BigInteger(\"255\"), NumberUtils.createBigInteger(\"#ff\"));\n\rassertEquals(\"createBigInteger(String) failed\", new BigInteger(\"-255\"), NumberUtils.createBigInteger(\"-0xff\"));\n\rassertEquals(\"createBigInteger(String) failed\", new BigInteger(\"255\"), NumberUtils.createBigInteger(\"0377\"));\n\rassertEquals(\"createBigInteger(String) failed\", new BigInteger(\"-255\"), NumberUtils.createBigInteger(\"-0377\"));\n\rassertEquals(\"createBigInteger(String) failed\", new BigInteger(\"-255\"), NumberUtils.createBigInteger(\"-0377\"));\n\rassertEquals(\"createBigInteger(String) failed\", new BigInteger(\"-0\"), NumberUtils.createBigInteger(\"-0\"));\n\rassertEquals(\"createBigInteger(String) failed\", new BigInteger(\"0\"), NumberUtils.createBigInteger(\"0\"));\n\rtestCreateBigIntegerFailure(\"#\");\n\rtestCreateBigIntegerFailure(\"-#\");\n\rtestCreateBigIntegerFailure(\"0x\");\n\rtestCreateBigIntegerFailure(\"-0x\");",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "19",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\nimport java.math.BigInteger;\n",
      "allMethod_info": "@Test\npublic void testCreateBigInteger() {\n    assertEquals(\"createBigInteger(String) failed\", new BigInteger(\"12345\"), NumberUtils.createBigInteger(\"12345\"));\n    assertEquals(\"createBigInteger(null) failed\", null, NumberUtils.createBigInteger(null));\n    this.testCreateBigIntegerFailure(\"\");\n    this.testCreateBigIntegerFailure(\" \");\n    this.testCreateBigIntegerFailure(\"\\b\\t\\n\\f\\r\");\n    // Funky whitespaces\n    this.testCreateBigIntegerFailure(\"\\u00A0\\uFEFF\\u000B\\u000C\\u001C\\u001D\\u001E\\u001F\");\n    assertEquals(\"createBigInteger(String) failed\", new BigInteger(\"255\"), NumberUtils.createBigInteger(\"0xff\"));\n    assertEquals(\"createBigInteger(String) failed\", new BigInteger(\"255\"), NumberUtils.createBigInteger(\"0Xff\"));\n    assertEquals(\"createBigInteger(String) failed\", new BigInteger(\"255\"), NumberUtils.createBigInteger(\"#ff\"));\n    assertEquals(\"createBigInteger(String) failed\", new BigInteger(\"-255\"), NumberUtils.createBigInteger(\"-0xff\"));\n    assertEquals(\"createBigInteger(String) failed\", new BigInteger(\"255\"), NumberUtils.createBigInteger(\"0377\"));\n    assertEquals(\"createBigInteger(String) failed\", new BigInteger(\"-255\"), NumberUtils.createBigInteger(\"-0377\"));\n    assertEquals(\"createBigInteger(String) failed\", new BigInteger(\"-255\"), NumberUtils.createBigInteger(\"-0377\"));\n    assertEquals(\"createBigInteger(String) failed\", new BigInteger(\"-0\"), NumberUtils.createBigInteger(\"-0\"));\n    assertEquals(\"createBigInteger(String) failed\", new BigInteger(\"0\"), NumberUtils.createBigInteger(\"0\"));\n    testCreateBigIntegerFailure(\"#\");\n    testCreateBigIntegerFailure(\"-#\");\n    testCreateBigIntegerFailure(\"0x\");\n    testCreateBigIntegerFailure(\"-0x\");\n}",
      "Method_name": "testCreateBigInteger",
      "Class_declaration": "public class NumberUtilsTest {\n",
      "constructors": "",
      "Class_name": "NumberUtilsTest",
      "methodName_paraNum": "[createBigInteger(1), createBigInteger(1), testCreateBigIntegerFailure(1), testCreateBigIntegerFailure(1), testCreateBigIntegerFailure(1), testCreateBigIntegerFailure(1), createBigInteger(1), createBigInteger(1), createBigInteger(1), createBigInteger(1), createBigInteger(1), createBigInteger(1), createBigInteger(1), createBigInteger(1), createBigInteger(1), testCreateBigIntegerFailure(1), testCreateBigIntegerFailure(1), testCreateBigIntegerFailure(1), testCreateBigIntegerFailure(1)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/math/NumberUtilsTest###testCreateBigInteger",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/math/NumberUtilsTest.java",
      "Signature": "public void testCreateBigInteger() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.junit.Assert.fail;\n\nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Modifier;\n\nimport java.math.BigDecimal;\n\nimport java.math.BigInteger;\n\nimport org.apache.commons.lang3.SystemUtils;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3.math",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static Collection<UnorderedPair> sampleUnorderedPairs(int minI, int maxI, int minJ, int maxJ, double prop) {\n    int numI = maxI - minI;\n    int numJ = maxJ - minJ;\n    long maxPairs = PairSampler.countUnorderedPairs(minI, maxI, minJ, maxJ);\n    Collection<UnorderedPair> samples;\n    if (maxPairs < 400000000 || prop > 0.1) {\n        samples = new ArrayList<UnorderedPair>();\n        int min = Math.min(minI, minJ);\n        int max = Math.max(maxI, maxJ);\n        for (int i = min; i < max; i++) {\n            for (int j = i; j < max; j++) {\n                if ((minI <= i && i < maxI && minJ <= j && j < maxJ) || (minJ <= i && i < maxJ && minI <= j && j < maxI)) {\n                    if (prop >= 1.0 || Prng.nextDouble() < prop) {\n                        samples.add(new UnorderedPair(i, j));\n                    }\n                }\n            }\n        }\n    } else {\n        samples = new HashSet<UnorderedPair>();\n        double numSamples = maxPairs * prop;\n        while (samples.size() < numSamples) {\n            int i = Prng.nextInt(numI) + minI;\n            int j = Prng.nextInt(numJ) + minJ;\n            if (i <= j) {\n                samples.add(new UnorderedPair(i, j));\n            }\n        }\n    }\n    return samples;\n}",
      "all_field_declaration": "",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "6",
      "Filed": "",
      "Parameter_type": "int,int,int,int,double",
      "Import_statements": "import java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport edu.jhu.prim.tuple.UnorderedPair;\nimport edu.jhu.prim.util.random.Prng;\n",
      "public_method_signature": "public static Collection<OrderedPair> sampleOrderedPairs(int minI, int maxI, int minJ, int maxJ, double prop);\npublic static Collection<UnorderedPair> sampleUnorderedPairs(int minI, int maxI, int minJ, int maxJ, double prop);\npublic static long countUnorderedPairs(int minI, int maxI, int minJ, int maxJ);",
      "public_field": "",
      "Method_statement": "sampleUnorderedPairs(int minI, int maxI, int minJ, int maxJ, double prop)",
      "Method_name": "sampleUnorderedPairs",
      "Class_declaration": "public class PairSampler {\n",
      "constructors": "private PairSampler() {\n}",
      "all_method_signature": "private PairSampler();\npublic static Collection<OrderedPair> sampleOrderedPairs(int minI, int maxI, int minJ, int maxJ, double prop);\npublic static Collection<UnorderedPair> sampleUnorderedPairs(int minI, int maxI, int minJ, int maxJ, double prop);\npublic static long countUnorderedPairs(int minI, int maxI, int minJ, int maxJ);",
      "Class_name": "PairSampler",
      "project_path": "mgormley_prim###mgormley_prim/src/main/java/edu/jhu/prim/sample/PairSampler###sampleUnorderedPairs",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.ArrayList;\n\nimport java.util.Collection;\n\nimport java.util.HashSet;\n\nimport edu.jhu.prim.tuple.OrderedPair;\n\nimport edu.jhu.prim.tuple.UnorderedPair;\n\nimport edu.jhu.prim.util.random.Prng;\n",
      "comment": "\n     * Sample with replacement unordered pairs of integers.\n     *  \n     * @param minI The minimum value for i (inclusive). \n     * @param maxI The maximum value for i (exclusive).\n     * @param minJ The minimum value for j (inclusive).\n     * @param maxJ The maximum value for j (exclusive).\n     * @param prop The proportion of possible pairs to return.\n     * @return A collection of unordered pairs represented as ordered pairs s.t. i <= j. \n     ",
      "packageName": "edu.jhu.prim.sample",
      "method_signature": "public static Collection<UnorderedPair> sampleUnorderedPairs(int minI, int maxI, int minJ, int maxJ, double prop);",
      "Junit_version": "4",
      "returnType": "Collection<UnorderedPair>"
    },
    "Test_method": {
      "Method_body": "Collection<UnorderedPair> samples;\n\rsamples = PairSampler.sampleUnorderedPairs(0, 100, 0, 1000, 1.0);\n\rsamples = PairSampler.sampleUnorderedPairs(0, 1000, 0, 100, 1.0);\n\rSystem.out.println(samples.size());\n\r// Test iterative sampling.\nsamples = PairSampler.sampleUnorderedPairs(0, 312, 100, 212, 0.3);\n\rSystem.out.println(samples.size());\n\r// Test hash-set sampling.\nsamples = PairSampler.sampleUnorderedPairs(0, 312, 0, 312, 0.3);\n\rSystem.out.println(samples.size());",
      "sub_project_name": "mgormley_prim",
      "lineNumbers": "8",
      "Filed": "",
      "Import_statements": "import java.util.Collection;\nimport org.junit.Test;\nimport edu.jhu.prim.tuple.UnorderedPair;\n",
      "allMethod_info": "@Test\npublic void testSampleUnorderedPairs() {\n    Collection<UnorderedPair> samples;\n    samples = PairSampler.sampleUnorderedPairs(0, 100, 0, 1000, 1.0);\n    samples = PairSampler.sampleUnorderedPairs(0, 1000, 0, 100, 1.0);\n    System.out.println(samples.size());\n    // Test iterative sampling.\n    samples = PairSampler.sampleUnorderedPairs(0, 312, 100, 212, 0.3);\n    System.out.println(samples.size());\n    // Test hash-set sampling.\n    samples = PairSampler.sampleUnorderedPairs(0, 312, 0, 312, 0.3);\n    System.out.println(samples.size());\n}",
      "Method_name": "testSampleUnorderedPairs",
      "Class_declaration": "public class PairSamplerTest {\n",
      "constructors": "",
      "Class_name": "PairSamplerTest",
      "methodName_paraNum": "[sampleUnorderedPairs(5), sampleUnorderedPairs(5), println(1), size(0), sampleUnorderedPairs(5), println(1), size(0), sampleUnorderedPairs(5), println(1), size(0)]",
      "project_path": "mgormley_prim###mgormley_prim/src/test/java/edu/jhu/prim/sample/PairSamplerTest###testSampleUnorderedPairs",
      "relativePath": "mgormley_prim/src/test/java/edu/jhu/prim/sample/PairSamplerTest.java",
      "Signature": "public void testSampleUnorderedPairs() {\n",
      "all_Import_statements": "import java.util.Collection;\n\nimport org.junit.Assert;\n\nimport org.junit.Test;\n\nimport edu.jhu.prim.tuple.OrderedPair;\n\nimport edu.jhu.prim.tuple.UnorderedPair;\n",
      "comment": "",
      "packageName": "edu.jhu.prim.sample",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic Prijzen getModel(InputStream stream) {\n    Map<String, VervoerderKeuze> vervoerderKeuzes = new HashMap<>();\n    Xml xml = Xml.getXml(stream, \"VervoerderKeuzes\");\n    for (Xml vervoerderKeuze : xml.children(\"VervoerderKeuze\")) {\n        String vervoerderKeuzeNaam = vervoerderKeuze.attr(\"naam\");\n        int tariefEenheden = Integer.parseInt(vervoerderKeuze.child(\"Tariefeenheden\").content());\n        Map<String, ReisType> reisTypes = new HashMap<>();\n        for (Xml reisTypeXml : vervoerderKeuze.children(\"ReisType\")) {\n            String reisTypeNaam = reisTypeXml.attr(\"name\");\n            Map<Integer, ReisKlasse> reisKlassen = new HashMap<>();\n            for (Xml reisKlasseXml : reisTypeXml.children(\"ReisKlasse\")) {\n                int klasse = Integer.parseInt(reisKlasseXml.attr(\"klasse\"));\n                List<Prijsdeel> prijsdelen = new LinkedList<>();\n                for (Xml prijsdeelXml : reisKlasseXml.children(\"Prijsdeel\")) {\n                    prijsdelen.add(new Prijsdeel(prijsdeelXml.attr(\"vervoerder\"), new BigDecimal(prijsdeelXml.attr(\"prijs\")), prijsdeelXml.attr(\"van\"), prijsdeelXml.attr(\"naar\")));\n                }\n                BigDecimal totaal = new BigDecimal(reisKlasseXml.child(\"Totaal\").content());\n                Map<String, BigDecimal> kortingprijzen = new HashMap<>();\n                for (Xml kortingsPrijsXml : reisKlasseXml.child(\"Korting\").children(\"Kortingsprijs\")) {\n                    kortingprijzen.put(kortingsPrijsXml.attr(\"name\"), new BigDecimal(kortingsPrijsXml.attr(\"prijs\")));\n                }\n                reisKlassen.put(klasse, new ReisKlasse(klasse, prijsdelen, totaal, Collections.unmodifiableMap(kortingprijzen)));\n            }\n            reisTypes.put(reisTypeNaam, new ReisType(reisTypeNaam, Collections.unmodifiableMap(reisKlassen)));\n        }\n        vervoerderKeuzes.put(vervoerderKeuzeNaam, new VervoerderKeuze(vervoerderKeuzeNaam, tariefEenheden, Collections.unmodifiableMap(reisTypes)));\n    }\n    return new Prijzen(Collections.unmodifiableMap(vervoerderKeuzes));\n}",
      "all_field_declaration": "",
      "sub_project_name": "pvanassen_ns-api",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "InputStream",
      "Import_statements": "import nl.pvanassen.ns.xml.Xml;\nimport java.io.InputStream;\nimport java.math.BigDecimal;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\n",
      "public_method_signature": "public Prijzen getModel(InputStream stream);",
      "public_field": "",
      "Method_statement": "getModel(InputStream stream)",
      "Method_name": "getModel",
      "Class_declaration": "public class PrijsHandle {\n",
      "constructors": "",
      "all_method_signature": "public Prijzen getModel(InputStream stream);",
      "Class_name": "PrijsHandle",
      "project_path": "pvanassen_ns-api###pvanassen_ns-api/src/main/java/nl/pvanassen/ns/model/prijzen/PrijsHandle###getModel",
      "Parameter_num": "1",
      "all_Import_statements": "import nl.pvanassen.ns.handle.Handle;\n\nimport nl.pvanassen.ns.xml.Xml;\n\nimport java.io.InputStream;\n\nimport java.math.BigDecimal;\n\nimport java.util.Collections;\n\nimport java.util.HashMap;\n\nimport java.util.LinkedList;\n\nimport java.util.List;\n\nimport java.util.Map;\n",
      "comment": "\n     * {@inheritDoc}\n     * \n     * @see nl.pvanassen.ns.handle.Handle#getModel(java.io.InputStream)\n     ",
      "packageName": "nl.pvanassen.ns.model.prijzen",
      "method_signature": "public Prijzen getModel(InputStream stream);",
      "Junit_version": "4",
      "returnType": "Prijzen"
    },
    "Test_method": {
      "Method_body": "PrijsHandle handle = new PrijsHandle();\n\rPrijzen prijzen = handle.getModel(getClass().getResourceAsStream(\"/prijzen/prijzen-example.xml\"));\n\rassertNotNull(prijzen);\n\rassertNotNull(prijzen.getVervoerderKeuzes());\n\rassertEquals(3, prijzen.getVervoerderKeuzes().size());\n\rVervoerderKeuze vervoerderKeuze = prijzen.getVervoerderKeuzes().get(\"MEEST_NS\");\n\rassertNotNull(vervoerderKeuze);\n\rassertEquals(82, vervoerderKeuze.getTariefEenheden());\n\rassertEquals(\"MEEST_NS\", vervoerderKeuze.getNaam());\n\rassertEquals(2, vervoerderKeuze.getReisTypes().size());\n\rReisType reisType = vervoerderKeuze.getReisTypes().get(\"Enkele reis\");\n\rassertNotNull(reisType);\n\rassertEquals(\"Enkele reis\", reisType.getNaam());\n\rassertEquals(2, reisType.getReisKlassen().size());\n\rReisKlasse reisKlasse = reisType.getReisKlassen().get(2);\n\rassertNotNull(reisKlasse);\n\rassertEquals(2, reisKlasse.getKlasse());\n\rassertEquals(new BigDecimal(\"13.90\"), reisKlasse.getTotaal());\n\rassertEquals(3, reisKlasse.getKorting().size());\n\rassertEquals(new BigDecimal(\"13.90\"), reisKlasse.getKorting().get(\"vol tarief\"));\n\rassertEquals(1, reisKlasse.getPrijsdeel().size());\n\rassertEquals(\"NS\", reisKlasse.getPrijsdeel().get(0).getVervoerder());\n\rassertEquals(\"GDM\", reisKlasse.getPrijsdeel().get(0).getNaar());\n\rassertEquals(\"RTD\", reisKlasse.getPrijsdeel().get(0).getVan());\n\rassertEquals(new BigDecimal(\"13.90\"), reisKlasse.getPrijsdeel().get(0).getPrijs());",
      "sub_project_name": "pvanassen_ns-api",
      "lineNumbers": "25",
      "Filed": "",
      "Import_statements": "import java.math.BigDecimal;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\n",
      "allMethod_info": "@Test\npublic void testGetModel() {\n    PrijsHandle handle = new PrijsHandle();\n    Prijzen prijzen = handle.getModel(getClass().getResourceAsStream(\"/prijzen/prijzen-example.xml\"));\n    assertNotNull(prijzen);\n    assertNotNull(prijzen.getVervoerderKeuzes());\n    assertEquals(3, prijzen.getVervoerderKeuzes().size());\n    VervoerderKeuze vervoerderKeuze = prijzen.getVervoerderKeuzes().get(\"MEEST_NS\");\n    assertNotNull(vervoerderKeuze);\n    assertEquals(82, vervoerderKeuze.getTariefEenheden());\n    assertEquals(\"MEEST_NS\", vervoerderKeuze.getNaam());\n    assertEquals(2, vervoerderKeuze.getReisTypes().size());\n    ReisType reisType = vervoerderKeuze.getReisTypes().get(\"Enkele reis\");\n    assertNotNull(reisType);\n    assertEquals(\"Enkele reis\", reisType.getNaam());\n    assertEquals(2, reisType.getReisKlassen().size());\n    ReisKlasse reisKlasse = reisType.getReisKlassen().get(2);\n    assertNotNull(reisKlasse);\n    assertEquals(2, reisKlasse.getKlasse());\n    assertEquals(new BigDecimal(\"13.90\"), reisKlasse.getTotaal());\n    assertEquals(3, reisKlasse.getKorting().size());\n    assertEquals(new BigDecimal(\"13.90\"), reisKlasse.getKorting().get(\"vol tarief\"));\n    assertEquals(1, reisKlasse.getPrijsdeel().size());\n    assertEquals(\"NS\", reisKlasse.getPrijsdeel().get(0).getVervoerder());\n    assertEquals(\"GDM\", reisKlasse.getPrijsdeel().get(0).getNaar());\n    assertEquals(\"RTD\", reisKlasse.getPrijsdeel().get(0).getVan());\n    assertEquals(new BigDecimal(\"13.90\"), reisKlasse.getPrijsdeel().get(0).getPrijs());\n}",
      "Method_name": "testGetModel",
      "Class_declaration": "public class PrijsHandleTest {\n",
      "constructors": "",
      "Class_name": "PrijsHandleTest",
      "methodName_paraNum": "[getModel(1), getResourceAsStream(1), getClass(0), getVervoerderKeuzes(0), size(0), getVervoerderKeuzes(0), get(1), getVervoerderKeuzes(0), getTariefEenheden(0), getNaam(0), size(0), getReisTypes(0), get(1), getReisTypes(0), getNaam(0), size(0), getReisKlassen(0), get(1), getReisKlassen(0), getKlasse(0), getTotaal(0), size(0), getKorting(0), get(1), getKorting(0), size(0), getPrijsdeel(0), getVervoerder(0), get(1), getPrijsdeel(0), getNaar(0), get(1), getPrijsdeel(0), getVan(0), get(1), getPrijsdeel(0), getPrijs(0), get(1), getPrijsdeel(0)]",
      "project_path": "pvanassen_ns-api###pvanassen_ns-api/src/test/java/nl/pvanassen/ns/model/prijzen/PrijsHandleTest###testGetModel",
      "relativePath": "pvanassen_ns-api/src/test/java/nl/pvanassen/ns/model/prijzen/PrijsHandleTest.java",
      "Signature": "public void testGetModel() {\n",
      "all_Import_statements": "import org.junit.Test;\n\nimport java.math.BigDecimal;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertNotNull;\n",
      "comment": "",
      "packageName": "nl.pvanassen.ns.model.prijzen",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic int hashCode() {\n    int result = hashCode;\n    if (hashCode == 0) {\n        result = 17;\n        result = 37 * result + getClass().hashCode();\n        result = 37 * result + minimum.hashCode();\n        result = 37 * result + maximum.hashCode();\n        hashCode = result;\n    }\n    return result;\n}",
      "all_field_declaration": "/**\n * Serialization version.\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 1L;\n/**\n * The ordering scheme used in this range.\n */\nprivate final Comparator<T> comparator;\n/**\n * The minimum value in this range (inclusive).\n */\nprivate final T minimum;\n/**\n * The maximum value in this range (inclusive).\n */\nprivate final T maximum;\n/**\n * Cached output hashCode (class is immutable).\n */\nprivate transient int hashCode;\n/**\n * Cached output toString (class is immutable).\n */\nprivate transient String toString;",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "3",
      "Filed": "private final T minimum;private final T maximum;private transient int hashCode;",
      "Parameter_type": "",
      "Import_statements": "",
      "public_method_signature": "public static Range<T> is(final T element);\npublic static Range<T> is(final T element, final Comparator<T> comparator);\npublic static Range<T> between(final T fromInclusive, final T toInclusive);\npublic static Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator);\npublic T getMinimum();\npublic T getMaximum();\npublic Comparator<T> getComparator();\npublic boolean isNaturalOrdering();\npublic boolean contains(final T element);\npublic boolean isAfter(final T element);\npublic boolean isStartedBy(final T element);\npublic boolean isEndedBy(final T element);\npublic boolean isBefore(final T element);\npublic int elementCompareTo(final T element);\npublic boolean containsRange(final Range<T> otherRange);\npublic boolean isAfterRange(final Range<T> otherRange);\npublic boolean isOverlappedBy(final Range<T> otherRange);\npublic boolean isBeforeRange(final Range<T> otherRange);\npublic Range<T> intersectionWith(final Range<T> other);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();\npublic String toString(final String format);",
      "public_field": "",
      "Method_statement": "hashCode()",
      "Method_name": "hashCode",
      "Class_declaration": "public  final class Range {\n",
      "constructors": "@SuppressWarnings(\"unchecked\")\nprivate Range(final T element1, final T element2, final Comparator<T> comp) {\n    if (element1 == null || element2 == null) {\n        throw new IllegalArgumentException(\"Elements in a range must not be null: element1=\" + element1 + \", element2=\" + element2);\n    }\n    if (comp == null) {\n        this.comparator = ComparableComparator.INSTANCE;\n    } else {\n        this.comparator = comp;\n    }\n    if (this.comparator.compare(element1, element2) < 1) {\n        this.minimum = element1;\n        this.maximum = element2;\n    } else {\n        this.minimum = element2;\n        this.maximum = element1;\n    }\n}",
      "all_method_signature": "public static Range<T> is(final T element);\npublic static Range<T> is(final T element, final Comparator<T> comparator);\npublic static Range<T> between(final T fromInclusive, final T toInclusive);\npublic static Range<T> between(final T fromInclusive, final T toInclusive, final Comparator<T> comparator);\nprivate Range(final T element1, final T element2, final Comparator<T> comp);\npublic T getMinimum();\npublic T getMaximum();\npublic Comparator<T> getComparator();\npublic boolean isNaturalOrdering();\npublic boolean contains(final T element);\npublic boolean isAfter(final T element);\npublic boolean isStartedBy(final T element);\npublic boolean isEndedBy(final T element);\npublic boolean isBefore(final T element);\npublic int elementCompareTo(final T element);\npublic boolean containsRange(final Range<T> otherRange);\npublic boolean isAfterRange(final Range<T> otherRange);\npublic boolean isOverlappedBy(final Range<T> otherRange);\npublic boolean isBeforeRange(final Range<T> otherRange);\npublic Range<T> intersectionWith(final Range<T> other);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();\npublic String toString(final String format);",
      "Class_name": "Range",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Range###hashCode",
      "Parameter_num": "0",
      "all_Import_statements": "import java.io.Serializable;\n\nimport java.util.Comparator;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>Gets a suitable hash code for the range.</p>\n     *\n     * @return a hash code value for this object\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public int hashCode();",
      "Junit_version": "4",
      "returnType": "int"
    },
    "Test_method": {
      "Method_body": "assertEquals(byteRange.hashCode(), byteRange2.hashCode());\n\rassertFalse(byteRange.hashCode() == byteRange3.hashCode());\n\rassertEquals(intRange.hashCode(), intRange.hashCode());\n\rassertTrue(intRange.hashCode() != 0);",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "4",
      "Filed": "private Range<Byte> byteRange;private Range<Byte> byteRange2;private Range<Byte> byteRange3;private Range<Integer> intRange;",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n",
      "allMethod_info": "@Test\npublic void testHashCode() {\n    assertEquals(byteRange.hashCode(), byteRange2.hashCode());\n    assertFalse(byteRange.hashCode() == byteRange3.hashCode());\n    assertEquals(intRange.hashCode(), intRange.hashCode());\n    assertTrue(intRange.hashCode() != 0);\n}",
      "Method_name": "testHashCode",
      "Class_declaration": "public class RangeTest {\n",
      "constructors": "",
      "Class_name": "RangeTest",
      "methodName_paraNum": "[hashCode(0), hashCode(0), hashCode(0), hashCode(0), hashCode(0), hashCode(0), hashCode(0)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/RangeTest###testHashCode",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/RangeTest.java",
      "Signature": "public void testHashCode() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertSame;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.Comparator;\n\nimport org.junit.Before;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static <T extends Serializable> T clone(final T object) {\n    if (object == null) {\n        return null;\n    }\n    final byte[] objectData = serialize(object);\n    final ByteArrayInputStream bais = new ByteArrayInputStream(objectData);\n    try (ClassLoaderAwareObjectInputStream in = new ClassLoaderAwareObjectInputStream(bais, object.getClass().getClassLoader())) {\n        @SuppressWarnings(\"unchecked\")\n        final T readObject = (T) in.readObject();\n        return readObject;\n    } catch (final ClassNotFoundException ex) {\n        throw new SerializationException(\"ClassNotFoundException while reading cloned object data\", ex);\n    } catch (final IOException ex) {\n        throw new SerializationException(\"IOException while reading or closing cloned object data\", ex);\n    }\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "T",
      "Import_statements": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.Serializable;\n",
      "public_method_signature": "public SerializationUtils();\npublic static T clone(final T object);\npublic static T roundtrip(final T msg);\npublic static void serialize(final Serializable obj, final OutputStream outputStream);\npublic static byte[] serialize(final Serializable obj);\npublic static T deserialize(final InputStream inputStream);\npublic static T deserialize(final byte[] objectData);",
      "public_field": "",
      "Method_statement": "clone(final T object)",
      "Method_name": "clone",
      "Class_declaration": "public class SerializationUtils {\n",
      "constructors": "public SerializationUtils() {\n    super();\n}",
      "all_method_signature": "public SerializationUtils();\npublic static T clone(final T object);\npublic static T roundtrip(final T msg);\npublic static void serialize(final Serializable obj, final OutputStream outputStream);\npublic static byte[] serialize(final Serializable obj);\npublic static T deserialize(final InputStream inputStream);\npublic static T deserialize(final byte[] objectData);",
      "Class_name": "SerializationUtils",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/SerializationUtils###clone",
      "Parameter_num": "1",
      "all_Import_statements": "import java.io.ByteArrayInputStream;\n\nimport java.io.ByteArrayOutputStream;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.ObjectOutputStream;\n\nimport java.io.ObjectStreamClass;\n\nimport java.io.OutputStream;\n\nimport java.io.Serializable;\n\nimport java.util.HashMap;\n\nimport java.util.Map;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>Deep clone an {@code Object} using serialization.</p>\n     *\n     * <p>This is many times slower than writing clone methods by hand\n     * on all objects in your object graph. However, for complex object\n     * graphs, or for those that don't support deep cloning this can\n     * be a simple alternative implementation. Of course all the objects\n     * must be {@code Serializable}.</p>\n     *\n     * @param <T> the type of the object involved\n     * @param object  the {@code Serializable} object to clone\n     * @return the cloned object\n     * @throws SerializationException (runtime) if the serialization fails\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static T clone(final T object);",
      "Junit_version": "4",
      "returnType": "T"
    },
    "Test_method": {
      "Method_body": "final Object test = SerializationUtils.clone(iMap);\n\rassertNotNull(test);\n\rassertTrue(test instanceof HashMap<?, ?>);\n\rassertTrue(test != iMap);\n\rfinal HashMap<?, ?> testMap = (HashMap<?, ?>) test;\n\rassertEquals(iString, testMap.get(\"FOO\"));\n\rassertTrue(iString != testMap.get(\"FOO\"));\n\rassertEquals(iInteger, testMap.get(\"BAR\"));\n\rassertTrue(iInteger != testMap.get(\"BAR\"));\n\rassertEquals(iMap, testMap);",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "10",
      "Filed": "private String iString;private Integer iInteger;private HashMap<Object, Object> iMap;",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\nimport java.util.HashMap;\n",
      "allMethod_info": "// -----------------------------------------------------------------------\n@Test\npublic void testClone() throws Exception {\n    final Object test = SerializationUtils.clone(iMap);\n    assertNotNull(test);\n    assertTrue(test instanceof HashMap<?, ?>);\n    assertTrue(test != iMap);\n    final HashMap<?, ?> testMap = (HashMap<?, ?>) test;\n    assertEquals(iString, testMap.get(\"FOO\"));\n    assertTrue(iString != testMap.get(\"FOO\"));\n    assertEquals(iInteger, testMap.get(\"BAR\"));\n    assertTrue(iInteger != testMap.get(\"BAR\"));\n    assertEquals(iMap, testMap);\n}",
      "Method_name": "testClone",
      "Class_declaration": "public class SerializationUtilsTest {\n",
      "constructors": "",
      "Class_name": "SerializationUtilsTest",
      "methodName_paraNum": "[clone(1), get(1), get(1), get(1), get(1)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/SerializationUtilsTest###testClone",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/SerializationUtilsTest.java",
      "Signature": "public void testClone() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertNull;\n\nimport static org.junit.Assert.assertSame;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.junit.Assert.fail;\n\nimport java.io.ByteArrayInputStream;\n\nimport java.io.ByteArrayOutputStream;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.ObjectOutputStream;\n\nimport java.io.OutputStream;\n\nimport java.io.Serializable;\n\nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Modifier;\n\nimport java.util.HashMap;\n\nimport org.junit.Before;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic Stations getModel(InputStream stream) {\n    List<Station> stations = new LinkedList<>();\n    Xml xml = Xml.getXml(stream, \"Stations\");\n    for (Xml stationXml : xml.children(\"Station\")) {\n        String code = stationXml.child(\"Code\").content();\n        String type = stationXml.child(\"Type\").content();\n        Namen namen = new Namen(stationXml.child(\"Namen\").child(\"Kort\").content(), stationXml.child(\"Namen\").child(\"Middel\").content(), stationXml.child(\"Namen\").child(\"Lang\").content());\n        String land = stationXml.child(\"Land\").content();\n        int uicCode = Integer.parseInt(stationXml.child(\"UICCode\").content());\n        double lat = Double.parseDouble(stationXml.child(\"Lat\").content());\n        double lon = Double.parseDouble(stationXml.child(\"Lon\").content());\n        List<String> synoniemen = new ArrayList<>(stationXml.child(\"Synoniemen\").children(\"Synoniem\").size());\n        for (Xml synomiemXml : stationXml.child(\"Synoniemen\").children(\"Synoniem\")) {\n            synoniemen.add(synomiemXml.content());\n        }\n        stations.add(new Station(code, type, namen, land, uicCode, lat, lon, synoniemen));\n    }\n    return new Stations(stations);\n}",
      "all_field_declaration": "",
      "sub_project_name": "pvanassen_ns-api",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "InputStream",
      "Import_statements": "import nl.pvanassen.ns.xml.Xml;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n",
      "public_method_signature": "public Stations getModel(InputStream stream);",
      "public_field": "",
      "Method_statement": "getModel(InputStream stream)",
      "Method_name": "getModel",
      "Class_declaration": "public class StationsHandle {\n",
      "constructors": "",
      "all_method_signature": "public Stations getModel(InputStream stream);",
      "Class_name": "StationsHandle",
      "project_path": "pvanassen_ns-api###pvanassen_ns-api/src/main/java/nl/pvanassen/ns/model/stations/StationsHandle###getModel",
      "Parameter_num": "1",
      "all_Import_statements": "import nl.pvanassen.ns.handle.Handle;\n\nimport nl.pvanassen.ns.xml.Xml;\n\nimport java.io.InputStream;\n\nimport java.util.ArrayList;\n\nimport java.util.LinkedList;\n\nimport java.util.List;\n",
      "comment": "\r\n     * \r\n     * {@inheritDoc}\r\n     * \r\n     * @see nl.pvanassen.ns.handle.Handle#getModel(java.io.InputStream)\r\n     ",
      "packageName": "nl.pvanassen.ns.model.stations",
      "method_signature": "public Stations getModel(InputStream stream);",
      "Junit_version": "4",
      "returnType": "Stations"
    },
    "Test_method": {
      "Method_body": "StationsHandle handle = new StationsHandle();\n\rList<Station> stations = handle.getModel(getClass().getResourceAsStream(\"/stations/stations-actual.xml\"));\n\rassertNotNull(stations);\n\rassertNotEquals(0, stations.size());\n\rStation stationDenBosch = stations.get(0);\n\rassertNotNull(stationDenBosch.getNamen());\n\rassertEquals(\"H'bosch\", stationDenBosch.getNamen().getKort());\n\rassertEquals(\"'s-Hertogenbosch\", stationDenBosch.getNamen().getMiddel());\n\rassertEquals(\"'s-Hertogenbosch\", stationDenBosch.getNamen().getLang());\n\rassertEquals(\"NL\", stationDenBosch.getLand());\n\rassertEquals(8400319, stationDenBosch.getUicCode());\n\rassertEquals(51.69048d, stationDenBosch.getLat(), Double.MIN_VALUE);\n\rassertEquals(5.29362d, stationDenBosch.getLon(), Double.MIN_VALUE);\n\rassertEquals(2, stationDenBosch.getSynoniemen().size());\n\rassertEquals(\"Hertogenbosch ('s)\", stationDenBosch.getSynoniemen().get(0));\n\rassertEquals(\"Den Bosch\", stationDenBosch.getSynoniemen().get(1));",
      "sub_project_name": "pvanassen_ns-api",
      "lineNumbers": "16",
      "Filed": "",
      "Import_statements": "import java.util.List;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotEquals;\nimport static org.junit.Assert.assertNotNull;\n",
      "allMethod_info": "@Test\npublic void testGetModel() {\n    StationsHandle handle = new StationsHandle();\n    List<Station> stations = handle.getModel(getClass().getResourceAsStream(\"/stations/stations-actual.xml\"));\n    assertNotNull(stations);\n    assertNotEquals(0, stations.size());\n    Station stationDenBosch = stations.get(0);\n    assertNotNull(stationDenBosch.getNamen());\n    assertEquals(\"H'bosch\", stationDenBosch.getNamen().getKort());\n    assertEquals(\"'s-Hertogenbosch\", stationDenBosch.getNamen().getMiddel());\n    assertEquals(\"'s-Hertogenbosch\", stationDenBosch.getNamen().getLang());\n    assertEquals(\"NL\", stationDenBosch.getLand());\n    assertEquals(8400319, stationDenBosch.getUicCode());\n    assertEquals(51.69048d, stationDenBosch.getLat(), Double.MIN_VALUE);\n    assertEquals(5.29362d, stationDenBosch.getLon(), Double.MIN_VALUE);\n    assertEquals(2, stationDenBosch.getSynoniemen().size());\n    assertEquals(\"Hertogenbosch ('s)\", stationDenBosch.getSynoniemen().get(0));\n    assertEquals(\"Den Bosch\", stationDenBosch.getSynoniemen().get(1));\n}",
      "Method_name": "testGetModel",
      "Class_declaration": "public class StationsHandleTest {\n",
      "constructors": "",
      "Class_name": "StationsHandleTest",
      "methodName_paraNum": "[getModel(1), getResourceAsStream(1), getClass(0), size(0), get(1), getNamen(0), getKort(0), getNamen(0), getMiddel(0), getNamen(0), getLang(0), getNamen(0), getLand(0), getUicCode(0), getLat(0), getLon(0), size(0), getSynoniemen(0), get(1), getSynoniemen(0), get(1), getSynoniemen(0)]",
      "project_path": "pvanassen_ns-api###pvanassen_ns-api/src/test/java/nl/pvanassen/ns/model/stations/StationsHandleTest###testGetModel",
      "relativePath": "pvanassen_ns-api/src/test/java/nl/pvanassen/ns/model/stations/StationsHandleTest.java",
      "Signature": "public void testGetModel() {\n",
      "all_Import_statements": "import org.junit.Test;\n\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertNotEquals;\n\nimport static org.junit.Assert.assertNotNull;\n",
      "comment": "",
      "packageName": "nl.pvanassen.ns.model.stations",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public StrBuilder setCharAt(final int index, final char ch) {\n    if (index < 0 || index >= length()) {\n        throw new StringIndexOutOfBoundsException(index);\n    }\n    buffer[index] = ch;\n    return this;\n}",
      "all_field_declaration": "/**\n * The extra capacity for new builders.\n */\nstatic final int CAPACITY = 32;\n/**\n * Required for serialization support.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 7628716375283629643L;\n/**\n * Internal data storage.\n */\n// TODO make private?\nprotected char[] buffer;\n/**\n * Current size of the buffer.\n */\n// TODO make private?\nprotected int size;\n/**\n * The new line.\n */\nprivate String newLine;\n/**\n * The null text.\n */\nprivate String nullText;",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "3",
      "Filed": "protected char[] buffer;",
      "Parameter_type": "int,char",
      "Import_statements": "import org.apache.commons.lang3.builder.Builder;\n",
      "public_method_signature": "public StrBuilder();\npublic StrBuilder(int initialCapacity);\npublic StrBuilder(final String str);\npublic String getNewLineText();\npublic StrBuilder setNewLineText(final String newLine);\npublic String getNullText();\npublic StrBuilder setNullText(String nullText);\npublic int length();\npublic StrBuilder setLength(final int length);\npublic int capacity();\npublic StrBuilder ensureCapacity(final int capacity);\npublic StrBuilder minimizeCapacity();\npublic int size();\npublic boolean isEmpty();\npublic StrBuilder clear();\npublic char charAt(final int index);\npublic StrBuilder setCharAt(final int index, final char ch);\npublic StrBuilder deleteCharAt(final int index);\npublic char[] toCharArray();\npublic char[] toCharArray(final int startIndex, int endIndex);\npublic char[] getChars(char[] destination);\npublic void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex);\npublic int readFrom(final Readable readable) throws IOException;\npublic StrBuilder appendNewLine();\npublic StrBuilder appendNull();\npublic StrBuilder append(final Object obj);\npublic StrBuilder append(final CharSequence seq);\npublic StrBuilder append(final CharSequence seq, final int startIndex, final int length);\npublic StrBuilder append(final String str);\npublic StrBuilder append(final String str, final int startIndex, final int length);\npublic StrBuilder append(final String format, final Object... objs);\npublic StrBuilder append(final CharBuffer buf);\npublic StrBuilder append(final CharBuffer buf, final int startIndex, final int length);\npublic StrBuilder append(final StringBuffer str);\npublic StrBuilder append(final StringBuffer str, final int startIndex, final int length);\npublic StrBuilder append(final StringBuilder str);\npublic StrBuilder append(final StringBuilder str, final int startIndex, final int length);\npublic StrBuilder append(final StrBuilder str);\npublic StrBuilder append(final StrBuilder str, final int startIndex, final int length);\npublic StrBuilder append(final char[] chars);\npublic StrBuilder append(final char[] chars, final int startIndex, final int length);\npublic StrBuilder append(final boolean value);\npublic StrBuilder append(final char ch);\npublic StrBuilder append(final int value);\npublic StrBuilder append(final long value);\npublic StrBuilder append(final float value);\npublic StrBuilder append(final double value);\npublic StrBuilder appendln(final Object obj);\npublic StrBuilder appendln(final String str);\npublic StrBuilder appendln(final String str, final int startIndex, final int length);\npublic StrBuilder appendln(final String format, final Object... objs);\npublic StrBuilder appendln(final StringBuffer str);\npublic StrBuilder appendln(final StringBuilder str);\npublic StrBuilder appendln(final StringBuilder str, final int startIndex, final int length);\npublic StrBuilder appendln(final StringBuffer str, final int startIndex, final int length);\npublic StrBuilder appendln(final StrBuilder str);\npublic StrBuilder appendln(final StrBuilder str, final int startIndex, final int length);\npublic StrBuilder appendln(final char[] chars);\npublic StrBuilder appendln(final char[] chars, final int startIndex, final int length);\npublic StrBuilder appendln(final boolean value);\npublic StrBuilder appendln(final char ch);\npublic StrBuilder appendln(final int value);\npublic StrBuilder appendln(final long value);\npublic StrBuilder appendln(final float value);\npublic StrBuilder appendln(final double value);\npublic StrBuilder appendAll(@SuppressWarnings(\"unchecked\") final T... array);\npublic StrBuilder appendAll(final Iterable<?> iterable);\npublic StrBuilder appendAll(final Iterator<?> it);\npublic StrBuilder appendWithSeparators(final Object[] array, final String separator);\npublic StrBuilder appendWithSeparators(final Iterable<?> iterable, final String separator);\npublic StrBuilder appendWithSeparators(final Iterator<?> it, final String separator);\npublic StrBuilder appendSeparator(final String separator);\npublic StrBuilder appendSeparator(final String standard, final String defaultIfEmpty);\npublic StrBuilder appendSeparator(final char separator);\npublic StrBuilder appendSeparator(final char standard, final char defaultIfEmpty);\npublic StrBuilder appendSeparator(final String separator, final int loopIndex);\npublic StrBuilder appendSeparator(final char separator, final int loopIndex);\npublic StrBuilder appendPadding(final int length, final char padChar);\npublic StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar);\npublic StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar);\npublic StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar);\npublic StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar);\npublic StrBuilder insert(final int index, final Object obj);\npublic StrBuilder insert(final int index, String str);\npublic StrBuilder insert(final int index, final char[] chars);\npublic StrBuilder insert(final int index, final char[] chars, final int offset, final int length);\npublic StrBuilder insert(int index, final boolean value);\npublic StrBuilder insert(final int index, final char value);\npublic StrBuilder insert(final int index, final int value);\npublic StrBuilder insert(final int index, final long value);\npublic StrBuilder insert(final int index, final float value);\npublic StrBuilder insert(final int index, final double value);\npublic StrBuilder delete(final int startIndex, int endIndex);\npublic StrBuilder deleteAll(final char ch);\npublic StrBuilder deleteFirst(final char ch);\npublic StrBuilder deleteAll(final String str);\npublic StrBuilder deleteFirst(final String str);\npublic StrBuilder deleteAll(final StrMatcher matcher);\npublic StrBuilder deleteFirst(final StrMatcher matcher);\npublic StrBuilder replace(final int startIndex, int endIndex, final String replaceStr);\npublic StrBuilder replaceAll(final char search, final char replace);\npublic StrBuilder replaceFirst(final char search, final char replace);\npublic StrBuilder replaceAll(final String searchStr, final String replaceStr);\npublic StrBuilder replaceFirst(final String searchStr, final String replaceStr);\npublic StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr);\npublic StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr);\npublic StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount);\npublic StrBuilder reverse();\npublic StrBuilder trim();\npublic boolean startsWith(final String str);\npublic boolean endsWith(final String str);\npublic CharSequence subSequence(final int startIndex, final int endIndex);\npublic String substring(final int start);\npublic String substring(final int startIndex, int endIndex);\npublic String leftString(final int length);\npublic String rightString(final int length);\npublic String midString(int index, final int length);\npublic boolean contains(final char ch);\npublic boolean contains(final String str);\npublic boolean contains(final StrMatcher matcher);\npublic int indexOf(final char ch);\npublic int indexOf(final char ch, int startIndex);\npublic int indexOf(final String str);\npublic int indexOf(final String str, int startIndex);\npublic int indexOf(final StrMatcher matcher);\npublic int indexOf(final StrMatcher matcher, int startIndex);\npublic int lastIndexOf(final char ch);\npublic int lastIndexOf(final char ch, int startIndex);\npublic int lastIndexOf(final String str);\npublic int lastIndexOf(final String str, int startIndex);\npublic int lastIndexOf(final StrMatcher matcher);\npublic int lastIndexOf(final StrMatcher matcher, int startIndex);\npublic StrTokenizer asTokenizer();\npublic Reader asReader();\npublic Writer asWriter();\npublic void appendTo(final Appendable appendable) throws IOException;\npublic boolean equalsIgnoreCase(final StrBuilder other);\npublic boolean equals(final StrBuilder other);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();\npublic StringBuffer toStringBuffer();\npublic StringBuilder toStringBuilder();\npublic String build();",
      "public_field": "",
      "Method_statement": "setCharAt(final int index, final char ch)",
      "Method_name": "setCharAt",
      "Class_declaration": "public class StrBuilder {\n",
      "constructors": "public StrBuilder() {\n    this(CAPACITY);\n}public StrBuilder(int initialCapacity) {\n    super();\n    if (initialCapacity <= 0) {\n        initialCapacity = CAPACITY;\n    }\n    buffer = new char[initialCapacity];\n}public StrBuilder(final String str) {\n    super();\n    if (str == null) {\n        buffer = new char[CAPACITY];\n    } else {\n        buffer = new char[str.length() + CAPACITY];\n        append(str);\n    }\n}",
      "all_method_signature": "public StrBuilder();\npublic StrBuilder(int initialCapacity);\npublic StrBuilder(final String str);\npublic String getNewLineText();\npublic StrBuilder setNewLineText(final String newLine);\npublic String getNullText();\npublic StrBuilder setNullText(String nullText);\npublic int length();\npublic StrBuilder setLength(final int length);\npublic int capacity();\npublic StrBuilder ensureCapacity(final int capacity);\npublic StrBuilder minimizeCapacity();\npublic int size();\npublic boolean isEmpty();\npublic StrBuilder clear();\npublic char charAt(final int index);\npublic StrBuilder setCharAt(final int index, final char ch);\npublic StrBuilder deleteCharAt(final int index);\npublic char[] toCharArray();\npublic char[] toCharArray(final int startIndex, int endIndex);\npublic char[] getChars(char[] destination);\npublic void getChars(final int startIndex, final int endIndex, final char[] destination, final int destinationIndex);\npublic int readFrom(final Readable readable) throws IOException;\npublic StrBuilder appendNewLine();\npublic StrBuilder appendNull();\npublic StrBuilder append(final Object obj);\npublic StrBuilder append(final CharSequence seq);\npublic StrBuilder append(final CharSequence seq, final int startIndex, final int length);\npublic StrBuilder append(final String str);\npublic StrBuilder append(final String str, final int startIndex, final int length);\npublic StrBuilder append(final String format, final Object... objs);\npublic StrBuilder append(final CharBuffer buf);\npublic StrBuilder append(final CharBuffer buf, final int startIndex, final int length);\npublic StrBuilder append(final StringBuffer str);\npublic StrBuilder append(final StringBuffer str, final int startIndex, final int length);\npublic StrBuilder append(final StringBuilder str);\npublic StrBuilder append(final StringBuilder str, final int startIndex, final int length);\npublic StrBuilder append(final StrBuilder str);\npublic StrBuilder append(final StrBuilder str, final int startIndex, final int length);\npublic StrBuilder append(final char[] chars);\npublic StrBuilder append(final char[] chars, final int startIndex, final int length);\npublic StrBuilder append(final boolean value);\npublic StrBuilder append(final char ch);\npublic StrBuilder append(final int value);\npublic StrBuilder append(final long value);\npublic StrBuilder append(final float value);\npublic StrBuilder append(final double value);\npublic StrBuilder appendln(final Object obj);\npublic StrBuilder appendln(final String str);\npublic StrBuilder appendln(final String str, final int startIndex, final int length);\npublic StrBuilder appendln(final String format, final Object... objs);\npublic StrBuilder appendln(final StringBuffer str);\npublic StrBuilder appendln(final StringBuilder str);\npublic StrBuilder appendln(final StringBuilder str, final int startIndex, final int length);\npublic StrBuilder appendln(final StringBuffer str, final int startIndex, final int length);\npublic StrBuilder appendln(final StrBuilder str);\npublic StrBuilder appendln(final StrBuilder str, final int startIndex, final int length);\npublic StrBuilder appendln(final char[] chars);\npublic StrBuilder appendln(final char[] chars, final int startIndex, final int length);\npublic StrBuilder appendln(final boolean value);\npublic StrBuilder appendln(final char ch);\npublic StrBuilder appendln(final int value);\npublic StrBuilder appendln(final long value);\npublic StrBuilder appendln(final float value);\npublic StrBuilder appendln(final double value);\npublic StrBuilder appendAll(@SuppressWarnings(\"unchecked\") final T... array);\npublic StrBuilder appendAll(final Iterable<?> iterable);\npublic StrBuilder appendAll(final Iterator<?> it);\npublic StrBuilder appendWithSeparators(final Object[] array, final String separator);\npublic StrBuilder appendWithSeparators(final Iterable<?> iterable, final String separator);\npublic StrBuilder appendWithSeparators(final Iterator<?> it, final String separator);\npublic StrBuilder appendSeparator(final String separator);\npublic StrBuilder appendSeparator(final String standard, final String defaultIfEmpty);\npublic StrBuilder appendSeparator(final char separator);\npublic StrBuilder appendSeparator(final char standard, final char defaultIfEmpty);\npublic StrBuilder appendSeparator(final String separator, final int loopIndex);\npublic StrBuilder appendSeparator(final char separator, final int loopIndex);\npublic StrBuilder appendPadding(final int length, final char padChar);\npublic StrBuilder appendFixedWidthPadLeft(final Object obj, final int width, final char padChar);\npublic StrBuilder appendFixedWidthPadLeft(final int value, final int width, final char padChar);\npublic StrBuilder appendFixedWidthPadRight(final Object obj, final int width, final char padChar);\npublic StrBuilder appendFixedWidthPadRight(final int value, final int width, final char padChar);\npublic StrBuilder insert(final int index, final Object obj);\npublic StrBuilder insert(final int index, String str);\npublic StrBuilder insert(final int index, final char[] chars);\npublic StrBuilder insert(final int index, final char[] chars, final int offset, final int length);\npublic StrBuilder insert(int index, final boolean value);\npublic StrBuilder insert(final int index, final char value);\npublic StrBuilder insert(final int index, final int value);\npublic StrBuilder insert(final int index, final long value);\npublic StrBuilder insert(final int index, final float value);\npublic StrBuilder insert(final int index, final double value);\nprivate void deleteImpl(final int startIndex, final int endIndex, final int len);\npublic StrBuilder delete(final int startIndex, int endIndex);\npublic StrBuilder deleteAll(final char ch);\npublic StrBuilder deleteFirst(final char ch);\npublic StrBuilder deleteAll(final String str);\npublic StrBuilder deleteFirst(final String str);\npublic StrBuilder deleteAll(final StrMatcher matcher);\npublic StrBuilder deleteFirst(final StrMatcher matcher);\nprivate void replaceImpl(final int startIndex, final int endIndex, final int removeLen, final String insertStr, final int insertLen);\npublic StrBuilder replace(final int startIndex, int endIndex, final String replaceStr);\npublic StrBuilder replaceAll(final char search, final char replace);\npublic StrBuilder replaceFirst(final char search, final char replace);\npublic StrBuilder replaceAll(final String searchStr, final String replaceStr);\npublic StrBuilder replaceFirst(final String searchStr, final String replaceStr);\npublic StrBuilder replaceAll(final StrMatcher matcher, final String replaceStr);\npublic StrBuilder replaceFirst(final StrMatcher matcher, final String replaceStr);\npublic StrBuilder replace(final StrMatcher matcher, final String replaceStr, final int startIndex, int endIndex, final int replaceCount);\nprivate StrBuilder replaceImpl(final StrMatcher matcher, final String replaceStr, final int from, int to, int replaceCount);\npublic StrBuilder reverse();\npublic StrBuilder trim();\npublic boolean startsWith(final String str);\npublic boolean endsWith(final String str);\npublic CharSequence subSequence(final int startIndex, final int endIndex);\npublic String substring(final int start);\npublic String substring(final int startIndex, int endIndex);\npublic String leftString(final int length);\npublic String rightString(final int length);\npublic String midString(int index, final int length);\npublic boolean contains(final char ch);\npublic boolean contains(final String str);\npublic boolean contains(final StrMatcher matcher);\npublic int indexOf(final char ch);\npublic int indexOf(final char ch, int startIndex);\npublic int indexOf(final String str);\npublic int indexOf(final String str, int startIndex);\npublic int indexOf(final StrMatcher matcher);\npublic int indexOf(final StrMatcher matcher, int startIndex);\npublic int lastIndexOf(final char ch);\npublic int lastIndexOf(final char ch, int startIndex);\npublic int lastIndexOf(final String str);\npublic int lastIndexOf(final String str, int startIndex);\npublic int lastIndexOf(final StrMatcher matcher);\npublic int lastIndexOf(final StrMatcher matcher, int startIndex);\npublic StrTokenizer asTokenizer();\npublic Reader asReader();\npublic Writer asWriter();\npublic void appendTo(final Appendable appendable) throws IOException;\npublic boolean equalsIgnoreCase(final StrBuilder other);\npublic boolean equals(final StrBuilder other);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();\npublic StringBuffer toStringBuffer();\npublic StringBuilder toStringBuilder();\npublic String build();\nprotected int validateRange(final int startIndex, int endIndex);\nprotected void validateIndex(final int index);",
      "Class_name": "StrBuilder",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/text/StrBuilder###setCharAt",
      "Parameter_num": "2",
      "all_Import_statements": "import java.io.IOException;\n\nimport java.io.Reader;\n\nimport java.io.Serializable;\n\nimport java.io.Writer;\n\nimport java.nio.CharBuffer;\n\nimport java.util.Iterator;\n\nimport java.util.List;\n\nimport java.util.Objects;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\nimport org.apache.commons.lang3.CharUtils;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport org.apache.commons.lang3.builder.Builder;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * Sets the character at the specified index.\n     *\n     * @see #charAt(int)\n     * @see #deleteCharAt(int)\n     * @param index  the index to set\n     * @param ch  the new character\n     * @return this, to enable chaining\n     * @throws IndexOutOfBoundsException if the index is invalid\n     ",
      "packageName": "org.apache.commons.lang3.text",
      "method_signature": "public StrBuilder setCharAt(final int index, final char ch);",
      "Junit_version": "4",
      "returnType": "StrBuilder"
    },
    "Test_method": {
      "Method_body": "final StrBuilder sb = new StrBuilder();\n\rtry {\n    sb.setCharAt(0, 'f');\n    fail(\"setCharAt(0,) expected IndexOutOfBoundsException\");\n} catch (final IndexOutOfBoundsException e) {\n    // expected\n}\n\rtry {\n    sb.setCharAt(-1, 'f');\n    fail(\"setCharAt(-1,) expected IndexOutOfBoundsException\");\n} catch (final IndexOutOfBoundsException e) {\n    // expected\n}\n\rsb.append(\"foo\");\n\rsb.setCharAt(0, 'b');\n\rsb.setCharAt(1, 'a');\n\rsb.setCharAt(2, 'r');\n\rtry {\n    sb.setCharAt(3, '!');\n    fail(\"setCharAt(3,) expected IndexOutOfBoundsException\");\n} catch (final IndexOutOfBoundsException e) {\n    // expected\n}\n\rassertEquals(\"bar\", sb.toString());",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "9",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n",
      "allMethod_info": "// -----------------------------------------------------------------------\n@Test\npublic void testSetCharAt() {\n    final StrBuilder sb = new StrBuilder();\n    try {\n        sb.setCharAt(0, 'f');\n        fail(\"setCharAt(0,) expected IndexOutOfBoundsException\");\n    } catch (final IndexOutOfBoundsException e) {\n        // expected\n    }\n    try {\n        sb.setCharAt(-1, 'f');\n        fail(\"setCharAt(-1,) expected IndexOutOfBoundsException\");\n    } catch (final IndexOutOfBoundsException e) {\n        // expected\n    }\n    sb.append(\"foo\");\n    sb.setCharAt(0, 'b');\n    sb.setCharAt(1, 'a');\n    sb.setCharAt(2, 'r');\n    try {\n        sb.setCharAt(3, '!');\n        fail(\"setCharAt(3,) expected IndexOutOfBoundsException\");\n    } catch (final IndexOutOfBoundsException e) {\n        // expected\n    }\n    assertEquals(\"bar\", sb.toString());\n}",
      "Method_name": "testSetCharAt",
      "Class_declaration": "public class StrBuilderTest {\n",
      "constructors": "",
      "Class_name": "StrBuilderTest",
      "methodName_paraNum": "[setCharAt(2), fail(1), setCharAt(2), fail(1), append(1), setCharAt(2), setCharAt(2), setCharAt(2), setCharAt(2), fail(1), toString(0)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/text/StrBuilderTest###testSetCharAt",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/text/StrBuilderTest.java",
      "Signature": "public void testSetCharAt() {\n",
      "all_Import_statements": "import org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertNotSame;\n\nimport static org.junit.Assert.assertNull;\n\nimport static org.junit.Assert.assertSame;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.junit.Assert.fail;\n\nimport java.io.IOException;\n\nimport java.io.Reader;\n\nimport java.io.StringReader;\n\nimport java.io.StringWriter;\n\nimport java.io.Writer;\n\nimport java.nio.CharBuffer;\n\nimport java.util.Arrays;\n\nimport org.apache.commons.lang3.ArrayUtils;\n",
      "comment": "-----------------------------------------------------------------------",
      "packageName": "org.apache.commons.lang3.text",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static int[] balancePair(String str, String left, String right) {\n    int count = 0;\n    int offset = 0;\n    int firstLeft = -1;\n    while (true) {\n        int leftIndex = str.indexOf(left, offset);\n        int rightIndex = str.indexOf(right, offset);\n        if (leftIndex == rightIndex) {\n            return new int[] { firstLeft, -1 };\n        } else if ((leftIndex < rightIndex && leftIndex != -1) || rightIndex == -1) {\n            if (firstLeft == -1) {\n                firstLeft = leftIndex;\n            }\n            count++;\n            offset = leftIndex + 1;\n        } else {\n            count--;\n            offset = rightIndex + 1;\n            if (count < 0) {\n                return new int[] { firstLeft, -1 };\n            }\n            if (count == 0) {\n                return new int[] { firstLeft, rightIndex };\n            }\n        }\n    }\n}",
      "all_field_declaration": "",
      "sub_project_name": "XDean_Java-EX",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "String,String,String",
      "Import_statements": "",
      "public_method_signature": "public static String replaceExcept(String origin, String from, String to, String except);\npublic static Iterator<Character> notExistChars(String s);\npublic static String repeat(String st, int times);\npublic static int firstIndexOf(String str, String... ts);\npublic static int lastIndexOf(String str, String... ts);\npublic static String replacePart(String sourceText, int from, int to, String replaceText);\npublic static String unWrap(String str, String left, String right);\npublic static int[] balancePair(String str, String left, String right);\npublic static boolean isControlCharacter(char c);\npublic static int countLine(String str);\npublic static boolean isEmpty(String str);\npublic static boolean notEmpty(String str);\npublic static String upperFirst(String st);\npublic static int indexOfIgnoreCase(String str, String target);\npublic static int indexOfIgnoreCase(String str, String target, int startIndex);\npublic static String encode(String str);\npublic static String decode(String str);\npublic static String camelToUnderline(String param);",
      "public_field": "",
      "Method_statement": "balancePair(String str, String left, String right)",
      "Method_name": "balancePair",
      "Class_declaration": "public class StringUtil {\n",
      "constructors": "",
      "all_method_signature": "public static String replaceExcept(String origin, String from, String to, String except);\npublic static Iterator<Character> notExistChars(String s);\npublic static String repeat(String st, int times);\npublic static int firstIndexOf(String str, String... ts);\npublic static int lastIndexOf(String str, String... ts);\npublic static String replacePart(String sourceText, int from, int to, String replaceText);\npublic static String unWrap(String str, String left, String right);\npublic static int[] balancePair(String str, String left, String right);\npublic static boolean isControlCharacter(char c);\npublic static int countLine(String str);\npublic static boolean isEmpty(String str);\npublic static boolean notEmpty(String str);\npublic static String upperFirst(String st);\npublic static int indexOfIgnoreCase(String str, String target);\npublic static int indexOfIgnoreCase(String str, String target, int startIndex);\npublic static String encode(String str);\npublic static String decode(String str);\npublic static String camelToUnderline(String param);",
      "Class_name": "StringUtil",
      "project_path": "XDean_Java-EX###XDean_Java-EX/src/main/java/cn/xdean/jex/lang/StringUtil###balancePair",
      "Parameter_num": "3",
      "all_Import_statements": "import cn.xdean.jex.lang.collection.IntList;\n\nimport com.google.common.collect.Ordering;\n\nimport java.util.Base64;\n\nimport java.util.Iterator;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.stream.Stream;\n",
      "comment": "\n   * Get the first balance pair substring index.\n   *\n   * @param str the string\n   * @param left left symbol\n   * @param right right symbol\n   * @return (leftIndex, rightIndex) If not found, rightIndex is -1.\n   ",
      "packageName": "cn.xdean.jex.lang",
      "method_signature": "public static int[] balancePair(String str, String left, String right);",
      "Junit_version": "4",
      "returnType": "int[]"
    },
    "Test_method": {
      "Method_body": "String str = \"a{b{c}d}{e}f{g}h}i}\";\n\rint[] pair = balancePair(str, \"{\", \"}\");\n\rassertEquals(\"{b{c}d}\", str.substring(pair[0], pair[1] + 1));\n\rstr = \"a{b{c{d{e}f}g}\";\n\rpair = balancePair(str, \"{\", \"}\");\n\rassertEquals(1, pair[0]);\n\rassertEquals(-1, pair[1]);",
      "sub_project_name": "XDean_Java-EX",
      "lineNumbers": "7",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "@Test\npublic void testBalancePair() {\n    String str = \"a{b{c}d}{e}f{g}h}i}\";\n    int[] pair = balancePair(str, \"{\", \"}\");\n    assertEquals(\"{b{c}d}\", str.substring(pair[0], pair[1] + 1));\n    str = \"a{b{c{d{e}f}g}\";\n    pair = balancePair(str, \"{\", \"}\");\n    assertEquals(1, pair[0]);\n    assertEquals(-1, pair[1]);\n}",
      "Method_name": "testBalancePair",
      "Class_declaration": "public class StringUtilTest {\n",
      "constructors": "",
      "Class_name": "StringUtilTest",
      "methodName_paraNum": "[balancePair(3), substring(2), balancePair(3)]",
      "project_path": "XDean_Java-EX###XDean_Java-EX/src/test/java/cn/xdean/jex/lang/StringUtilTest###testBalancePair",
      "relativePath": "XDean_Java-EX/src/test/java/cn/xdean/jex/lang/StringUtilTest.java",
      "Signature": "public void testBalancePair() {\n",
      "all_Import_statements": "import io.reactivex.Flowable;\n\nimport org.junit.Test;\n\nimport org.junit.experimental.theories.Theories;\n\nimport org.junit.experimental.theories.Theory;\n\nimport org.junit.experimental.theories.suppliers.TestedOn;\n\nimport org.junit.runner.RunWith;\n\nimport java.util.stream.IntStream;\n\nimport static cn.xdean.jex.lang.StringUtil.*;\n\nimport static org.junit.Assert.assertEquals;\n",
      "comment": "",
      "packageName": "cn.xdean.jex.lang",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static Token generate(final SecureRandom random, final Key key, final byte[] payload) {\n    final IvParameterSpec initializationVector = generateInitializationVector(random);\n    final byte[] cipherText = key.encrypt(payload, initializationVector);\n    final Instant timestamp = Instant.now();\n    final byte[] hmac = key.sign(supportedVersion, timestamp, initializationVector, cipherText);\n    return new Token(supportedVersion, timestamp, initializationVector, cipherText, hmac);\n}",
      "all_field_declaration": "private final byte version;\nprivate final Instant timestamp;\nprivate final IvParameterSpec initializationVector;\nprivate final byte[] cipherText;\nprivate final byte[] hmac;",
      "sub_project_name": "fernet-java8",
      "lineNumbers": "5",
      "Filed": "private final Instant timestamp;private final IvParameterSpec initializationVector;private final byte[] cipherText;private final byte[] hmac;",
      "Parameter_type": "SecureRandom,Key,byte[]",
      "Import_statements": "import static com.macasaet.fernet.Constants.supportedVersion;\nimport java.security.SecureRandom;\nimport java.time.Instant;\nimport javax.crypto.spec.IvParameterSpec;\n",
      "public_method_signature": "public static Token fromBytes(final byte[] bytes);\npublic static Token fromString(final String string);\npublic static Token generate(final Key key, final String plainText);\npublic static Token generate(final SecureRandom random, final Key key, final String plainText);\npublic static Token generate(final Key key, final byte[] payload);\npublic static Token generate(final SecureRandom random, final Key key, final byte[] payload);\npublic T validateAndDecrypt(final Key key, final Validator<T> validator);\npublic T validateAndDecrypt(final Collection<? extends Key> keys, final Validator<T> validator);\npublic String serialise();\npublic void writeTo(final OutputStream outputStream) throws IOException;\npublic byte getVersion();\npublic Instant getTimestamp();\npublic IvParameterSpec getInitializationVector();\npublic String toString();\npublic boolean isValidSignature(final Key key);",
      "public_field": "",
      "Method_statement": "generate(final SecureRandom random, final Key key, final byte() payload)",
      "Method_name": "generate",
      "Class_declaration": "public class Token {\n",
      "constructors": "@SuppressWarnings({ \"PMD.ArrayIsStoredDirectly\", \"PMD.CyclomaticComplexity\" })\nprotected Token(final byte version, final Instant timestamp, final IvParameterSpec initializationVector, final byte[] cipherText, final byte[] hmac) {\n    if (version != supportedVersion) {\n        throw new IllegalTokenException(\"Unsupported version: \" + version);\n    }\n    if (timestamp == null) {\n        throw new IllegalTokenException(\"timestamp cannot be null\");\n    }\n    if (initializationVector == null || initializationVector.getIV().length != initializationVectorBytes) {\n        throw new IllegalTokenException(\"Initialization Vector must be 128 bits\");\n    }\n    if (cipherText == null || cipherText.length % cipherTextBlockSize != 0) {\n        throw new IllegalTokenException(\"Ciphertext must be a multiple of 128 bits\");\n    }\n    if (hmac == null || hmac.length != signatureBytes) {\n        throw new IllegalTokenException(\"hmac must be 256 bits\");\n    }\n    this.version = version;\n    this.timestamp = timestamp;\n    this.initializationVector = initializationVector;\n    this.cipherText = cipherText;\n    this.hmac = hmac;\n}",
      "all_method_signature": "protected Token(final byte version, final Instant timestamp, final IvParameterSpec initializationVector, final byte[] cipherText, final byte[] hmac);\npublic static Token fromBytes(final byte[] bytes);\nprotected static byte[] read(final DataInputStream stream, final int numBytes) throws IOException;\npublic static Token fromString(final String string);\npublic static Token generate(final Key key, final String plainText);\npublic static Token generate(final SecureRandom random, final Key key, final String plainText);\npublic static Token generate(final Key key, final byte[] payload);\npublic static Token generate(final SecureRandom random, final Key key, final byte[] payload);\npublic T validateAndDecrypt(final Key key, final Validator<T> validator);\npublic T validateAndDecrypt(final Collection<? extends Key> keys, final Validator<T> validator);\nprotected byte[] validateAndDecrypt(final Key key, final Instant earliestValidInstant, final Instant latestValidInstant);\npublic String serialise();\npublic void writeTo(final OutputStream outputStream) throws IOException;\npublic byte getVersion();\npublic Instant getTimestamp();\npublic IvParameterSpec getInitializationVector();\npublic String toString();\nprotected static IvParameterSpec generateInitializationVector(final SecureRandom random);\nprotected static byte[] generateInitializationVectorBytes(final SecureRandom random);\npublic boolean isValidSignature(final Key key);\nprotected Encoder getEncoder();\nprotected byte[] getCipherText();\nprotected byte[] getHmac();",
      "Class_name": "Token",
      "project_path": "l0s_fernet-java8###l0s_fernet-java8/fernet-java8/src/main/java/com/macasaet/fernet/Token###generate",
      "Parameter_num": "3",
      "all_Import_statements": "import static com.macasaet.fernet.Constants.charset;\n\nimport static com.macasaet.fernet.Constants.cipherTextBlockSize;\n\nimport static com.macasaet.fernet.Constants.decoder;\n\nimport static com.macasaet.fernet.Constants.encoder;\n\nimport static com.macasaet.fernet.Constants.initializationVectorBytes;\n\nimport static com.macasaet.fernet.Constants.minimumTokenBytes;\n\nimport static com.macasaet.fernet.Constants.signatureBytes;\n\nimport static com.macasaet.fernet.Constants.supportedVersion;\n\nimport static com.macasaet.fernet.Constants.tokenStaticBytes;\n\nimport java.io.ByteArrayInputStream;\n\nimport java.io.ByteArrayOutputStream;\n\nimport java.io.DataInputStream;\n\nimport java.io.DataOutputStream;\n\nimport java.io.IOException;\n\nimport java.io.OutputStream;\n\nimport java.math.BigInteger;\n\nimport java.security.MessageDigest;\n\nimport java.security.SecureRandom;\n\nimport java.time.Instant;\n\nimport java.util.Base64.Encoder;\n\nimport java.util.Collection;\n\nimport javax.crypto.spec.IvParameterSpec;\n",
      "comment": "\n     * Generate a new Fernet token.\n     *\n     * @param random a source of entropy for your application\n     * @param key the secret key for encrypting <em>payload</em> and signing the token\n     * @param payload the unencrypted data to embed in the token\n     * @return a unique Fernet token\n     ",
      "packageName": "com.macasaet.fernet",
      "method_signature": "public static Token generate(final SecureRandom random, final Key key, final byte[] payload);",
      "Junit_version": "4",
      "returnType": "Token"
    },
    "Test_method": {
      "Method_body": "// given\nfinal SecureRandom deterministicRandom = new SecureRandom() {\n\n    private static final long serialVersionUID = 3075400891983079965L;\n\n    public void nextBytes(final byte[] bytes) {\n        for (int i = bytes.length; --i >= 0; bytes[i] = 1) ;\n    }\n};\n\rfinal Key key = Key.generateKey(deterministicRandom);\n\r// when\nfinal Token result = Token.generate(deterministicRandom, key, \"Hello, world!\");\n\r// then\nfinal String plainText = result.validateAndDecrypt(key, validator);\n\rassertEquals(\"Hello, world!\", plainText);",
      "sub_project_name": "fernet-java8",
      "lineNumbers": "5",
      "Filed": "private Validator<String> validator;",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport java.security.SecureRandom;\n",
      "allMethod_info": "@Test\npublic void testGenerate() {\n    // given\n    final SecureRandom deterministicRandom = new SecureRandom() {\n\n        private static final long serialVersionUID = 3075400891983079965L;\n\n        public void nextBytes(final byte[] bytes) {\n            for (int i = bytes.length; --i >= 0; bytes[i] = 1) ;\n        }\n    };\n    final Key key = Key.generateKey(deterministicRandom);\n    // when\n    final Token result = Token.generate(deterministicRandom, key, \"Hello, world!\");\n    // then\n    final String plainText = result.validateAndDecrypt(key, validator);\n    assertEquals(\"Hello, world!\", plainText);\n}",
      "Method_name": "testGenerate",
      "Class_declaration": "public class TokenTest {\n",
      "constructors": "",
      "Class_name": "TokenTest",
      "methodName_paraNum": "[generateKey(1), generate(3), validateAndDecrypt(2)]",
      "project_path": "l0s_fernet-java8###l0s_fernet-java8/fernet-java8/src/test/java/com/macasaet/fernet/TokenTest###testGenerate",
      "relativePath": "l0s_fernet-java8/fernet-java8/src/test/java/com/macasaet/fernet/TokenTest.java",
      "Signature": "public void testGenerate() {\n",
      "all_Import_statements": "import static com.macasaet.fernet.Constants.initializationVectorBytes;\n\nimport static java.util.stream.Collectors.toList;\n\nimport static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertThrows;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.mutabilitydetector.unittesting.AllowedReason.allowingForSubclassing;\n\nimport static org.mutabilitydetector.unittesting.AllowedReason.assumingFields;\n\nimport static org.mutabilitydetector.unittesting.AllowedReason.provided;\n\nimport static org.mutabilitydetector.unittesting.MutabilityAssert.assertInstancesOf;\n\nimport static org.mutabilitydetector.unittesting.MutabilityMatchers.areImmutable;\n\nimport java.security.SecureRandom;\n\nimport java.time.Instant;\n\nimport java.time.format.DateTimeFormatter;\n\nimport java.util.List;\n\nimport java.util.stream.IntStream;\n\nimport javax.crypto.spec.IvParameterSpec;\n\nimport org.junit.Before;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "com.macasaet.fernet",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static Class<?> getRawType(final Type type, final Type assigningType) {\n    if (type instanceof Class<?>) {\n        return (Class<?>) type;\n    }\n    if (type instanceof ParameterizedType) {\n        return getRawType((ParameterizedType) type);\n    }\n    if (type instanceof TypeVariable<?>) {\n        if (assigningType == null) {\n            return null;\n        }\n        final Object genericDeclaration = ((TypeVariable<?>) type).getGenericDeclaration();\n        if (!(genericDeclaration instanceof Class<?>)) {\n            return null;\n        }\n        final Map<TypeVariable<?>, Type> typeVarAssigns = getTypeArguments(assigningType, (Class<?>) genericDeclaration);\n        if (typeVarAssigns == null) {\n            return null;\n        }\n        final Type typeArgument = typeVarAssigns.get(type);\n        if (typeArgument == null) {\n            return null;\n        }\n        return getRawType(typeArgument, assigningType);\n    }\n    if (type instanceof GenericArrayType) {\n        final Class<?> rawComponentType = getRawType(((GenericArrayType) type).getGenericComponentType(), assigningType);\n        return Array.newInstance(rawComponentType, 0).getClass();\n    }\n    if (type instanceof WildcardType) {\n        return null;\n    }\n    throw new IllegalArgumentException(\"unknown type: \" + type);\n}",
      "all_field_declaration": "/**\n * A wildcard instance matching {@code ?}.\n * @since 3.2\n */\npublic static final WildcardType WILDCARD_ALL = wildcardType().withUpperBounds(Object.class).build();",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "6",
      "Filed": "",
      "Parameter_type": "Type,Type",
      "Import_statements": "import java.lang.reflect.Array;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.GenericDeclaration;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport java.util.Map;\n",
      "public_method_signature": "public TypeUtils();\npublic static boolean isAssignable(final Type type, final Type toType);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType type);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass);\npublic static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType);\npublic static boolean isInstance(final Object value, final Type type);\npublic static Type[] normalizeUpperBounds(final Type[] bounds);\npublic static Type[] getImplicitBounds(final TypeVariable<?> typeVariable);\npublic static Type[] getImplicitUpperBounds(final WildcardType wildcardType);\npublic static Type[] getImplicitLowerBounds(final WildcardType wildcardType);\npublic static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns);\npublic static Class<?> getRawType(final Type type, final Type assigningType);\npublic static boolean isArrayType(final Type type);\npublic static Type getArrayComponentType(final Type type);\npublic static Type unrollVariables(Map<TypeVariable<?>, Type> typeArguments, final Type type);\npublic static boolean containsTypeVariables(final Type type);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static WildcardTypeBuilder wildcardType();\npublic static GenericArrayType genericArrayType(final Type componentType);\npublic static boolean equals(final Type t1, final Type t2);\npublic static String toString(final Type type);\npublic static String toLongString(final TypeVariable<?> var);\npublic static Typed<T> wrap(final Type type);\npublic static Typed<T> wrap(final Class<T> type);",
      "public_field": "/**\n * A wildcard instance matching {@code ?}.\n * @since 3.2\n */\npublic static final WildcardType WILDCARD_ALL = wildcardType().withUpperBounds(Object.class).build();",
      "Method_statement": "getRawType(final Type type, final Type assigningType)",
      "Method_name": "getRawType",
      "Class_declaration": "public class TypeUtils {\n",
      "constructors": "public TypeUtils() {\n    super();\n}",
      "all_method_signature": "public TypeUtils();\npublic static boolean isAssignable(final Type type, final Type toType);\nprivate static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final Class<?> toClass);\nprivate static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final TypeVariable<?> toTypeVariable, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType type);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\npublic static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType);\nprivate static void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type getClosestParentType(final Class<?> cls, final Class<?> superClass);\npublic static boolean isInstance(final Object value, final Type type);\npublic static Type[] normalizeUpperBounds(final Type[] bounds);\npublic static Type[] getImplicitBounds(final TypeVariable<?> typeVariable);\npublic static Type[] getImplicitUpperBounds(final WildcardType wildcardType);\npublic static Type[] getImplicitLowerBounds(final WildcardType wildcardType);\npublic static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Class<?> getRawType(final ParameterizedType parameterizedType);\npublic static Class<?> getRawType(final Type type, final Type assigningType);\npublic static boolean isArrayType(final Type type);\npublic static Type getArrayComponentType(final Type type);\npublic static Type unrollVariables(Map<TypeVariable<?>, Type> typeArguments, final Type type);\nprivate static Type[] unrollBounds(final Map<TypeVariable<?>, Type> typeArguments, final Type[] bounds);\npublic static boolean containsTypeVariables(final Type type);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\nprivate static Type[] extractTypeArgumentsFrom(final Map<TypeVariable<?>, Type> mappings, final TypeVariable<?>[] variables);\npublic static WildcardTypeBuilder wildcardType();\npublic static GenericArrayType genericArrayType(final Type componentType);\npublic static boolean equals(final Type t1, final Type t2);\nprivate static boolean equals(final ParameterizedType p, final Type t);\nprivate static boolean equals(final GenericArrayType a, final Type t);\nprivate static boolean equals(final WildcardType w, final Type t);\nprivate static boolean equals(final Type[] t1, final Type[] t2);\npublic static String toString(final Type type);\npublic static String toLongString(final TypeVariable<?> var);\npublic static Typed<T> wrap(final Type type);\npublic static Typed<T> wrap(final Class<T> type);\nprivate static String classToString(final Class<?> c);\nprivate static String typeVariableToString(final TypeVariable<?> v);\nprivate static String parameterizedTypeToString(final ParameterizedType p);\nprivate static void appendRecursiveTypes(final StringBuilder buf, final int[] recursiveTypeIndexes, final Type[] argumentTypes);\nprivate static int[] findRecursiveTypes(final ParameterizedType p);\nprivate static boolean containsVariableTypeSameParametrizedTypeBound(final TypeVariable<?> typeVariable, final ParameterizedType p);\nprivate static String wildcardTypeToString(final WildcardType w);\nprivate static String genericArrayTypeToString(final GenericArrayType g);\nprivate static StringBuilder appendAllTo(final StringBuilder buf, final String sep, final T... types);\nprivate static String toString(final T object);",
      "Class_name": "TypeUtils",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/reflect/TypeUtils###getRawType",
      "Parameter_num": "2",
      "all_Import_statements": "import java.lang.reflect.Array;\n\nimport java.lang.reflect.GenericArrayType;\n\nimport java.lang.reflect.GenericDeclaration;\n\nimport java.lang.reflect.ParameterizedType;\n\nimport java.lang.reflect.Type;\n\nimport java.lang.reflect.TypeVariable;\n\nimport java.lang.reflect.WildcardType;\n\nimport java.util.Arrays;\n\nimport java.util.Collections;\n\nimport java.util.HashMap;\n\nimport java.util.HashSet;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Objects;\n\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\nimport org.apache.commons.lang3.ClassUtils;\n\nimport org.apache.commons.lang3.ObjectUtils;\n\nimport org.apache.commons.lang3.Validate;\n\nimport org.apache.commons.lang3.builder.Builder;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>Get the raw type of a Java type, given its context. Primarily for use\n     * with {@link TypeVariable}s and {@link GenericArrayType}s, or when you do\n     * not know the runtime type of {@code type}: if you know you have a\n     * {@link Class} instance, it is already raw; if you know you have a\n     * {@link ParameterizedType}, its raw type is only a method call away.</p>\n     *\n     * @param type to resolve\n     * @param assigningType type to be resolved against\n     * @return the resolved {@link Class} object or {@code null} if\n     * the type could not be resolved\n     ",
      "packageName": "org.apache.commons.lang3.reflect",
      "method_signature": "public static Class<?> getRawType(final Type type, final Type assigningType);",
      "Junit_version": "4",
      "returnType": "Class<?>"
    },
    "Test_method": {
      "Method_body": "final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField(\"stringParent\").getGenericType();\n\rfinal Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField(\"integerParent\").getGenericType();\n\rfinal Type foosFieldType = GenericTypeHolder.class.getDeclaredField(\"foos\").getGenericType();\n\rfinal Type genericParentT = GenericParent.class.getTypeParameters()[0];\n\rassertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null));\n\rassertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, null));\n\rassertEquals(List.class, TypeUtils.getRawType(foosFieldType, null));\n\rassertEquals(String.class, TypeUtils.getRawType(genericParentT, StringParameterizedChild.class));\n\rassertEquals(String.class, TypeUtils.getRawType(genericParentT, stringParentFieldType));\n\rassertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], foosFieldType));\n\rassertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], foosFieldType));\n\rassertNull(TypeUtils.getRawType(genericParentT, GenericParent.class));\n\rassertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class.getDeclaredField(\"barParents\").getGenericType(), null));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "13",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Type;\nimport java.util.List;\nimport org.apache.commons.lang3.reflect.testbed.Foo;\nimport org.apache.commons.lang3.reflect.testbed.GenericParent;\nimport org.apache.commons.lang3.reflect.testbed.GenericTypeHolder;\nimport org.apache.commons.lang3.reflect.testbed.StringParameterizedChild;\n",
      "allMethod_info": "@Test\npublic void testGetRawType() throws SecurityException, NoSuchFieldException {\n    final Type stringParentFieldType = GenericTypeHolder.class.getDeclaredField(\"stringParent\").getGenericType();\n    final Type integerParentFieldType = GenericTypeHolder.class.getDeclaredField(\"integerParent\").getGenericType();\n    final Type foosFieldType = GenericTypeHolder.class.getDeclaredField(\"foos\").getGenericType();\n    final Type genericParentT = GenericParent.class.getTypeParameters()[0];\n    assertEquals(GenericParent.class, TypeUtils.getRawType(stringParentFieldType, null));\n    assertEquals(GenericParent.class, TypeUtils.getRawType(integerParentFieldType, null));\n    assertEquals(List.class, TypeUtils.getRawType(foosFieldType, null));\n    assertEquals(String.class, TypeUtils.getRawType(genericParentT, StringParameterizedChild.class));\n    assertEquals(String.class, TypeUtils.getRawType(genericParentT, stringParentFieldType));\n    assertEquals(Foo.class, TypeUtils.getRawType(Iterable.class.getTypeParameters()[0], foosFieldType));\n    assertEquals(Foo.class, TypeUtils.getRawType(List.class.getTypeParameters()[0], foosFieldType));\n    assertNull(TypeUtils.getRawType(genericParentT, GenericParent.class));\n    assertEquals(GenericParent[].class, TypeUtils.getRawType(GenericTypeHolder.class.getDeclaredField(\"barParents\").getGenericType(), null));\n}",
      "Method_name": "testGetRawType",
      "Class_declaration": "public class TypeUtilsTest {\n",
      "constructors": "",
      "Class_name": "TypeUtilsTest",
      "methodName_paraNum": "[getGenericType(0), getDeclaredField(1), getGenericType(0), getDeclaredField(1), getGenericType(0), getDeclaredField(1), getTypeParameters(0), getRawType(2), getRawType(2), getRawType(2), getRawType(2), getRawType(2), getRawType(2), getTypeParameters(0), getRawType(2), getTypeParameters(0), getRawType(2), getRawType(2), getGenericType(0), getDeclaredField(1)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest###testGetRawType",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java",
      "Signature": "public void testGetRawType() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNull;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.Serializable;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.GenericArrayType;\n\nimport java.lang.reflect.Method;\n\nimport java.lang.reflect.ParameterizedType;\n\nimport java.lang.reflect.Type;\n\nimport java.lang.reflect.TypeVariable;\n\nimport java.lang.reflect.WildcardType;\n\nimport java.net.URI;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collection;\n\nimport java.util.HashMap;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.TreeSet;\n\nimport org.apache.commons.lang3.reflect.testbed.Foo;\n\nimport org.apache.commons.lang3.reflect.testbed.GenericParent;\n\nimport org.apache.commons.lang3.reflect.testbed.GenericTypeHolder;\n\nimport org.apache.commons.lang3.reflect.testbed.StringParameterizedChild;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3.reflect",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "private static boolean isAssignable(final Type type, final Class<?> toClass) {\n    if (type == null) {\n        return toClass == null || !toClass.isPrimitive();\n    }\n    if (toClass == null) {\n        return false;\n    }\n    if (toClass.equals(type)) {\n        return true;\n    }\n    if (type instanceof Class<?>) {\n        return ClassUtils.isAssignable((Class<?>) type, toClass);\n    }\n    if (type instanceof ParameterizedType) {\n        return isAssignable(getRawType((ParameterizedType) type), toClass);\n    }\n    if (type instanceof TypeVariable<?>) {\n        for (final Type bound : ((TypeVariable<?>) type).getBounds()) {\n            if (isAssignable(bound, toClass)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (type instanceof GenericArrayType) {\n        return toClass.equals(Object.class) || toClass.isArray() && isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass.getComponentType());\n    }\n    if (type instanceof WildcardType) {\n        return false;\n    }\n    throw new IllegalStateException(\"found an unhandled type: \" + type);\n}",
      "all_field_declaration": "/**\n * A wildcard instance matching {@code ?}.\n * @since 3.2\n */\npublic static final WildcardType WILDCARD_ALL = wildcardType().withUpperBounds(Object.class).build();",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "9",
      "Filed": "",
      "Parameter_type": "Type,Class<?>",
      "Import_statements": "import java.lang.reflect.Array;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.lang.reflect.WildcardType;\nimport org.apache.commons.lang3.ClassUtils;\n",
      "public_method_signature": "public TypeUtils();\npublic static boolean isAssignable(final Type type, final Type toType);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType type);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass);\npublic static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType);\npublic static boolean isInstance(final Object value, final Type type);\npublic static Type[] normalizeUpperBounds(final Type[] bounds);\npublic static Type[] getImplicitBounds(final TypeVariable<?> typeVariable);\npublic static Type[] getImplicitUpperBounds(final WildcardType wildcardType);\npublic static Type[] getImplicitLowerBounds(final WildcardType wildcardType);\npublic static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns);\npublic static Class<?> getRawType(final Type type, final Type assigningType);\npublic static boolean isArrayType(final Type type);\npublic static Type getArrayComponentType(final Type type);\npublic static Type unrollVariables(Map<TypeVariable<?>, Type> typeArguments, final Type type);\npublic static boolean containsTypeVariables(final Type type);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static WildcardTypeBuilder wildcardType();\npublic static GenericArrayType genericArrayType(final Type componentType);\npublic static boolean equals(final Type t1, final Type t2);\npublic static String toString(final Type type);\npublic static String toLongString(final TypeVariable<?> var);\npublic static Typed<T> wrap(final Type type);\npublic static Typed<T> wrap(final Class<T> type);",
      "public_field": "/**\n * A wildcard instance matching {@code ?}.\n * @since 3.2\n */\npublic static final WildcardType WILDCARD_ALL = wildcardType().withUpperBounds(Object.class).build();",
      "Method_statement": "isAssignable(final Type type, final Class<?> toClass)",
      "Method_name": "isAssignable",
      "Class_declaration": "public class TypeUtils {\n",
      "constructors": "public TypeUtils() {\n    super();\n}",
      "all_method_signature": "public TypeUtils();\npublic static boolean isAssignable(final Type type, final Type toType);\nprivate static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final Class<?> toClass);\nprivate static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final TypeVariable<?> toTypeVariable, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType type);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\npublic static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType);\nprivate static void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type getClosestParentType(final Class<?> cls, final Class<?> superClass);\npublic static boolean isInstance(final Object value, final Type type);\npublic static Type[] normalizeUpperBounds(final Type[] bounds);\npublic static Type[] getImplicitBounds(final TypeVariable<?> typeVariable);\npublic static Type[] getImplicitUpperBounds(final WildcardType wildcardType);\npublic static Type[] getImplicitLowerBounds(final WildcardType wildcardType);\npublic static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Class<?> getRawType(final ParameterizedType parameterizedType);\npublic static Class<?> getRawType(final Type type, final Type assigningType);\npublic static boolean isArrayType(final Type type);\npublic static Type getArrayComponentType(final Type type);\npublic static Type unrollVariables(Map<TypeVariable<?>, Type> typeArguments, final Type type);\nprivate static Type[] unrollBounds(final Map<TypeVariable<?>, Type> typeArguments, final Type[] bounds);\npublic static boolean containsTypeVariables(final Type type);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\nprivate static Type[] extractTypeArgumentsFrom(final Map<TypeVariable<?>, Type> mappings, final TypeVariable<?>[] variables);\npublic static WildcardTypeBuilder wildcardType();\npublic static GenericArrayType genericArrayType(final Type componentType);\npublic static boolean equals(final Type t1, final Type t2);\nprivate static boolean equals(final ParameterizedType p, final Type t);\nprivate static boolean equals(final GenericArrayType a, final Type t);\nprivate static boolean equals(final WildcardType w, final Type t);\nprivate static boolean equals(final Type[] t1, final Type[] t2);\npublic static String toString(final Type type);\npublic static String toLongString(final TypeVariable<?> var);\npublic static Typed<T> wrap(final Type type);\npublic static Typed<T> wrap(final Class<T> type);\nprivate static String classToString(final Class<?> c);\nprivate static String typeVariableToString(final TypeVariable<?> v);\nprivate static String parameterizedTypeToString(final ParameterizedType p);\nprivate static void appendRecursiveTypes(final StringBuilder buf, final int[] recursiveTypeIndexes, final Type[] argumentTypes);\nprivate static int[] findRecursiveTypes(final ParameterizedType p);\nprivate static boolean containsVariableTypeSameParametrizedTypeBound(final TypeVariable<?> typeVariable, final ParameterizedType p);\nprivate static String wildcardTypeToString(final WildcardType w);\nprivate static String genericArrayTypeToString(final GenericArrayType g);\nprivate static StringBuilder appendAllTo(final StringBuilder buf, final String sep, final T... types);\nprivate static String toString(final T object);",
      "Class_name": "TypeUtils",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/reflect/TypeUtils###isAssignable",
      "Parameter_num": "2",
      "all_Import_statements": "import java.lang.reflect.Array;\n\nimport java.lang.reflect.GenericArrayType;\n\nimport java.lang.reflect.GenericDeclaration;\n\nimport java.lang.reflect.ParameterizedType;\n\nimport java.lang.reflect.Type;\n\nimport java.lang.reflect.TypeVariable;\n\nimport java.lang.reflect.WildcardType;\n\nimport java.util.Arrays;\n\nimport java.util.Collections;\n\nimport java.util.HashMap;\n\nimport java.util.HashSet;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Objects;\n\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\nimport org.apache.commons.lang3.ClassUtils;\n\nimport org.apache.commons.lang3.ObjectUtils;\n\nimport org.apache.commons.lang3.Validate;\n\nimport org.apache.commons.lang3.builder.Builder;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>Checks if the subject type may be implicitly cast to the target class\n     * following the Java generics rules.</p>\n     *\n     * @param type the subject type to be assigned to the target type\n     * @param toClass the target class\n     * @return {@code true} if {@code type} is assignable to {@code toClass}.\n     ",
      "packageName": "org.apache.commons.lang3.reflect",
      "method_signature": "private static boolean isAssignable(final Type type, final Class<?> toClass);",
      "Junit_version": "4",
      "returnType": "boolean"
    },
    "Test_method": {
      "Method_body": "List list0 = null;\n\rList<Object> list1 = null;\n\rList<?> list2 = null;\n\rList<? super Object> list3 = null;\n\rList<String> list4 = null;\n\rList<? extends String> list5 = null;\n\rList<? super String> list6 = null;\n\rList[] list7 = null;\n\rList<Object>[] list8 = null;\n\rList<?>[] list9 = null;\n\rList<? super Object>[] list10 = null;\n\rList<String>[] list11 = null;\n\rList<? extends String>[] list12 = null;\n\rList<? super String>[] list13;\n\rfinal Class<?> clazz = getClass();\n\rfinal Method method = clazz.getMethod(\"dummyMethod\", List.class, List.class, List.class, List.class, List.class, List.class, List.class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class);\n\rfinal Type[] types = method.getGenericParameterTypes();\n\r// list0 = list0;\ndelegateBooleanAssertion(types, 0, 0, true);\n\rlist1 = list0;\n\rdelegateBooleanAssertion(types, 0, 1, true);\n\rlist0 = list1;\n\rdelegateBooleanAssertion(types, 1, 0, true);\n\rlist2 = list0;\n\rdelegateBooleanAssertion(types, 0, 2, true);\n\rlist0 = list2;\n\rdelegateBooleanAssertion(types, 2, 0, true);\n\rlist3 = list0;\n\rdelegateBooleanAssertion(types, 0, 3, true);\n\rlist0 = list3;\n\rdelegateBooleanAssertion(types, 3, 0, true);\n\rlist4 = list0;\n\rdelegateBooleanAssertion(types, 0, 4, true);\n\rlist0 = list4;\n\rdelegateBooleanAssertion(types, 4, 0, true);\n\rlist5 = list0;\n\rdelegateBooleanAssertion(types, 0, 5, true);\n\rlist0 = list5;\n\rdelegateBooleanAssertion(types, 5, 0, true);\n\rlist6 = list0;\n\rdelegateBooleanAssertion(types, 0, 6, true);\n\rlist0 = list6;\n\rdelegateBooleanAssertion(types, 6, 0, true);\n\r// list1 = list1;\ndelegateBooleanAssertion(types, 1, 1, true);\n\rlist2 = list1;\n\rdelegateBooleanAssertion(types, 1, 2, true);\n\rlist1 = (List<Object>) list2;\n\rdelegateBooleanAssertion(types, 2, 1, false);\n\rlist3 = list1;\n\rdelegateBooleanAssertion(types, 1, 3, true);\n\rlist1 = (List<Object>) list3;\n\rdelegateBooleanAssertion(types, 3, 1, false);\n\r// list4 = list1;\ndelegateBooleanAssertion(types, 1, 4, false);\n\r// list1 = list4;\ndelegateBooleanAssertion(types, 4, 1, false);\n\r// list5 = list1;\ndelegateBooleanAssertion(types, 1, 5, false);\n\r// list1 = list5;\ndelegateBooleanAssertion(types, 5, 1, false);\n\rlist6 = list1;\n\rdelegateBooleanAssertion(types, 1, 6, true);\n\rlist1 = (List<Object>) list6;\n\rdelegateBooleanAssertion(types, 6, 1, false);\n\r// list2 = list2;\ndelegateBooleanAssertion(types, 2, 2, true);\n\rlist2 = list3;\n\rdelegateBooleanAssertion(types, 2, 3, false);\n\rlist2 = list4;\n\rdelegateBooleanAssertion(types, 3, 2, true);\n\rlist3 = (List<? super Object>) list2;\n\rdelegateBooleanAssertion(types, 2, 4, false);\n\rlist2 = list5;\n\rdelegateBooleanAssertion(types, 4, 2, true);\n\rlist4 = (List<String>) list2;\n\rdelegateBooleanAssertion(types, 2, 5, false);\n\rlist2 = list6;\n\rdelegateBooleanAssertion(types, 5, 2, true);\n\rlist5 = (List<? extends String>) list2;\n\rdelegateBooleanAssertion(types, 2, 6, false);\n\r// list3 = list3;\ndelegateBooleanAssertion(types, 6, 2, true);\n\rlist6 = (List<? super String>) list2;\n\rdelegateBooleanAssertion(types, 3, 3, true);\n\r// list4 = list3;\ndelegateBooleanAssertion(types, 3, 4, false);\n\r// list3 = list4;\ndelegateBooleanAssertion(types, 4, 3, false);\n\r// list5 = list3;\ndelegateBooleanAssertion(types, 3, 5, false);\n\r// list3 = list5;\ndelegateBooleanAssertion(types, 5, 3, false);\n\rlist6 = list3;\n\rdelegateBooleanAssertion(types, 3, 6, true);\n\rlist3 = (List<? super Object>) list6;\n\rdelegateBooleanAssertion(types, 6, 3, false);\n\r// list4 = list4;\ndelegateBooleanAssertion(types, 4, 4, true);\n\rlist5 = list4;\n\rdelegateBooleanAssertion(types, 4, 5, true);\n\rlist4 = (List<String>) list5;\n\rdelegateBooleanAssertion(types, 5, 4, false);\n\rlist6 = list4;\n\rdelegateBooleanAssertion(types, 4, 6, true);\n\rlist4 = (List<String>) list6;\n\rdelegateBooleanAssertion(types, 6, 4, false);\n\r// list5 = list5;\ndelegateBooleanAssertion(types, 5, 5, true);\n\rlist6 = (List<? super String>) list5;\n\rdelegateBooleanAssertion(types, 5, 6, false);\n\rlist5 = (List<? extends String>) list6;\n\rdelegateBooleanAssertion(types, 6, 5, false);\n\r// list6 = list6;\ndelegateBooleanAssertion(types, 6, 6, true);\n\r// list7 = list7;\ndelegateBooleanAssertion(types, 7, 7, true);\n\rlist8 = list7;\n\rdelegateBooleanAssertion(types, 7, 8, true);\n\rlist7 = list8;\n\rdelegateBooleanAssertion(types, 8, 7, true);\n\rlist9 = list7;\n\rdelegateBooleanAssertion(types, 7, 9, true);\n\rlist7 = list9;\n\rdelegateBooleanAssertion(types, 9, 7, true);\n\rlist10 = list7;\n\rdelegateBooleanAssertion(types, 7, 10, true);\n\rlist7 = list10;\n\rdelegateBooleanAssertion(types, 10, 7, true);\n\rlist11 = list7;\n\rdelegateBooleanAssertion(types, 7, 11, true);\n\rlist7 = list11;\n\rdelegateBooleanAssertion(types, 11, 7, true);\n\rlist12 = list7;\n\rdelegateBooleanAssertion(types, 7, 12, true);\n\rlist7 = list12;\n\rdelegateBooleanAssertion(types, 12, 7, true);\n\rlist13 = list7;\n\rdelegateBooleanAssertion(types, 7, 13, true);\n\rlist7 = list13;\n\rdelegateBooleanAssertion(types, 13, 7, true);\n\r// list8 = list8;\ndelegateBooleanAssertion(types, 8, 8, true);\n\rlist9 = list8;\n\rdelegateBooleanAssertion(types, 8, 9, true);\n\rlist8 = (List<Object>[]) list9;\n\rdelegateBooleanAssertion(types, 9, 8, false);\n\rlist10 = list8;\n\rdelegateBooleanAssertion(types, 8, 10, true);\n\r// NOTE cast is required by Sun Java, but not by Eclipse\nlist8 = (List<Object>[]) list10;\n\rdelegateBooleanAssertion(types, 10, 8, false);\n\r// list11 = list8;\ndelegateBooleanAssertion(types, 8, 11, false);\n\r// list8 = list11;\ndelegateBooleanAssertion(types, 11, 8, false);\n\r// list12 = list8;\ndelegateBooleanAssertion(types, 8, 12, false);\n\r// list8 = list12;\ndelegateBooleanAssertion(types, 12, 8, false);\n\rlist13 = list8;\n\rdelegateBooleanAssertion(types, 8, 13, true);\n\rlist8 = (List<Object>[]) list13;\n\rdelegateBooleanAssertion(types, 13, 8, false);\n\r// list9 = list9;\ndelegateBooleanAssertion(types, 9, 9, true);\n\rlist10 = (List<? super Object>[]) list9;\n\rdelegateBooleanAssertion(types, 9, 10, false);\n\rlist9 = list10;\n\rdelegateBooleanAssertion(types, 10, 9, true);\n\rlist11 = (List<String>[]) list9;\n\rdelegateBooleanAssertion(types, 9, 11, false);\n\rlist9 = list11;\n\rdelegateBooleanAssertion(types, 11, 9, true);\n\rlist12 = (List<? extends String>[]) list9;\n\rdelegateBooleanAssertion(types, 9, 12, false);\n\rlist9 = list12;\n\rdelegateBooleanAssertion(types, 12, 9, true);\n\rlist13 = (List<? super String>[]) list9;\n\rdelegateBooleanAssertion(types, 9, 13, false);\n\rlist9 = list13;\n\rdelegateBooleanAssertion(types, 13, 9, true);\n\r// list10 = list10;\ndelegateBooleanAssertion(types, 10, 10, true);\n\r// list11 = list10;\ndelegateBooleanAssertion(types, 10, 11, false);\n\r// list10 = list11;\ndelegateBooleanAssertion(types, 11, 10, false);\n\r// list12 = list10;\ndelegateBooleanAssertion(types, 10, 12, false);\n\r// list10 = list12;\ndelegateBooleanAssertion(types, 12, 10, false);\n\rlist13 = list10;\n\rdelegateBooleanAssertion(types, 10, 13, true);\n\rlist10 = (List<? super Object>[]) list13;\n\rdelegateBooleanAssertion(types, 13, 10, false);\n\r// list11 = list11;\ndelegateBooleanAssertion(types, 11, 11, true);\n\rlist12 = list11;\n\rdelegateBooleanAssertion(types, 11, 12, true);\n\rlist11 = (List<String>[]) list12;\n\rdelegateBooleanAssertion(types, 12, 11, false);\n\rlist13 = list11;\n\rdelegateBooleanAssertion(types, 11, 13, true);\n\rlist11 = (List<String>[]) list13;\n\rdelegateBooleanAssertion(types, 13, 11, false);\n\r// list12 = list12;\ndelegateBooleanAssertion(types, 12, 12, true);\n\rlist13 = (List<? super String>[]) list12;\n\rdelegateBooleanAssertion(types, 12, 13, false);\n\rlist12 = (List<? extends String>[]) list13;\n\rdelegateBooleanAssertion(types, 13, 12, false);\n\r// list13 = list13;\ndelegateBooleanAssertion(types, 13, 13, true);\n\rfinal Type disType = getClass().getField(\"dis\").getGenericType();\n\r// Reporter.log( ( ( ParameterizedType ) disType\n// ).getOwnerType().getClass().toString() );\nfinal Type datType = getClass().getField(\"dat\").getGenericType();\n\rfinal Type daType = getClass().getField(\"da\").getGenericType();\n\rfinal Type uhderType = getClass().getField(\"uhder\").getGenericType();\n\rfinal Type dingType = getClass().getField(\"ding\").getGenericType();\n\rfinal Type testerType = getClass().getField(\"tester\").getGenericType();\n\rfinal Type tester2Type = getClass().getField(\"tester2\").getGenericType();\n\rfinal Type dat2Type = getClass().getField(\"dat2\").getGenericType();\n\rfinal Type dat3Type = getClass().getField(\"dat3\").getGenericType();\n\rdis = dat;\n\rassertTrue(TypeUtils.isAssignable(datType, disType));\n\r// dis = da;\nassertFalse(TypeUtils.isAssignable(daType, disType));\n\rdis = uhder;\n\rassertTrue(TypeUtils.isAssignable(uhderType, disType));\n\rdis = ding;\n\rassertFalse(String.format(\"type %s not assignable to %s!\", dingType, disType), TypeUtils.isAssignable(dingType, disType));\n\rdis = tester;\n\rassertTrue(TypeUtils.isAssignable(testerType, disType));\n\r// dis = tester2;\nassertFalse(TypeUtils.isAssignable(tester2Type, disType));\n\r// dat = dat2;\nassertFalse(TypeUtils.isAssignable(dat2Type, datType));\n\r// dat2 = dat;\nassertFalse(TypeUtils.isAssignable(datType, dat2Type));\n\r// dat = dat3;\nassertFalse(TypeUtils.isAssignable(dat3Type, datType));\n\rfinal char ch = 0;\n\rfinal boolean bo = false;\n\rfinal byte by = 0;\n\rfinal short sh = 0;\n\rint in = 0;\n\rlong lo = 0;\n\rfinal float fl = 0;\n\rdouble du = 0;\n\rdu = ch;\n\rassertTrue(TypeUtils.isAssignable(char.class, double.class));\n\rdu = by;\n\rassertTrue(TypeUtils.isAssignable(byte.class, double.class));\n\rdu = sh;\n\rassertTrue(TypeUtils.isAssignable(short.class, double.class));\n\rdu = in;\n\rassertTrue(TypeUtils.isAssignable(int.class, double.class));\n\rdu = lo;\n\rassertTrue(TypeUtils.isAssignable(long.class, double.class));\n\rdu = fl;\n\rassertTrue(TypeUtils.isAssignable(float.class, double.class));\n\rlo = in;\n\rassertTrue(TypeUtils.isAssignable(int.class, long.class));\n\rlo = Integer.valueOf(0);\n\rassertTrue(TypeUtils.isAssignable(Integer.class, long.class));\n\r// Long lngW = 1;\nassertFalse(TypeUtils.isAssignable(int.class, Long.class));\n\r// lngW = Integer.valueOf( 0 );\nassertFalse(TypeUtils.isAssignable(Integer.class, Long.class));\n\rin = Integer.valueOf(0);\n\rassertTrue(TypeUtils.isAssignable(Integer.class, int.class));\n\rfinal Integer inte = in;\n\rassertTrue(TypeUtils.isAssignable(int.class, Integer.class));\n\rassertTrue(TypeUtils.isAssignable(int.class, Number.class));\n\rassertTrue(TypeUtils.isAssignable(int.class, Object.class));\n\rfinal Type intComparableType = getClass().getField(\"intComparable\").getGenericType();\n\rintComparable = 1;\n\rassertTrue(TypeUtils.isAssignable(int.class, intComparableType));\n\rassertTrue(TypeUtils.isAssignable(int.class, Comparable.class));\n\rfinal Serializable ser = 1;\n\rassertTrue(TypeUtils.isAssignable(int.class, Serializable.class));\n\rfinal Type longComparableType = getClass().getField(\"longComparable\").getGenericType();\n\r// longComparable = 1;\nassertFalse(TypeUtils.isAssignable(int.class, longComparableType));\n\r// longComparable = Integer.valueOf( 0 );\nassertFalse(TypeUtils.isAssignable(Integer.class, longComparableType));\n\r// int[] ia;\n// long[] la = ia;\nassertFalse(TypeUtils.isAssignable(int[].class, long[].class));\n\rfinal Integer[] ia = null;\n\rfinal Type caType = getClass().getField(\"intWildcardComparable\").getGenericType();\n\rintWildcardComparable = ia;\n\rassertTrue(TypeUtils.isAssignable(Integer[].class, caType));\n\r// int[] ina = ia;\nassertFalse(TypeUtils.isAssignable(Integer[].class, int[].class));\n\rfinal int[] ina = null;\n\rObject[] oa;\n\r// oa = ina;\nassertFalse(TypeUtils.isAssignable(int[].class, Object[].class));\n\roa = new Integer[0];\n\rassertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class));\n\rfinal Type bClassType = AClass.class.getField(\"bClass\").getGenericType();\n\rfinal Type cClassType = AClass.class.getField(\"cClass\").getGenericType();\n\rfinal Type dClassType = AClass.class.getField(\"dClass\").getGenericType();\n\rfinal Type eClassType = AClass.class.getField(\"eClass\").getGenericType();\n\rfinal Type fClassType = AClass.class.getField(\"fClass\").getGenericType();\n\rfinal AClass aClass = new AClass(new AAClass<String>());\n\raClass.bClass = aClass.cClass;\n\rassertTrue(TypeUtils.isAssignable(cClassType, bClassType));\n\raClass.bClass = aClass.dClass;\n\rassertTrue(TypeUtils.isAssignable(dClassType, bClassType));\n\raClass.bClass = aClass.eClass;\n\rassertTrue(TypeUtils.isAssignable(eClassType, bClassType));\n\raClass.bClass = aClass.fClass;\n\rassertTrue(TypeUtils.isAssignable(fClassType, bClassType));\n\raClass.cClass = aClass.dClass;\n\rassertTrue(TypeUtils.isAssignable(dClassType, cClassType));\n\raClass.cClass = aClass.eClass;\n\rassertTrue(TypeUtils.isAssignable(eClassType, cClassType));\n\raClass.cClass = aClass.fClass;\n\rassertTrue(TypeUtils.isAssignable(fClassType, cClassType));\n\raClass.dClass = aClass.eClass;\n\rassertTrue(TypeUtils.isAssignable(eClassType, dClassType));\n\raClass.dClass = aClass.fClass;\n\rassertTrue(TypeUtils.isAssignable(fClassType, dClassType));\n\raClass.eClass = aClass.fClass;\n\rassertTrue(TypeUtils.isAssignable(fClassType, eClassType));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "283",
      "Filed": "public This<String, String> dis;public That<String, String> dat;public The<String, String> da;public Other<String> uhder;public Thing ding;public TypeUtilsTest<String>.Tester tester;public Tester tester2;public TypeUtilsTest<String>.That<String, String> dat2;public TypeUtilsTest<Number>.That<String, String> dat3;public Comparable<? extends Integer>[] intWildcardComparable;public static Comparable<Integer> intComparable;public static Comparable<Long> longComparable;",
      "Import_statements": "import static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport java.io.Serializable;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.List;\n",
      "allMethod_info": "// deliberately used here\n@SuppressWarnings(\"boxing\")\n@Test\npublic void testIsAssignable() throws SecurityException, NoSuchMethodException, NoSuchFieldException {\n    List list0 = null;\n    List<Object> list1 = null;\n    List<?> list2 = null;\n    List<? super Object> list3 = null;\n    List<String> list4 = null;\n    List<? extends String> list5 = null;\n    List<? super String> list6 = null;\n    List[] list7 = null;\n    List<Object>[] list8 = null;\n    List<?>[] list9 = null;\n    List<? super Object>[] list10 = null;\n    List<String>[] list11 = null;\n    List<? extends String>[] list12 = null;\n    List<? super String>[] list13;\n    final Class<?> clazz = getClass();\n    final Method method = clazz.getMethod(\"dummyMethod\", List.class, List.class, List.class, List.class, List.class, List.class, List.class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class, List[].class);\n    final Type[] types = method.getGenericParameterTypes();\n    // list0 = list0;\n    delegateBooleanAssertion(types, 0, 0, true);\n    list1 = list0;\n    delegateBooleanAssertion(types, 0, 1, true);\n    list0 = list1;\n    delegateBooleanAssertion(types, 1, 0, true);\n    list2 = list0;\n    delegateBooleanAssertion(types, 0, 2, true);\n    list0 = list2;\n    delegateBooleanAssertion(types, 2, 0, true);\n    list3 = list0;\n    delegateBooleanAssertion(types, 0, 3, true);\n    list0 = list3;\n    delegateBooleanAssertion(types, 3, 0, true);\n    list4 = list0;\n    delegateBooleanAssertion(types, 0, 4, true);\n    list0 = list4;\n    delegateBooleanAssertion(types, 4, 0, true);\n    list5 = list0;\n    delegateBooleanAssertion(types, 0, 5, true);\n    list0 = list5;\n    delegateBooleanAssertion(types, 5, 0, true);\n    list6 = list0;\n    delegateBooleanAssertion(types, 0, 6, true);\n    list0 = list6;\n    delegateBooleanAssertion(types, 6, 0, true);\n    // list1 = list1;\n    delegateBooleanAssertion(types, 1, 1, true);\n    list2 = list1;\n    delegateBooleanAssertion(types, 1, 2, true);\n    list1 = (List<Object>) list2;\n    delegateBooleanAssertion(types, 2, 1, false);\n    list3 = list1;\n    delegateBooleanAssertion(types, 1, 3, true);\n    list1 = (List<Object>) list3;\n    delegateBooleanAssertion(types, 3, 1, false);\n    // list4 = list1;\n    delegateBooleanAssertion(types, 1, 4, false);\n    // list1 = list4;\n    delegateBooleanAssertion(types, 4, 1, false);\n    // list5 = list1;\n    delegateBooleanAssertion(types, 1, 5, false);\n    // list1 = list5;\n    delegateBooleanAssertion(types, 5, 1, false);\n    list6 = list1;\n    delegateBooleanAssertion(types, 1, 6, true);\n    list1 = (List<Object>) list6;\n    delegateBooleanAssertion(types, 6, 1, false);\n    // list2 = list2;\n    delegateBooleanAssertion(types, 2, 2, true);\n    list2 = list3;\n    delegateBooleanAssertion(types, 2, 3, false);\n    list2 = list4;\n    delegateBooleanAssertion(types, 3, 2, true);\n    list3 = (List<? super Object>) list2;\n    delegateBooleanAssertion(types, 2, 4, false);\n    list2 = list5;\n    delegateBooleanAssertion(types, 4, 2, true);\n    list4 = (List<String>) list2;\n    delegateBooleanAssertion(types, 2, 5, false);\n    list2 = list6;\n    delegateBooleanAssertion(types, 5, 2, true);\n    list5 = (List<? extends String>) list2;\n    delegateBooleanAssertion(types, 2, 6, false);\n    // list3 = list3;\n    delegateBooleanAssertion(types, 6, 2, true);\n    list6 = (List<? super String>) list2;\n    delegateBooleanAssertion(types, 3, 3, true);\n    // list4 = list3;\n    delegateBooleanAssertion(types, 3, 4, false);\n    // list3 = list4;\n    delegateBooleanAssertion(types, 4, 3, false);\n    // list5 = list3;\n    delegateBooleanAssertion(types, 3, 5, false);\n    // list3 = list5;\n    delegateBooleanAssertion(types, 5, 3, false);\n    list6 = list3;\n    delegateBooleanAssertion(types, 3, 6, true);\n    list3 = (List<? super Object>) list6;\n    delegateBooleanAssertion(types, 6, 3, false);\n    // list4 = list4;\n    delegateBooleanAssertion(types, 4, 4, true);\n    list5 = list4;\n    delegateBooleanAssertion(types, 4, 5, true);\n    list4 = (List<String>) list5;\n    delegateBooleanAssertion(types, 5, 4, false);\n    list6 = list4;\n    delegateBooleanAssertion(types, 4, 6, true);\n    list4 = (List<String>) list6;\n    delegateBooleanAssertion(types, 6, 4, false);\n    // list5 = list5;\n    delegateBooleanAssertion(types, 5, 5, true);\n    list6 = (List<? super String>) list5;\n    delegateBooleanAssertion(types, 5, 6, false);\n    list5 = (List<? extends String>) list6;\n    delegateBooleanAssertion(types, 6, 5, false);\n    // list6 = list6;\n    delegateBooleanAssertion(types, 6, 6, true);\n    // list7 = list7;\n    delegateBooleanAssertion(types, 7, 7, true);\n    list8 = list7;\n    delegateBooleanAssertion(types, 7, 8, true);\n    list7 = list8;\n    delegateBooleanAssertion(types, 8, 7, true);\n    list9 = list7;\n    delegateBooleanAssertion(types, 7, 9, true);\n    list7 = list9;\n    delegateBooleanAssertion(types, 9, 7, true);\n    list10 = list7;\n    delegateBooleanAssertion(types, 7, 10, true);\n    list7 = list10;\n    delegateBooleanAssertion(types, 10, 7, true);\n    list11 = list7;\n    delegateBooleanAssertion(types, 7, 11, true);\n    list7 = list11;\n    delegateBooleanAssertion(types, 11, 7, true);\n    list12 = list7;\n    delegateBooleanAssertion(types, 7, 12, true);\n    list7 = list12;\n    delegateBooleanAssertion(types, 12, 7, true);\n    list13 = list7;\n    delegateBooleanAssertion(types, 7, 13, true);\n    list7 = list13;\n    delegateBooleanAssertion(types, 13, 7, true);\n    // list8 = list8;\n    delegateBooleanAssertion(types, 8, 8, true);\n    list9 = list8;\n    delegateBooleanAssertion(types, 8, 9, true);\n    list8 = (List<Object>[]) list9;\n    delegateBooleanAssertion(types, 9, 8, false);\n    list10 = list8;\n    delegateBooleanAssertion(types, 8, 10, true);\n    // NOTE cast is required by Sun Java, but not by Eclipse\n    list8 = (List<Object>[]) list10;\n    delegateBooleanAssertion(types, 10, 8, false);\n    // list11 = list8;\n    delegateBooleanAssertion(types, 8, 11, false);\n    // list8 = list11;\n    delegateBooleanAssertion(types, 11, 8, false);\n    // list12 = list8;\n    delegateBooleanAssertion(types, 8, 12, false);\n    // list8 = list12;\n    delegateBooleanAssertion(types, 12, 8, false);\n    list13 = list8;\n    delegateBooleanAssertion(types, 8, 13, true);\n    list8 = (List<Object>[]) list13;\n    delegateBooleanAssertion(types, 13, 8, false);\n    // list9 = list9;\n    delegateBooleanAssertion(types, 9, 9, true);\n    list10 = (List<? super Object>[]) list9;\n    delegateBooleanAssertion(types, 9, 10, false);\n    list9 = list10;\n    delegateBooleanAssertion(types, 10, 9, true);\n    list11 = (List<String>[]) list9;\n    delegateBooleanAssertion(types, 9, 11, false);\n    list9 = list11;\n    delegateBooleanAssertion(types, 11, 9, true);\n    list12 = (List<? extends String>[]) list9;\n    delegateBooleanAssertion(types, 9, 12, false);\n    list9 = list12;\n    delegateBooleanAssertion(types, 12, 9, true);\n    list13 = (List<? super String>[]) list9;\n    delegateBooleanAssertion(types, 9, 13, false);\n    list9 = list13;\n    delegateBooleanAssertion(types, 13, 9, true);\n    // list10 = list10;\n    delegateBooleanAssertion(types, 10, 10, true);\n    // list11 = list10;\n    delegateBooleanAssertion(types, 10, 11, false);\n    // list10 = list11;\n    delegateBooleanAssertion(types, 11, 10, false);\n    // list12 = list10;\n    delegateBooleanAssertion(types, 10, 12, false);\n    // list10 = list12;\n    delegateBooleanAssertion(types, 12, 10, false);\n    list13 = list10;\n    delegateBooleanAssertion(types, 10, 13, true);\n    list10 = (List<? super Object>[]) list13;\n    delegateBooleanAssertion(types, 13, 10, false);\n    // list11 = list11;\n    delegateBooleanAssertion(types, 11, 11, true);\n    list12 = list11;\n    delegateBooleanAssertion(types, 11, 12, true);\n    list11 = (List<String>[]) list12;\n    delegateBooleanAssertion(types, 12, 11, false);\n    list13 = list11;\n    delegateBooleanAssertion(types, 11, 13, true);\n    list11 = (List<String>[]) list13;\n    delegateBooleanAssertion(types, 13, 11, false);\n    // list12 = list12;\n    delegateBooleanAssertion(types, 12, 12, true);\n    list13 = (List<? super String>[]) list12;\n    delegateBooleanAssertion(types, 12, 13, false);\n    list12 = (List<? extends String>[]) list13;\n    delegateBooleanAssertion(types, 13, 12, false);\n    // list13 = list13;\n    delegateBooleanAssertion(types, 13, 13, true);\n    final Type disType = getClass().getField(\"dis\").getGenericType();\n    // Reporter.log( ( ( ParameterizedType ) disType\n    // ).getOwnerType().getClass().toString() );\n    final Type datType = getClass().getField(\"dat\").getGenericType();\n    final Type daType = getClass().getField(\"da\").getGenericType();\n    final Type uhderType = getClass().getField(\"uhder\").getGenericType();\n    final Type dingType = getClass().getField(\"ding\").getGenericType();\n    final Type testerType = getClass().getField(\"tester\").getGenericType();\n    final Type tester2Type = getClass().getField(\"tester2\").getGenericType();\n    final Type dat2Type = getClass().getField(\"dat2\").getGenericType();\n    final Type dat3Type = getClass().getField(\"dat3\").getGenericType();\n    dis = dat;\n    assertTrue(TypeUtils.isAssignable(datType, disType));\n    // dis = da;\n    assertFalse(TypeUtils.isAssignable(daType, disType));\n    dis = uhder;\n    assertTrue(TypeUtils.isAssignable(uhderType, disType));\n    dis = ding;\n    assertFalse(String.format(\"type %s not assignable to %s!\", dingType, disType), TypeUtils.isAssignable(dingType, disType));\n    dis = tester;\n    assertTrue(TypeUtils.isAssignable(testerType, disType));\n    // dis = tester2;\n    assertFalse(TypeUtils.isAssignable(tester2Type, disType));\n    // dat = dat2;\n    assertFalse(TypeUtils.isAssignable(dat2Type, datType));\n    // dat2 = dat;\n    assertFalse(TypeUtils.isAssignable(datType, dat2Type));\n    // dat = dat3;\n    assertFalse(TypeUtils.isAssignable(dat3Type, datType));\n    final char ch = 0;\n    final boolean bo = false;\n    final byte by = 0;\n    final short sh = 0;\n    int in = 0;\n    long lo = 0;\n    final float fl = 0;\n    double du = 0;\n    du = ch;\n    assertTrue(TypeUtils.isAssignable(char.class, double.class));\n    du = by;\n    assertTrue(TypeUtils.isAssignable(byte.class, double.class));\n    du = sh;\n    assertTrue(TypeUtils.isAssignable(short.class, double.class));\n    du = in;\n    assertTrue(TypeUtils.isAssignable(int.class, double.class));\n    du = lo;\n    assertTrue(TypeUtils.isAssignable(long.class, double.class));\n    du = fl;\n    assertTrue(TypeUtils.isAssignable(float.class, double.class));\n    lo = in;\n    assertTrue(TypeUtils.isAssignable(int.class, long.class));\n    lo = Integer.valueOf(0);\n    assertTrue(TypeUtils.isAssignable(Integer.class, long.class));\n    // Long lngW = 1;\n    assertFalse(TypeUtils.isAssignable(int.class, Long.class));\n    // lngW = Integer.valueOf( 0 );\n    assertFalse(TypeUtils.isAssignable(Integer.class, Long.class));\n    in = Integer.valueOf(0);\n    assertTrue(TypeUtils.isAssignable(Integer.class, int.class));\n    final Integer inte = in;\n    assertTrue(TypeUtils.isAssignable(int.class, Integer.class));\n    assertTrue(TypeUtils.isAssignable(int.class, Number.class));\n    assertTrue(TypeUtils.isAssignable(int.class, Object.class));\n    final Type intComparableType = getClass().getField(\"intComparable\").getGenericType();\n    intComparable = 1;\n    assertTrue(TypeUtils.isAssignable(int.class, intComparableType));\n    assertTrue(TypeUtils.isAssignable(int.class, Comparable.class));\n    final Serializable ser = 1;\n    assertTrue(TypeUtils.isAssignable(int.class, Serializable.class));\n    final Type longComparableType = getClass().getField(\"longComparable\").getGenericType();\n    // longComparable = 1;\n    assertFalse(TypeUtils.isAssignable(int.class, longComparableType));\n    // longComparable = Integer.valueOf( 0 );\n    assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType));\n    // int[] ia;\n    // long[] la = ia;\n    assertFalse(TypeUtils.isAssignable(int[].class, long[].class));\n    final Integer[] ia = null;\n    final Type caType = getClass().getField(\"intWildcardComparable\").getGenericType();\n    intWildcardComparable = ia;\n    assertTrue(TypeUtils.isAssignable(Integer[].class, caType));\n    // int[] ina = ia;\n    assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class));\n    final int[] ina = null;\n    Object[] oa;\n    // oa = ina;\n    assertFalse(TypeUtils.isAssignable(int[].class, Object[].class));\n    oa = new Integer[0];\n    assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class));\n    final Type bClassType = AClass.class.getField(\"bClass\").getGenericType();\n    final Type cClassType = AClass.class.getField(\"cClass\").getGenericType();\n    final Type dClassType = AClass.class.getField(\"dClass\").getGenericType();\n    final Type eClassType = AClass.class.getField(\"eClass\").getGenericType();\n    final Type fClassType = AClass.class.getField(\"fClass\").getGenericType();\n    final AClass aClass = new AClass(new AAClass<String>());\n    aClass.bClass = aClass.cClass;\n    assertTrue(TypeUtils.isAssignable(cClassType, bClassType));\n    aClass.bClass = aClass.dClass;\n    assertTrue(TypeUtils.isAssignable(dClassType, bClassType));\n    aClass.bClass = aClass.eClass;\n    assertTrue(TypeUtils.isAssignable(eClassType, bClassType));\n    aClass.bClass = aClass.fClass;\n    assertTrue(TypeUtils.isAssignable(fClassType, bClassType));\n    aClass.cClass = aClass.dClass;\n    assertTrue(TypeUtils.isAssignable(dClassType, cClassType));\n    aClass.cClass = aClass.eClass;\n    assertTrue(TypeUtils.isAssignable(eClassType, cClassType));\n    aClass.cClass = aClass.fClass;\n    assertTrue(TypeUtils.isAssignable(fClassType, cClassType));\n    aClass.dClass = aClass.eClass;\n    assertTrue(TypeUtils.isAssignable(eClassType, dClassType));\n    aClass.dClass = aClass.fClass;\n    assertTrue(TypeUtils.isAssignable(fClassType, dClassType));\n    aClass.eClass = aClass.fClass;\n    assertTrue(TypeUtils.isAssignable(fClassType, eClassType));\n}",
      "Method_name": "testIsAssignable",
      "Class_declaration": "public class TypeUtilsTest {\n",
      "constructors": "",
      "Class_name": "TypeUtilsTest",
      "methodName_paraNum": "[getClass(0), getMethod(15), getGenericParameterTypes(0), getGenericType(0), getField(1), getClass(0), getGenericType(0), getField(1), getClass(0), getGenericType(0), getField(1), getClass(0), getGenericType(0), getField(1), getClass(0), getGenericType(0), getField(1), getClass(0), getGenericType(0), getField(1), getClass(0), getGenericType(0), getField(1), getClass(0), getGenericType(0), getField(1), getClass(0), getGenericType(0), getField(1), getClass(0), isAssignable(2), isAssignable(2), isAssignable(2), format(3), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), valueOf(1), isAssignable(2), isAssignable(2), isAssignable(2), valueOf(1), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), getGenericType(0), getField(1), getClass(0), isAssignable(2), isAssignable(2), isAssignable(2), getGenericType(0), getField(1), getClass(0), isAssignable(2), isAssignable(2), isAssignable(2), getGenericType(0), getField(1), getClass(0), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), getGenericType(0), getField(1), getGenericType(0), getField(1), getGenericType(0), getField(1), getGenericType(0), getField(1), getGenericType(0), getField(1), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2), isAssignable(2)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest###testIsAssignable",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java",
      "Signature": "public void testIsAssignable() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNull;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.Serializable;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.GenericArrayType;\n\nimport java.lang.reflect.Method;\n\nimport java.lang.reflect.ParameterizedType;\n\nimport java.lang.reflect.Type;\n\nimport java.lang.reflect.TypeVariable;\n\nimport java.lang.reflect.WildcardType;\n\nimport java.net.URI;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collection;\n\nimport java.util.HashMap;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.TreeSet;\n\nimport org.apache.commons.lang3.reflect.testbed.Foo;\n\nimport org.apache.commons.lang3.reflect.testbed.GenericParent;\n\nimport org.apache.commons.lang3.reflect.testbed.GenericTypeHolder;\n\nimport org.apache.commons.lang3.reflect.testbed.StringParameterizedChild;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3.reflect",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings) {\n    Validate.notNull(raw, \"raw class is null\");\n    Validate.notNull(typeArgMappings, \"typeArgMappings is null\");\n    return parameterizeWithOwner(null, raw, extractTypeArgumentsFrom(typeArgMappings, raw.getTypeParameters()));\n}",
      "all_field_declaration": "/**\n * A wildcard instance matching {@code ?}.\n * @since 3.2\n */\npublic static final WildcardType WILDCARD_ALL = wildcardType().withUpperBounds(Object.class).build();",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "3",
      "Filed": "",
      "Parameter_type": "Class<?>,Map<TypeVariable<?>, Type>",
      "Import_statements": "import java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport java.util.Map;\nimport org.apache.commons.lang3.Validate;\n",
      "public_method_signature": "public TypeUtils();\npublic static boolean isAssignable(final Type type, final Type toType);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType type);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass);\npublic static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType);\npublic static boolean isInstance(final Object value, final Type type);\npublic static Type[] normalizeUpperBounds(final Type[] bounds);\npublic static Type[] getImplicitBounds(final TypeVariable<?> typeVariable);\npublic static Type[] getImplicitUpperBounds(final WildcardType wildcardType);\npublic static Type[] getImplicitLowerBounds(final WildcardType wildcardType);\npublic static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns);\npublic static Class<?> getRawType(final Type type, final Type assigningType);\npublic static boolean isArrayType(final Type type);\npublic static Type getArrayComponentType(final Type type);\npublic static Type unrollVariables(Map<TypeVariable<?>, Type> typeArguments, final Type type);\npublic static boolean containsTypeVariables(final Type type);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static WildcardTypeBuilder wildcardType();\npublic static GenericArrayType genericArrayType(final Type componentType);\npublic static boolean equals(final Type t1, final Type t2);\npublic static String toString(final Type type);\npublic static String toLongString(final TypeVariable<?> var);\npublic static Typed<T> wrap(final Type type);\npublic static Typed<T> wrap(final Class<T> type);",
      "public_field": "/**\n * A wildcard instance matching {@code ?}.\n * @since 3.2\n */\npublic static final WildcardType WILDCARD_ALL = wildcardType().withUpperBounds(Object.class).build();",
      "Method_statement": "parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings)",
      "Method_name": "parameterize",
      "Class_declaration": "public class TypeUtils {\n",
      "constructors": "public TypeUtils() {\n    super();\n}",
      "all_method_signature": "public TypeUtils();\npublic static boolean isAssignable(final Type type, final Type toType);\nprivate static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final Class<?> toClass);\nprivate static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final TypeVariable<?> toTypeVariable, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType type);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\npublic static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType);\nprivate static void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type getClosestParentType(final Class<?> cls, final Class<?> superClass);\npublic static boolean isInstance(final Object value, final Type type);\npublic static Type[] normalizeUpperBounds(final Type[] bounds);\npublic static Type[] getImplicitBounds(final TypeVariable<?> typeVariable);\npublic static Type[] getImplicitUpperBounds(final WildcardType wildcardType);\npublic static Type[] getImplicitLowerBounds(final WildcardType wildcardType);\npublic static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Class<?> getRawType(final ParameterizedType parameterizedType);\npublic static Class<?> getRawType(final Type type, final Type assigningType);\npublic static boolean isArrayType(final Type type);\npublic static Type getArrayComponentType(final Type type);\npublic static Type unrollVariables(Map<TypeVariable<?>, Type> typeArguments, final Type type);\nprivate static Type[] unrollBounds(final Map<TypeVariable<?>, Type> typeArguments, final Type[] bounds);\npublic static boolean containsTypeVariables(final Type type);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\nprivate static Type[] extractTypeArgumentsFrom(final Map<TypeVariable<?>, Type> mappings, final TypeVariable<?>[] variables);\npublic static WildcardTypeBuilder wildcardType();\npublic static GenericArrayType genericArrayType(final Type componentType);\npublic static boolean equals(final Type t1, final Type t2);\nprivate static boolean equals(final ParameterizedType p, final Type t);\nprivate static boolean equals(final GenericArrayType a, final Type t);\nprivate static boolean equals(final WildcardType w, final Type t);\nprivate static boolean equals(final Type[] t1, final Type[] t2);\npublic static String toString(final Type type);\npublic static String toLongString(final TypeVariable<?> var);\npublic static Typed<T> wrap(final Type type);\npublic static Typed<T> wrap(final Class<T> type);\nprivate static String classToString(final Class<?> c);\nprivate static String typeVariableToString(final TypeVariable<?> v);\nprivate static String parameterizedTypeToString(final ParameterizedType p);\nprivate static void appendRecursiveTypes(final StringBuilder buf, final int[] recursiveTypeIndexes, final Type[] argumentTypes);\nprivate static int[] findRecursiveTypes(final ParameterizedType p);\nprivate static boolean containsVariableTypeSameParametrizedTypeBound(final TypeVariable<?> typeVariable, final ParameterizedType p);\nprivate static String wildcardTypeToString(final WildcardType w);\nprivate static String genericArrayTypeToString(final GenericArrayType g);\nprivate static StringBuilder appendAllTo(final StringBuilder buf, final String sep, final T... types);\nprivate static String toString(final T object);",
      "Class_name": "TypeUtils",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/reflect/TypeUtils###parameterize",
      "Parameter_num": "2",
      "all_Import_statements": "import java.lang.reflect.Array;\n\nimport java.lang.reflect.GenericArrayType;\n\nimport java.lang.reflect.GenericDeclaration;\n\nimport java.lang.reflect.ParameterizedType;\n\nimport java.lang.reflect.Type;\n\nimport java.lang.reflect.TypeVariable;\n\nimport java.lang.reflect.WildcardType;\n\nimport java.util.Arrays;\n\nimport java.util.Collections;\n\nimport java.util.HashMap;\n\nimport java.util.HashSet;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Objects;\n\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\nimport org.apache.commons.lang3.ClassUtils;\n\nimport org.apache.commons.lang3.ObjectUtils;\n\nimport org.apache.commons.lang3.Validate;\n\nimport org.apache.commons.lang3.builder.Builder;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * Create a parameterized type instance.\n     *\n     * @param raw the raw class to create a parameterized type instance for\n     * @param typeArgMappings the mapping used for parameterization\n     * @return {@link ParameterizedType}\n     * @since 3.2\n     ",
      "packageName": "org.apache.commons.lang3.reflect",
      "method_signature": "public static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);",
      "Junit_version": "4",
      "returnType": "ParameterizedType"
    },
    "Test_method": {
      "Method_body": "final ParameterizedType stringComparableType = TypeUtils.parameterize(Comparable.class, String.class);\n\rassertTrue(TypeUtils.equals(getClass().getField(\"stringComparable\").getGenericType(), stringComparableType));\n\rassertEquals(\"java.lang.Comparable<java.lang.String>\", stringComparableType.toString());",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "3",
      "Filed": "public static Comparable<String> stringComparable;",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\n",
      "allMethod_info": "@Test\npublic void testParameterize() throws Exception {\n    final ParameterizedType stringComparableType = TypeUtils.parameterize(Comparable.class, String.class);\n    assertTrue(TypeUtils.equals(getClass().getField(\"stringComparable\").getGenericType(), stringComparableType));\n    assertEquals(\"java.lang.Comparable<java.lang.String>\", stringComparableType.toString());\n}",
      "Method_name": "testParameterize",
      "Class_declaration": "public class TypeUtilsTest {\n",
      "constructors": "",
      "Class_name": "TypeUtilsTest",
      "methodName_paraNum": "[parameterize(2), equals(2), getGenericType(0), getField(1), getClass(0), toString(0)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest###testParameterize",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java",
      "Signature": "public void testParameterize() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNull;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.Serializable;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.GenericArrayType;\n\nimport java.lang.reflect.Method;\n\nimport java.lang.reflect.ParameterizedType;\n\nimport java.lang.reflect.Type;\n\nimport java.lang.reflect.TypeVariable;\n\nimport java.lang.reflect.WildcardType;\n\nimport java.net.URI;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collection;\n\nimport java.util.HashMap;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.TreeSet;\n\nimport org.apache.commons.lang3.reflect.testbed.Foo;\n\nimport org.apache.commons.lang3.reflect.testbed.GenericParent;\n\nimport org.apache.commons.lang3.reflect.testbed.GenericTypeHolder;\n\nimport org.apache.commons.lang3.reflect.testbed.StringParameterizedChild;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3.reflect",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static String toLongString(final TypeVariable<?> var) {\n    Validate.notNull(var, \"var is null\");\n    final StringBuilder buf = new StringBuilder();\n    final GenericDeclaration d = var.getGenericDeclaration();\n    if (d instanceof Class<?>) {\n        Class<?> c = (Class<?>) d;\n        while (true) {\n            if (c.getEnclosingClass() == null) {\n                buf.insert(0, c.getName());\n                break;\n            }\n            buf.insert(0, c.getSimpleName()).insert(0, '.');\n            c = c.getEnclosingClass();\n        }\n    } else if (d instanceof Type) {\n        buf.append(toString((Type) d));\n    } else {\n        buf.append(d);\n    }\n    return buf.append(':').append(typeVariableToString(var)).toString();\n}",
      "all_field_declaration": "/**\n * A wildcard instance matching {@code ?}.\n * @since 3.2\n */\npublic static final WildcardType WILDCARD_ALL = wildcardType().withUpperBounds(Object.class).build();",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "TypeVariable<?>",
      "Import_statements": "import java.lang.reflect.GenericDeclaration;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.Builder;\n",
      "public_method_signature": "public TypeUtils();\npublic static boolean isAssignable(final Type type, final Type toType);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType type);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass);\npublic static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType);\npublic static boolean isInstance(final Object value, final Type type);\npublic static Type[] normalizeUpperBounds(final Type[] bounds);\npublic static Type[] getImplicitBounds(final TypeVariable<?> typeVariable);\npublic static Type[] getImplicitUpperBounds(final WildcardType wildcardType);\npublic static Type[] getImplicitLowerBounds(final WildcardType wildcardType);\npublic static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns);\npublic static Class<?> getRawType(final Type type, final Type assigningType);\npublic static boolean isArrayType(final Type type);\npublic static Type getArrayComponentType(final Type type);\npublic static Type unrollVariables(Map<TypeVariable<?>, Type> typeArguments, final Type type);\npublic static boolean containsTypeVariables(final Type type);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static WildcardTypeBuilder wildcardType();\npublic static GenericArrayType genericArrayType(final Type componentType);\npublic static boolean equals(final Type t1, final Type t2);\npublic static String toString(final Type type);\npublic static String toLongString(final TypeVariable<?> var);\npublic static Typed<T> wrap(final Type type);\npublic static Typed<T> wrap(final Class<T> type);",
      "public_field": "/**\n * A wildcard instance matching {@code ?}.\n * @since 3.2\n */\npublic static final WildcardType WILDCARD_ALL = wildcardType().withUpperBounds(Object.class).build();",
      "Method_statement": "toLongString(final TypeVariable<?> var)",
      "Method_name": "toLongString",
      "Class_declaration": "public class TypeUtils {\n",
      "constructors": "public TypeUtils() {\n    super();\n}",
      "all_method_signature": "public TypeUtils();\npublic static boolean isAssignable(final Type type, final Type toType);\nprivate static boolean isAssignable(final Type type, final Type toType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final Class<?> toClass);\nprivate static boolean isAssignable(final Type type, final ParameterizedType toParameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type unrollVariableAssignments(TypeVariable<?> var, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final GenericArrayType toGenericArrayType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final WildcardType toWildcardType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static boolean isAssignable(final Type type, final TypeVariable<?> toTypeVariable, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type substituteTypeVariables(final Type type, final Map<TypeVariable<?>, Type> typeVarAssigns);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType type);\npublic static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(final Type type, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(final ParameterizedType parameterizedType, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\nprivate static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, final Class<?> toClass, final Map<TypeVariable<?>, Type> subtypeVarAssigns);\npublic static Map<TypeVariable<?>, Type> determineTypeArguments(final Class<?> cls, final ParameterizedType superType);\nprivate static void mapTypeVariablesToArguments(final Class<T> cls, final ParameterizedType parameterizedType, final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Type getClosestParentType(final Class<?> cls, final Class<?> superClass);\npublic static boolean isInstance(final Object value, final Type type);\npublic static Type[] normalizeUpperBounds(final Type[] bounds);\npublic static Type[] getImplicitBounds(final TypeVariable<?> typeVariable);\npublic static Type[] getImplicitUpperBounds(final WildcardType wildcardType);\npublic static Type[] getImplicitLowerBounds(final WildcardType wildcardType);\npublic static boolean typesSatisfyVariables(final Map<TypeVariable<?>, Type> typeVarAssigns);\nprivate static Class<?> getRawType(final ParameterizedType parameterizedType);\npublic static Class<?> getRawType(final Type type, final Type assigningType);\npublic static boolean isArrayType(final Type type);\npublic static Type getArrayComponentType(final Type type);\npublic static Type unrollVariables(Map<TypeVariable<?>, Type> typeArguments, final Type type);\nprivate static Type[] unrollBounds(final Map<TypeVariable<?>, Type> typeArguments, final Type[] bounds);\npublic static boolean containsTypeVariables(final Type type);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterize(final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Type... typeArguments);\npublic static final ParameterizedType parameterizeWithOwner(final Type owner, final Class<?> raw, final Map<TypeVariable<?>, Type> typeArgMappings);\nprivate static Type[] extractTypeArgumentsFrom(final Map<TypeVariable<?>, Type> mappings, final TypeVariable<?>[] variables);\npublic static WildcardTypeBuilder wildcardType();\npublic static GenericArrayType genericArrayType(final Type componentType);\npublic static boolean equals(final Type t1, final Type t2);\nprivate static boolean equals(final ParameterizedType p, final Type t);\nprivate static boolean equals(final GenericArrayType a, final Type t);\nprivate static boolean equals(final WildcardType w, final Type t);\nprivate static boolean equals(final Type[] t1, final Type[] t2);\npublic static String toString(final Type type);\npublic static String toLongString(final TypeVariable<?> var);\npublic static Typed<T> wrap(final Type type);\npublic static Typed<T> wrap(final Class<T> type);\nprivate static String classToString(final Class<?> c);\nprivate static String typeVariableToString(final TypeVariable<?> v);\nprivate static String parameterizedTypeToString(final ParameterizedType p);\nprivate static void appendRecursiveTypes(final StringBuilder buf, final int[] recursiveTypeIndexes, final Type[] argumentTypes);\nprivate static int[] findRecursiveTypes(final ParameterizedType p);\nprivate static boolean containsVariableTypeSameParametrizedTypeBound(final TypeVariable<?> typeVariable, final ParameterizedType p);\nprivate static String wildcardTypeToString(final WildcardType w);\nprivate static String genericArrayTypeToString(final GenericArrayType g);\nprivate static StringBuilder appendAllTo(final StringBuilder buf, final String sep, final T... types);\nprivate static String toString(final T object);",
      "Class_name": "TypeUtils",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/reflect/TypeUtils###toLongString",
      "Parameter_num": "1",
      "all_Import_statements": "import java.lang.reflect.Array;\n\nimport java.lang.reflect.GenericArrayType;\n\nimport java.lang.reflect.GenericDeclaration;\n\nimport java.lang.reflect.ParameterizedType;\n\nimport java.lang.reflect.Type;\n\nimport java.lang.reflect.TypeVariable;\n\nimport java.lang.reflect.WildcardType;\n\nimport java.util.Arrays;\n\nimport java.util.Collections;\n\nimport java.util.HashMap;\n\nimport java.util.HashSet;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Objects;\n\nimport java.util.Set;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\nimport org.apache.commons.lang3.ClassUtils;\n\nimport org.apache.commons.lang3.ObjectUtils;\n\nimport org.apache.commons.lang3.Validate;\n\nimport org.apache.commons.lang3.builder.Builder;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * Format a {@link TypeVariable} including its {@link GenericDeclaration}.\n     *\n     * @param var the type variable to create a String representation for, not {@code null}\n     * @return String\n     * @since 3.2\n     ",
      "packageName": "org.apache.commons.lang3.reflect",
      "method_signature": "public static String toLongString(final TypeVariable<?> var);",
      "Junit_version": "4",
      "returnType": "String"
    },
    "Test_method": {
      "Method_body": "assertEquals(getClass().getName() + \":B\", TypeUtils.toLongString(getClass().getTypeParameters()[0]));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "1",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport java.lang.reflect.Type;\n",
      "allMethod_info": "@Test\npublic void testToLongString() {\n    assertEquals(getClass().getName() + \":B\", TypeUtils.toLongString(getClass().getTypeParameters()[0]));\n}",
      "Method_name": "testToLongString",
      "Class_declaration": "public class TypeUtilsTest {\n",
      "constructors": "",
      "Class_name": "TypeUtilsTest",
      "methodName_paraNum": "[getName(0), getClass(0), toLongString(1), getTypeParameters(0), getClass(0)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest###testToLongString",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/reflect/TypeUtilsTest.java",
      "Signature": "public void testToLongString() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNull;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.Serializable;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.GenericArrayType;\n\nimport java.lang.reflect.Method;\n\nimport java.lang.reflect.ParameterizedType;\n\nimport java.lang.reflect.Type;\n\nimport java.lang.reflect.TypeVariable;\n\nimport java.lang.reflect.WildcardType;\n\nimport java.net.URI;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collection;\n\nimport java.util.HashMap;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.TreeSet;\n\nimport org.apache.commons.lang3.reflect.testbed.Foo;\n\nimport org.apache.commons.lang3.reflect.testbed.GenericParent;\n\nimport org.apache.commons.lang3.reflect.testbed.GenericTypeHolder;\n\nimport org.apache.commons.lang3.reflect.testbed.StringParameterizedChild;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3.reflect",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic Xml child(String name) {\n    List<Xml> children = children(name);\n    if (children.size() != 1) {\n        logger.debug(\"Could not find individual child node: \" + name);\n        return new XmlAbsent(name);\n    }\n    return children.get(0);\n}",
      "all_field_declaration": "private final Logger logger = LoggerFactory.getLogger(getClass());\nprivate final String name;\nprivate final String content;\nprivate final Map<String, String> nameAttributes = new HashMap<>();\nprivate final Map<String, List<Xml>> nameChildren = new HashMap<>();",
      "sub_project_name": "pvanassen_ns-api",
      "lineNumbers": "3",
      "Filed": "private final Logger logger = LoggerFactory.getLogger(getClass());private final String name;",
      "Parameter_type": "String",
      "Import_statements": "import java.util.List;\n",
      "public_method_signature": "public String name();\npublic String content();\npublic Xml child(String name);\npublic List<Xml> children(String name);\npublic String attr(String name);\npublic boolean isPresent(String name);",
      "public_field": "",
      "Method_statement": "child(String name)",
      "Method_name": "child",
      "Class_declaration": "public class XmlPresent {\n",
      "constructors": "XmlPresent(InputStream stream, String rootName) {\n    this(XmlPresent.rootElement(stream, rootName));\n}private XmlPresent(Element element) {\n    name = element.getNodeName();\n    content = element.getTextContent();\n    NamedNodeMap namedNodeMap = element.getAttributes();\n    int n = namedNodeMap.getLength();\n    for (int i = 0; i < n; i++) {\n        Node node = namedNodeMap.item(i);\n        String name = node.getNodeName();\n        addAttribute(name, node.getNodeValue());\n    }\n    NodeList nodes = element.getChildNodes();\n    n = nodes.getLength();\n    for (int i = 0; i < n; i++) {\n        Node node = nodes.item(i);\n        int type = node.getNodeType();\n        if (type == Node.ELEMENT_NODE) {\n            addChild(node.getNodeName(), new XmlPresent((Element) node));\n        }\n    }\n}",
      "all_method_signature": "private static Element rootElement(InputStream stream, String rootName);\n XmlPresent(InputStream stream, String rootName);\nprivate XmlPresent(Element element);\nprivate void addAttribute(String name, String value);\nprivate void addChild(String name, XmlPresent child);\npublic String name();\npublic String content();\npublic Xml child(String name);\npublic List<Xml> children(String name);\npublic String attr(String name);\npublic boolean isPresent(String name);",
      "Class_name": "XmlPresent",
      "project_path": "pvanassen_ns-api###pvanassen_ns-api/src/main/java/nl/pvanassen/ns/xml/XmlPresent###child",
      "Parameter_num": "1",
      "all_Import_statements": "import nl.pvanassen.ns.error.NsApiException;\n\nimport org.slf4j.Logger;\n\nimport org.slf4j.LoggerFactory;\n\nimport org.w3c.dom.Document;\n\nimport org.w3c.dom.Element;\n\nimport org.w3c.dom.NamedNodeMap;\n\nimport org.w3c.dom.Node;\n\nimport org.w3c.dom.NodeList;\n\nimport javax.xml.parsers.DocumentBuilder;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\n\nimport java.io.InputStream;\n\nimport java.util.ArrayList;\n\nimport java.util.HashMap;\n\nimport java.util.List;\n\nimport java.util.Map;\n",
      "comment": "\r\n     * {@inheritDoc}\r\n     * \r\n     * @see nl.pvanassen.ns.xml.Xml#child(java.lang.String)\r\n     ",
      "packageName": "nl.pvanassen.ns.xml",
      "method_signature": "public Xml child(String name);",
      "Junit_version": "4",
      "returnType": "Xml"
    },
    "Test_method": {
      "Method_body": "assertNotNull(present.child(\"subelement\"));\n\rassertTrue(present.child(\"subelement\") instanceof XmlPresent);\n\rassertNotNull(present.child(\"doesNotExist\"));\n\rassertTrue(present.child(\"doesNotExist\") instanceof XmlAbsent);",
      "sub_project_name": "pvanassen_ns-api",
      "lineNumbers": "4",
      "Filed": "private XmlPresent present;",
      "Import_statements": "import static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n",
      "allMethod_info": "@Test\npublic void testChild() {\n    assertNotNull(present.child(\"subelement\"));\n    assertTrue(present.child(\"subelement\") instanceof XmlPresent);\n    assertNotNull(present.child(\"doesNotExist\"));\n    assertTrue(present.child(\"doesNotExist\") instanceof XmlAbsent);\n}",
      "Method_name": "testChild",
      "Class_declaration": "public class XmlPresentTest {\n",
      "constructors": "",
      "Class_name": "XmlPresentTest",
      "methodName_paraNum": "[child(1), child(1), child(1), child(1)]",
      "project_path": "pvanassen_ns-api###pvanassen_ns-api/src/test/java/nl/pvanassen/ns/xml/XmlPresentTest###testChild",
      "relativePath": "pvanassen_ns-api/src/test/java/nl/pvanassen/ns/xml/XmlPresentTest.java",
      "Signature": "public void testChild() {\n",
      "all_Import_statements": "import org.junit.Before;\n\nimport org.junit.Test;\n\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertNull;\n\nimport static org.junit.Assert.assertTrue;\n",
      "comment": "",
      "packageName": "nl.pvanassen.ns.xml",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static Map<Object, Object> toMap(final Object[] array) {\n    if (array == null) {\n        return null;\n    }\n    final Map<Object, Object> map = new HashMap<>((int) (array.length * 1.5));\n    for (int i = 0; i < array.length; i++) {\n        final Object object = array[i];\n        if (object instanceof Map.Entry<?, ?>) {\n            final Map.Entry<?, ?> entry = (Map.Entry<?, ?>) object;\n            map.put(entry.getKey(), entry.getValue());\n        } else if (object instanceof Object[]) {\n            final Object[] entry = (Object[]) object;\n            if (entry.length < 2) {\n                throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', has a length less than 2\");\n            }\n            map.put(entry[0], entry[1]);\n        } else {\n            throw new IllegalArgumentException(\"Array element \" + i + \", '\" + object + \"', is neither of type Map.Entry nor an Array\");\n        }\n    }\n    return map;\n}",
      "all_field_declaration": "/**\n * An empty immutable {@code Object} array.\n */\npublic static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n * An empty immutable {@code Class} array.\n */\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n * An empty immutable {@code String} array.\n */\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n * An empty immutable {@code long} array.\n */\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n * An empty immutable {@code Long} array.\n */\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n * An empty immutable {@code int} array.\n */\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n * An empty immutable {@code Integer} array.\n */\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n * An empty immutable {@code short} array.\n */\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n * An empty immutable {@code Short} array.\n */\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n * An empty immutable {@code byte} array.\n */\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n * An empty immutable {@code Byte} array.\n */\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n * An empty immutable {@code double} array.\n */\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n * An empty immutable {@code Double} array.\n */\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n * An empty immutable {@code float} array.\n */\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n * An empty immutable {@code Float} array.\n */\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n * An empty immutable {@code boolean} array.\n */\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n * An empty immutable {@code Boolean} array.\n */\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n * An empty immutable {@code char} array.\n */\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n * An empty immutable {@code Character} array.\n */\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n/**\n * The index value when an element is not found in a list or array: {@code -1}.\n * This value is returned by methods in this class and can also be used in comparisons with values returned by\n * various method from {@link java.util.List}.\n */\npublic static final int INDEX_NOT_FOUND = -1;",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "Object[]",
      "Import_statements": "import java.lang.reflect.Array;\nimport java.util.HashMap;\nimport java.util.Map;\n",
      "public_method_signature": "public ArrayUtils();\npublic static String toString(final Object array);\npublic static String toString(final Object array, final String stringIfNull);\npublic static int hashCode(final Object array);\npublic static boolean isEquals(final Object array1, final Object array2);\npublic static Map<Object, Object> toMap(final Object[] array);\npublic static T[] toArray(final T... items);\npublic static T[] clone(final T[] array);\npublic static long[] clone(final long[] array);\npublic static int[] clone(final int[] array);\npublic static short[] clone(final short[] array);\npublic static char[] clone(final char[] array);\npublic static byte[] clone(final byte[] array);\npublic static double[] clone(final double[] array);\npublic static float[] clone(final float[] array);\npublic static boolean[] clone(final boolean[] array);\npublic static T[] nullToEmpty(final T[] array, final Class<T[]> type);\npublic static Object[] nullToEmpty(final Object[] array);\npublic static Class<?>[] nullToEmpty(final Class<?>[] array);\npublic static String[] nullToEmpty(final String[] array);\npublic static long[] nullToEmpty(final long[] array);\npublic static int[] nullToEmpty(final int[] array);\npublic static short[] nullToEmpty(final short[] array);\npublic static char[] nullToEmpty(final char[] array);\npublic static byte[] nullToEmpty(final byte[] array);\npublic static double[] nullToEmpty(final double[] array);\npublic static float[] nullToEmpty(final float[] array);\npublic static boolean[] nullToEmpty(final boolean[] array);\npublic static Long[] nullToEmpty(final Long[] array);\npublic static Integer[] nullToEmpty(final Integer[] array);\npublic static Short[] nullToEmpty(final Short[] array);\npublic static Character[] nullToEmpty(final Character[] array);\npublic static Byte[] nullToEmpty(final Byte[] array);\npublic static Double[] nullToEmpty(final Double[] array);\npublic static Float[] nullToEmpty(final Float[] array);\npublic static Boolean[] nullToEmpty(final Boolean[] array);\npublic static T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive);\npublic static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive);\npublic static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive);\npublic static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive);\npublic static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive);\npublic static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive);\npublic static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive);\npublic static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive);\npublic static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive);\npublic static boolean isSameLength(final Object[] array1, final Object[] array2);\npublic static boolean isSameLength(final long[] array1, final long[] array2);\npublic static boolean isSameLength(final int[] array1, final int[] array2);\npublic static boolean isSameLength(final short[] array1, final short[] array2);\npublic static boolean isSameLength(final char[] array1, final char[] array2);\npublic static boolean isSameLength(final byte[] array1, final byte[] array2);\npublic static boolean isSameLength(final double[] array1, final double[] array2);\npublic static boolean isSameLength(final float[] array1, final float[] array2);\npublic static boolean isSameLength(final boolean[] array1, final boolean[] array2);\npublic static int getLength(final Object array);\npublic static boolean isSameType(final Object array1, final Object array2);\npublic static void reverse(final Object[] array);\npublic static void reverse(final long[] array);\npublic static void reverse(final int[] array);\npublic static void reverse(final short[] array);\npublic static void reverse(final char[] array);\npublic static void reverse(final byte[] array);\npublic static void reverse(final double[] array);\npublic static void reverse(final float[] array);\npublic static void reverse(final boolean[] array);\npublic static void reverse(final boolean[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final byte[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final char[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final double[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final float[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final int[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final long[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final Object[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final short[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void swap(final Object[] array, final int offset1, final int offset2);\npublic static void swap(final long[] array, final int offset1, final int offset2);\npublic static void swap(final int[] array, final int offset1, final int offset2);\npublic static void swap(final short[] array, final int offset1, final int offset2);\npublic static void swap(final char[] array, final int offset1, final int offset2);\npublic static void swap(final byte[] array, final int offset1, final int offset2);\npublic static void swap(final double[] array, final int offset1, final int offset2);\npublic static void swap(final float[] array, final int offset1, final int offset2);\npublic static void swap(final boolean[] array, final int offset1, final int offset2);\npublic static void swap(final boolean[] array, int offset1, int offset2, int len);\npublic static void swap(final byte[] array, int offset1, int offset2, int len);\npublic static void swap(final char[] array, int offset1, int offset2, int len);\npublic static void swap(final double[] array, int offset1, int offset2, int len);\npublic static void swap(final float[] array, int offset1, int offset2, int len);\npublic static void swap(final int[] array, int offset1, int offset2, int len);\npublic static void swap(final long[] array, int offset1, int offset2, int len);\npublic static void swap(final Object[] array, int offset1, int offset2, int len);\npublic static void swap(final short[] array, int offset1, int offset2, int len);\npublic static void shift(final Object[] array, final int offset);\npublic static void shift(final long[] array, final int offset);\npublic static void shift(final int[] array, final int offset);\npublic static void shift(final short[] array, final int offset);\npublic static void shift(final char[] array, final int offset);\npublic static void shift(final byte[] array, final int offset);\npublic static void shift(final double[] array, final int offset);\npublic static void shift(final float[] array, final int offset);\npublic static void shift(final boolean[] array, final int offset);\npublic static void shift(final boolean[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final byte[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final char[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final double[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final float[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final int[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final long[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final Object[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final short[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static int indexOf(final Object[] array, final Object objectToFind);\npublic static int indexOf(final Object[] array, final Object objectToFind, int startIndex);\npublic static int lastIndexOf(final Object[] array, final Object objectToFind);\npublic static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex);\npublic static boolean contains(final Object[] array, final Object objectToFind);\npublic static int indexOf(final long[] array, final long valueToFind);\npublic static int indexOf(final long[] array, final long valueToFind, int startIndex);\npublic static int lastIndexOf(final long[] array, final long valueToFind);\npublic static int lastIndexOf(final long[] array, final long valueToFind, int startIndex);\npublic static boolean contains(final long[] array, final long valueToFind);\npublic static int indexOf(final int[] array, final int valueToFind);\npublic static int indexOf(final int[] array, final int valueToFind, int startIndex);\npublic static int lastIndexOf(final int[] array, final int valueToFind);\npublic static int lastIndexOf(final int[] array, final int valueToFind, int startIndex);\npublic static boolean contains(final int[] array, final int valueToFind);\npublic static int indexOf(final short[] array, final short valueToFind);\npublic static int indexOf(final short[] array, final short valueToFind, int startIndex);\npublic static int lastIndexOf(final short[] array, final short valueToFind);\npublic static int lastIndexOf(final short[] array, final short valueToFind, int startIndex);\npublic static boolean contains(final short[] array, final short valueToFind);\npublic static int indexOf(final char[] array, final char valueToFind);\npublic static int indexOf(final char[] array, final char valueToFind, int startIndex);\npublic static int lastIndexOf(final char[] array, final char valueToFind);\npublic static int lastIndexOf(final char[] array, final char valueToFind, int startIndex);\npublic static boolean contains(final char[] array, final char valueToFind);\npublic static int indexOf(final byte[] array, final byte valueToFind);\npublic static int indexOf(final byte[] array, final byte valueToFind, int startIndex);\npublic static int lastIndexOf(final byte[] array, final byte valueToFind);\npublic static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex);\npublic static boolean contains(final byte[] array, final byte valueToFind);\npublic static int indexOf(final double[] array, final double valueToFind);\npublic static int indexOf(final double[] array, final double valueToFind, final double tolerance);\npublic static int indexOf(final double[] array, final double valueToFind, int startIndex);\npublic static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance);\npublic static int lastIndexOf(final double[] array, final double valueToFind);\npublic static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance);\npublic static int lastIndexOf(final double[] array, final double valueToFind, int startIndex);\npublic static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance);\npublic static boolean contains(final double[] array, final double valueToFind);\npublic static boolean contains(final double[] array, final double valueToFind, final double tolerance);\npublic static int indexOf(final float[] array, final float valueToFind);\npublic static int indexOf(final float[] array, final float valueToFind, int startIndex);\npublic static int lastIndexOf(final float[] array, final float valueToFind);\npublic static int lastIndexOf(final float[] array, final float valueToFind, int startIndex);\npublic static boolean contains(final float[] array, final float valueToFind);\npublic static int indexOf(final boolean[] array, final boolean valueToFind);\npublic static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex);\npublic static int lastIndexOf(final boolean[] array, final boolean valueToFind);\npublic static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex);\npublic static boolean contains(final boolean[] array, final boolean valueToFind);\npublic static char[] toPrimitive(final Character[] array);\npublic static char[] toPrimitive(final Character[] array, final char valueForNull);\npublic static Character[] toObject(final char[] array);\npublic static long[] toPrimitive(final Long[] array);\npublic static long[] toPrimitive(final Long[] array, final long valueForNull);\npublic static Long[] toObject(final long[] array);\npublic static int[] toPrimitive(final Integer[] array);\npublic static int[] toPrimitive(final Integer[] array, final int valueForNull);\npublic static Integer[] toObject(final int[] array);\npublic static short[] toPrimitive(final Short[] array);\npublic static short[] toPrimitive(final Short[] array, final short valueForNull);\npublic static Short[] toObject(final short[] array);\npublic static byte[] toPrimitive(final Byte[] array);\npublic static byte[] toPrimitive(final Byte[] array, final byte valueForNull);\npublic static Byte[] toObject(final byte[] array);\npublic static double[] toPrimitive(final Double[] array);\npublic static double[] toPrimitive(final Double[] array, final double valueForNull);\npublic static Double[] toObject(final double[] array);\npublic static float[] toPrimitive(final Float[] array);\npublic static float[] toPrimitive(final Float[] array, final float valueForNull);\npublic static Float[] toObject(final float[] array);\npublic static Object toPrimitive(final Object array);\npublic static boolean[] toPrimitive(final Boolean[] array);\npublic static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull);\npublic static Boolean[] toObject(final boolean[] array);\npublic static boolean isEmpty(final Object[] array);\npublic static boolean isEmpty(final long[] array);\npublic static boolean isEmpty(final int[] array);\npublic static boolean isEmpty(final short[] array);\npublic static boolean isEmpty(final char[] array);\npublic static boolean isEmpty(final byte[] array);\npublic static boolean isEmpty(final double[] array);\npublic static boolean isEmpty(final float[] array);\npublic static boolean isEmpty(final boolean[] array);\npublic static boolean isNotEmpty(final T[] array);\npublic static boolean isNotEmpty(final long[] array);\npublic static boolean isNotEmpty(final int[] array);\npublic static boolean isNotEmpty(final short[] array);\npublic static boolean isNotEmpty(final char[] array);\npublic static boolean isNotEmpty(final byte[] array);\npublic static boolean isNotEmpty(final double[] array);\npublic static boolean isNotEmpty(final float[] array);\npublic static boolean isNotEmpty(final boolean[] array);\npublic static T[] addAll(final T[] array1, final T... array2);\npublic static boolean[] addAll(final boolean[] array1, final boolean... array2);\npublic static char[] addAll(final char[] array1, final char... array2);\npublic static byte[] addAll(final byte[] array1, final byte... array2);\npublic static short[] addAll(final short[] array1, final short... array2);\npublic static int[] addAll(final int[] array1, final int... array2);\npublic static long[] addAll(final long[] array1, final long... array2);\npublic static float[] addAll(final float[] array1, final float... array2);\npublic static double[] addAll(final double[] array1, final double... array2);\npublic static T[] add(final T[] array, final T element);\npublic static boolean[] add(final boolean[] array, final boolean element);\npublic static byte[] add(final byte[] array, final byte element);\npublic static char[] add(final char[] array, final char element);\npublic static double[] add(final double[] array, final double element);\npublic static float[] add(final float[] array, final float element);\npublic static int[] add(final int[] array, final int element);\npublic static long[] add(final long[] array, final long element);\npublic static short[] add(final short[] array, final short element);\npublic static T[] add(final T[] array, final int index, final T element);\npublic static boolean[] add(final boolean[] array, final int index, final boolean element);\npublic static char[] add(final char[] array, final int index, final char element);\npublic static byte[] add(final byte[] array, final int index, final byte element);\npublic static short[] add(final short[] array, final int index, final short element);\npublic static int[] add(final int[] array, final int index, final int element);\npublic static long[] add(final long[] array, final int index, final long element);\npublic static float[] add(final float[] array, final int index, final float element);\npublic static double[] add(final double[] array, final int index, final double element);\npublic static T[] remove(final T[] array, final int index);\npublic static T[] removeElement(final T[] array, final Object element);\npublic static boolean[] remove(final boolean[] array, final int index);\npublic static boolean[] removeElement(final boolean[] array, final boolean element);\npublic static byte[] remove(final byte[] array, final int index);\npublic static byte[] removeElement(final byte[] array, final byte element);\npublic static char[] remove(final char[] array, final int index);\npublic static char[] removeElement(final char[] array, final char element);\npublic static double[] remove(final double[] array, final int index);\npublic static double[] removeElement(final double[] array, final double element);\npublic static float[] remove(final float[] array, final int index);\npublic static float[] removeElement(final float[] array, final float element);\npublic static int[] remove(final int[] array, final int index);\npublic static int[] removeElement(final int[] array, final int element);\npublic static long[] remove(final long[] array, final int index);\npublic static long[] removeElement(final long[] array, final long element);\npublic static short[] remove(final short[] array, final int index);\npublic static short[] removeElement(final short[] array, final short element);\npublic static T[] removeAll(final T[] array, final int... indices);\npublic static T[] removeElements(final T[] array, final T... values);\npublic static byte[] removeAll(final byte[] array, final int... indices);\npublic static byte[] removeElements(final byte[] array, final byte... values);\npublic static short[] removeAll(final short[] array, final int... indices);\npublic static short[] removeElements(final short[] array, final short... values);\npublic static int[] removeAll(final int[] array, final int... indices);\npublic static int[] removeElements(final int[] array, final int... values);\npublic static char[] removeAll(final char[] array, final int... indices);\npublic static char[] removeElements(final char[] array, final char... values);\npublic static long[] removeAll(final long[] array, final int... indices);\npublic static long[] removeElements(final long[] array, final long... values);\npublic static float[] removeAll(final float[] array, final int... indices);\npublic static float[] removeElements(final float[] array, final float... values);\npublic static double[] removeAll(final double[] array, final int... indices);\npublic static double[] removeElements(final double[] array, final double... values);\npublic static boolean[] removeAll(final boolean[] array, final int... indices);\npublic static boolean[] removeElements(final boolean[] array, final boolean... values);\npublic static boolean isSorted(final T[] array);\npublic static boolean isSorted(final T[] array, final Comparator<T> comparator);\npublic static boolean isSorted(final int[] array);\npublic static boolean isSorted(final long[] array);\npublic static boolean isSorted(final short[] array);\npublic static boolean isSorted(final double[] array);\npublic static boolean isSorted(final float[] array);\npublic static boolean isSorted(final byte[] array);\npublic static boolean isSorted(final char[] array);\npublic static boolean isSorted(final boolean[] array);\npublic static boolean[] removeAllOccurences(final boolean[] array, final boolean element);\npublic static char[] removeAllOccurences(final char[] array, final char element);\npublic static byte[] removeAllOccurences(final byte[] array, final byte element);\npublic static short[] removeAllOccurences(final short[] array, final short element);\npublic static int[] removeAllOccurences(final int[] array, final int element);\npublic static long[] removeAllOccurences(final long[] array, final long element);\npublic static float[] removeAllOccurences(final float[] array, final float element);\npublic static double[] removeAllOccurences(final double[] array, final double element);\npublic static T[] removeAllOccurences(final T[] array, final T element);\npublic static String[] toStringArray(final Object[] array);\npublic static String[] toStringArray(final Object[] array, final String valueForNullElements);\npublic static boolean[] insert(final int index, final boolean[] array, final boolean... values);\npublic static byte[] insert(final int index, final byte[] array, final byte... values);\npublic static char[] insert(final int index, final char[] array, final char... values);\npublic static double[] insert(final int index, final double[] array, final double... values);\npublic static float[] insert(final int index, final float[] array, final float... values);\npublic static int[] insert(final int index, final int[] array, final int... values);\npublic static long[] insert(final int index, final long[] array, final long... values);\npublic static short[] insert(final int index, final short[] array, final short... values);\npublic static T[] insert(final int index, final T[] array, final T... values);\npublic static void shuffle(final Object[] array);\npublic static void shuffle(final Object[] array, final Random random);\npublic static void shuffle(final boolean[] array);\npublic static void shuffle(final boolean[] array, final Random random);\npublic static void shuffle(final byte[] array);\npublic static void shuffle(final byte[] array, final Random random);\npublic static void shuffle(final char[] array);\npublic static void shuffle(final char[] array, final Random random);\npublic static void shuffle(final short[] array);\npublic static void shuffle(final short[] array, final Random random);\npublic static void shuffle(final int[] array);\npublic static void shuffle(final int[] array, final Random random);\npublic static void shuffle(final long[] array);\npublic static void shuffle(final long[] array, final Random random);\npublic static void shuffle(final float[] array);\npublic static void shuffle(final float[] array, final Random random);\npublic static void shuffle(final double[] array);\npublic static void shuffle(final double[] array, final Random random);",
      "public_field": "/**\n * An empty immutable {@code Object} array.\n */\npublic static final Object[] EMPTY_OBJECT_ARRAY = new Object[0];\n/**\n * An empty immutable {@code Class} array.\n */\npublic static final Class<?>[] EMPTY_CLASS_ARRAY = new Class[0];\n/**\n * An empty immutable {@code String} array.\n */\npublic static final String[] EMPTY_STRING_ARRAY = new String[0];\n/**\n * An empty immutable {@code long} array.\n */\npublic static final long[] EMPTY_LONG_ARRAY = new long[0];\n/**\n * An empty immutable {@code Long} array.\n */\npublic static final Long[] EMPTY_LONG_OBJECT_ARRAY = new Long[0];\n/**\n * An empty immutable {@code int} array.\n */\npublic static final int[] EMPTY_INT_ARRAY = new int[0];\n/**\n * An empty immutable {@code Integer} array.\n */\npublic static final Integer[] EMPTY_INTEGER_OBJECT_ARRAY = new Integer[0];\n/**\n * An empty immutable {@code short} array.\n */\npublic static final short[] EMPTY_SHORT_ARRAY = new short[0];\n/**\n * An empty immutable {@code Short} array.\n */\npublic static final Short[] EMPTY_SHORT_OBJECT_ARRAY = new Short[0];\n/**\n * An empty immutable {@code byte} array.\n */\npublic static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n/**\n * An empty immutable {@code Byte} array.\n */\npublic static final Byte[] EMPTY_BYTE_OBJECT_ARRAY = new Byte[0];\n/**\n * An empty immutable {@code double} array.\n */\npublic static final double[] EMPTY_DOUBLE_ARRAY = new double[0];\n/**\n * An empty immutable {@code Double} array.\n */\npublic static final Double[] EMPTY_DOUBLE_OBJECT_ARRAY = new Double[0];\n/**\n * An empty immutable {@code float} array.\n */\npublic static final float[] EMPTY_FLOAT_ARRAY = new float[0];\n/**\n * An empty immutable {@code Float} array.\n */\npublic static final Float[] EMPTY_FLOAT_OBJECT_ARRAY = new Float[0];\n/**\n * An empty immutable {@code boolean} array.\n */\npublic static final boolean[] EMPTY_BOOLEAN_ARRAY = new boolean[0];\n/**\n * An empty immutable {@code Boolean} array.\n */\npublic static final Boolean[] EMPTY_BOOLEAN_OBJECT_ARRAY = new Boolean[0];\n/**\n * An empty immutable {@code char} array.\n */\npublic static final char[] EMPTY_CHAR_ARRAY = new char[0];\n/**\n * An empty immutable {@code Character} array.\n */\npublic static final Character[] EMPTY_CHARACTER_OBJECT_ARRAY = new Character[0];\n/**\n * The index value when an element is not found in a list or array: {@code -1}.\n * This value is returned by methods in this class and can also be used in comparisons with values returned by\n * various method from {@link java.util.List}.\n */\npublic static final int INDEX_NOT_FOUND = -1;",
      "Method_statement": "toMap(final Object() array)",
      "Method_name": "toMap",
      "Class_declaration": "public class ArrayUtils {\n",
      "constructors": "public ArrayUtils() {\n    super();\n}",
      "all_method_signature": "public ArrayUtils();\npublic static String toString(final Object array);\npublic static String toString(final Object array, final String stringIfNull);\npublic static int hashCode(final Object array);\npublic static boolean isEquals(final Object array1, final Object array2);\npublic static Map<Object, Object> toMap(final Object[] array);\npublic static T[] toArray(final T... items);\npublic static T[] clone(final T[] array);\npublic static long[] clone(final long[] array);\npublic static int[] clone(final int[] array);\npublic static short[] clone(final short[] array);\npublic static char[] clone(final char[] array);\npublic static byte[] clone(final byte[] array);\npublic static double[] clone(final double[] array);\npublic static float[] clone(final float[] array);\npublic static boolean[] clone(final boolean[] array);\npublic static T[] nullToEmpty(final T[] array, final Class<T[]> type);\npublic static Object[] nullToEmpty(final Object[] array);\npublic static Class<?>[] nullToEmpty(final Class<?>[] array);\npublic static String[] nullToEmpty(final String[] array);\npublic static long[] nullToEmpty(final long[] array);\npublic static int[] nullToEmpty(final int[] array);\npublic static short[] nullToEmpty(final short[] array);\npublic static char[] nullToEmpty(final char[] array);\npublic static byte[] nullToEmpty(final byte[] array);\npublic static double[] nullToEmpty(final double[] array);\npublic static float[] nullToEmpty(final float[] array);\npublic static boolean[] nullToEmpty(final boolean[] array);\npublic static Long[] nullToEmpty(final Long[] array);\npublic static Integer[] nullToEmpty(final Integer[] array);\npublic static Short[] nullToEmpty(final Short[] array);\npublic static Character[] nullToEmpty(final Character[] array);\npublic static Byte[] nullToEmpty(final Byte[] array);\npublic static Double[] nullToEmpty(final Double[] array);\npublic static Float[] nullToEmpty(final Float[] array);\npublic static Boolean[] nullToEmpty(final Boolean[] array);\npublic static T[] subarray(final T[] array, int startIndexInclusive, int endIndexExclusive);\npublic static long[] subarray(final long[] array, int startIndexInclusive, int endIndexExclusive);\npublic static int[] subarray(final int[] array, int startIndexInclusive, int endIndexExclusive);\npublic static short[] subarray(final short[] array, int startIndexInclusive, int endIndexExclusive);\npublic static char[] subarray(final char[] array, int startIndexInclusive, int endIndexExclusive);\npublic static byte[] subarray(final byte[] array, int startIndexInclusive, int endIndexExclusive);\npublic static double[] subarray(final double[] array, int startIndexInclusive, int endIndexExclusive);\npublic static float[] subarray(final float[] array, int startIndexInclusive, int endIndexExclusive);\npublic static boolean[] subarray(final boolean[] array, int startIndexInclusive, int endIndexExclusive);\npublic static boolean isSameLength(final Object[] array1, final Object[] array2);\npublic static boolean isSameLength(final long[] array1, final long[] array2);\npublic static boolean isSameLength(final int[] array1, final int[] array2);\npublic static boolean isSameLength(final short[] array1, final short[] array2);\npublic static boolean isSameLength(final char[] array1, final char[] array2);\npublic static boolean isSameLength(final byte[] array1, final byte[] array2);\npublic static boolean isSameLength(final double[] array1, final double[] array2);\npublic static boolean isSameLength(final float[] array1, final float[] array2);\npublic static boolean isSameLength(final boolean[] array1, final boolean[] array2);\npublic static int getLength(final Object array);\npublic static boolean isSameType(final Object array1, final Object array2);\npublic static void reverse(final Object[] array);\npublic static void reverse(final long[] array);\npublic static void reverse(final int[] array);\npublic static void reverse(final short[] array);\npublic static void reverse(final char[] array);\npublic static void reverse(final byte[] array);\npublic static void reverse(final double[] array);\npublic static void reverse(final float[] array);\npublic static void reverse(final boolean[] array);\npublic static void reverse(final boolean[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final byte[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final char[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final double[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final float[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final int[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final long[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final Object[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void reverse(final short[] array, final int startIndexInclusive, final int endIndexExclusive);\npublic static void swap(final Object[] array, final int offset1, final int offset2);\npublic static void swap(final long[] array, final int offset1, final int offset2);\npublic static void swap(final int[] array, final int offset1, final int offset2);\npublic static void swap(final short[] array, final int offset1, final int offset2);\npublic static void swap(final char[] array, final int offset1, final int offset2);\npublic static void swap(final byte[] array, final int offset1, final int offset2);\npublic static void swap(final double[] array, final int offset1, final int offset2);\npublic static void swap(final float[] array, final int offset1, final int offset2);\npublic static void swap(final boolean[] array, final int offset1, final int offset2);\npublic static void swap(final boolean[] array, int offset1, int offset2, int len);\npublic static void swap(final byte[] array, int offset1, int offset2, int len);\npublic static void swap(final char[] array, int offset1, int offset2, int len);\npublic static void swap(final double[] array, int offset1, int offset2, int len);\npublic static void swap(final float[] array, int offset1, int offset2, int len);\npublic static void swap(final int[] array, int offset1, int offset2, int len);\npublic static void swap(final long[] array, int offset1, int offset2, int len);\npublic static void swap(final Object[] array, int offset1, int offset2, int len);\npublic static void swap(final short[] array, int offset1, int offset2, int len);\npublic static void shift(final Object[] array, final int offset);\npublic static void shift(final long[] array, final int offset);\npublic static void shift(final int[] array, final int offset);\npublic static void shift(final short[] array, final int offset);\npublic static void shift(final char[] array, final int offset);\npublic static void shift(final byte[] array, final int offset);\npublic static void shift(final double[] array, final int offset);\npublic static void shift(final float[] array, final int offset);\npublic static void shift(final boolean[] array, final int offset);\npublic static void shift(final boolean[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final byte[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final char[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final double[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final float[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final int[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final long[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final Object[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static void shift(final short[] array, int startIndexInclusive, int endIndexExclusive, int offset);\npublic static int indexOf(final Object[] array, final Object objectToFind);\npublic static int indexOf(final Object[] array, final Object objectToFind, int startIndex);\npublic static int lastIndexOf(final Object[] array, final Object objectToFind);\npublic static int lastIndexOf(final Object[] array, final Object objectToFind, int startIndex);\npublic static boolean contains(final Object[] array, final Object objectToFind);\npublic static int indexOf(final long[] array, final long valueToFind);\npublic static int indexOf(final long[] array, final long valueToFind, int startIndex);\npublic static int lastIndexOf(final long[] array, final long valueToFind);\npublic static int lastIndexOf(final long[] array, final long valueToFind, int startIndex);\npublic static boolean contains(final long[] array, final long valueToFind);\npublic static int indexOf(final int[] array, final int valueToFind);\npublic static int indexOf(final int[] array, final int valueToFind, int startIndex);\npublic static int lastIndexOf(final int[] array, final int valueToFind);\npublic static int lastIndexOf(final int[] array, final int valueToFind, int startIndex);\npublic static boolean contains(final int[] array, final int valueToFind);\npublic static int indexOf(final short[] array, final short valueToFind);\npublic static int indexOf(final short[] array, final short valueToFind, int startIndex);\npublic static int lastIndexOf(final short[] array, final short valueToFind);\npublic static int lastIndexOf(final short[] array, final short valueToFind, int startIndex);\npublic static boolean contains(final short[] array, final short valueToFind);\npublic static int indexOf(final char[] array, final char valueToFind);\npublic static int indexOf(final char[] array, final char valueToFind, int startIndex);\npublic static int lastIndexOf(final char[] array, final char valueToFind);\npublic static int lastIndexOf(final char[] array, final char valueToFind, int startIndex);\npublic static boolean contains(final char[] array, final char valueToFind);\npublic static int indexOf(final byte[] array, final byte valueToFind);\npublic static int indexOf(final byte[] array, final byte valueToFind, int startIndex);\npublic static int lastIndexOf(final byte[] array, final byte valueToFind);\npublic static int lastIndexOf(final byte[] array, final byte valueToFind, int startIndex);\npublic static boolean contains(final byte[] array, final byte valueToFind);\npublic static int indexOf(final double[] array, final double valueToFind);\npublic static int indexOf(final double[] array, final double valueToFind, final double tolerance);\npublic static int indexOf(final double[] array, final double valueToFind, int startIndex);\npublic static int indexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance);\npublic static int lastIndexOf(final double[] array, final double valueToFind);\npublic static int lastIndexOf(final double[] array, final double valueToFind, final double tolerance);\npublic static int lastIndexOf(final double[] array, final double valueToFind, int startIndex);\npublic static int lastIndexOf(final double[] array, final double valueToFind, int startIndex, final double tolerance);\npublic static boolean contains(final double[] array, final double valueToFind);\npublic static boolean contains(final double[] array, final double valueToFind, final double tolerance);\npublic static int indexOf(final float[] array, final float valueToFind);\npublic static int indexOf(final float[] array, final float valueToFind, int startIndex);\npublic static int lastIndexOf(final float[] array, final float valueToFind);\npublic static int lastIndexOf(final float[] array, final float valueToFind, int startIndex);\npublic static boolean contains(final float[] array, final float valueToFind);\npublic static int indexOf(final boolean[] array, final boolean valueToFind);\npublic static int indexOf(final boolean[] array, final boolean valueToFind, int startIndex);\npublic static int lastIndexOf(final boolean[] array, final boolean valueToFind);\npublic static int lastIndexOf(final boolean[] array, final boolean valueToFind, int startIndex);\npublic static boolean contains(final boolean[] array, final boolean valueToFind);\npublic static char[] toPrimitive(final Character[] array);\npublic static char[] toPrimitive(final Character[] array, final char valueForNull);\npublic static Character[] toObject(final char[] array);\npublic static long[] toPrimitive(final Long[] array);\npublic static long[] toPrimitive(final Long[] array, final long valueForNull);\npublic static Long[] toObject(final long[] array);\npublic static int[] toPrimitive(final Integer[] array);\npublic static int[] toPrimitive(final Integer[] array, final int valueForNull);\npublic static Integer[] toObject(final int[] array);\npublic static short[] toPrimitive(final Short[] array);\npublic static short[] toPrimitive(final Short[] array, final short valueForNull);\npublic static Short[] toObject(final short[] array);\npublic static byte[] toPrimitive(final Byte[] array);\npublic static byte[] toPrimitive(final Byte[] array, final byte valueForNull);\npublic static Byte[] toObject(final byte[] array);\npublic static double[] toPrimitive(final Double[] array);\npublic static double[] toPrimitive(final Double[] array, final double valueForNull);\npublic static Double[] toObject(final double[] array);\npublic static float[] toPrimitive(final Float[] array);\npublic static float[] toPrimitive(final Float[] array, final float valueForNull);\npublic static Float[] toObject(final float[] array);\npublic static Object toPrimitive(final Object array);\npublic static boolean[] toPrimitive(final Boolean[] array);\npublic static boolean[] toPrimitive(final Boolean[] array, final boolean valueForNull);\npublic static Boolean[] toObject(final boolean[] array);\npublic static boolean isEmpty(final Object[] array);\npublic static boolean isEmpty(final long[] array);\npublic static boolean isEmpty(final int[] array);\npublic static boolean isEmpty(final short[] array);\npublic static boolean isEmpty(final char[] array);\npublic static boolean isEmpty(final byte[] array);\npublic static boolean isEmpty(final double[] array);\npublic static boolean isEmpty(final float[] array);\npublic static boolean isEmpty(final boolean[] array);\npublic static boolean isNotEmpty(final T[] array);\npublic static boolean isNotEmpty(final long[] array);\npublic static boolean isNotEmpty(final int[] array);\npublic static boolean isNotEmpty(final short[] array);\npublic static boolean isNotEmpty(final char[] array);\npublic static boolean isNotEmpty(final byte[] array);\npublic static boolean isNotEmpty(final double[] array);\npublic static boolean isNotEmpty(final float[] array);\npublic static boolean isNotEmpty(final boolean[] array);\npublic static T[] addAll(final T[] array1, final T... array2);\npublic static boolean[] addAll(final boolean[] array1, final boolean... array2);\npublic static char[] addAll(final char[] array1, final char... array2);\npublic static byte[] addAll(final byte[] array1, final byte... array2);\npublic static short[] addAll(final short[] array1, final short... array2);\npublic static int[] addAll(final int[] array1, final int... array2);\npublic static long[] addAll(final long[] array1, final long... array2);\npublic static float[] addAll(final float[] array1, final float... array2);\npublic static double[] addAll(final double[] array1, final double... array2);\npublic static T[] add(final T[] array, final T element);\npublic static boolean[] add(final boolean[] array, final boolean element);\npublic static byte[] add(final byte[] array, final byte element);\npublic static char[] add(final char[] array, final char element);\npublic static double[] add(final double[] array, final double element);\npublic static float[] add(final float[] array, final float element);\npublic static int[] add(final int[] array, final int element);\npublic static long[] add(final long[] array, final long element);\npublic static short[] add(final short[] array, final short element);\nprivate static Object copyArrayGrow1(final Object array, final Class<?> newArrayComponentType);\npublic static T[] add(final T[] array, final int index, final T element);\npublic static boolean[] add(final boolean[] array, final int index, final boolean element);\npublic static char[] add(final char[] array, final int index, final char element);\npublic static byte[] add(final byte[] array, final int index, final byte element);\npublic static short[] add(final short[] array, final int index, final short element);\npublic static int[] add(final int[] array, final int index, final int element);\npublic static long[] add(final long[] array, final int index, final long element);\npublic static float[] add(final float[] array, final int index, final float element);\npublic static double[] add(final double[] array, final int index, final double element);\nprivate static Object add(final Object array, final int index, final Object element, final Class<?> clss);\npublic static T[] remove(final T[] array, final int index);\npublic static T[] removeElement(final T[] array, final Object element);\npublic static boolean[] remove(final boolean[] array, final int index);\npublic static boolean[] removeElement(final boolean[] array, final boolean element);\npublic static byte[] remove(final byte[] array, final int index);\npublic static byte[] removeElement(final byte[] array, final byte element);\npublic static char[] remove(final char[] array, final int index);\npublic static char[] removeElement(final char[] array, final char element);\npublic static double[] remove(final double[] array, final int index);\npublic static double[] removeElement(final double[] array, final double element);\npublic static float[] remove(final float[] array, final int index);\npublic static float[] removeElement(final float[] array, final float element);\npublic static int[] remove(final int[] array, final int index);\npublic static int[] removeElement(final int[] array, final int element);\npublic static long[] remove(final long[] array, final int index);\npublic static long[] removeElement(final long[] array, final long element);\npublic static short[] remove(final short[] array, final int index);\npublic static short[] removeElement(final short[] array, final short element);\nprivate static Object remove(final Object array, final int index);\npublic static T[] removeAll(final T[] array, final int... indices);\npublic static T[] removeElements(final T[] array, final T... values);\npublic static byte[] removeAll(final byte[] array, final int... indices);\npublic static byte[] removeElements(final byte[] array, final byte... values);\npublic static short[] removeAll(final short[] array, final int... indices);\npublic static short[] removeElements(final short[] array, final short... values);\npublic static int[] removeAll(final int[] array, final int... indices);\npublic static int[] removeElements(final int[] array, final int... values);\npublic static char[] removeAll(final char[] array, final int... indices);\npublic static char[] removeElements(final char[] array, final char... values);\npublic static long[] removeAll(final long[] array, final int... indices);\npublic static long[] removeElements(final long[] array, final long... values);\npublic static float[] removeAll(final float[] array, final int... indices);\npublic static float[] removeElements(final float[] array, final float... values);\npublic static double[] removeAll(final double[] array, final int... indices);\npublic static double[] removeElements(final double[] array, final double... values);\npublic static boolean[] removeAll(final boolean[] array, final int... indices);\npublic static boolean[] removeElements(final boolean[] array, final boolean... values);\n static Object removeAll(final Object array, final int... indices);\n static Object removeAll(final Object array, final BitSet indices);\npublic static boolean isSorted(final T[] array);\npublic static boolean isSorted(final T[] array, final Comparator<T> comparator);\npublic static boolean isSorted(final int[] array);\npublic static boolean isSorted(final long[] array);\npublic static boolean isSorted(final short[] array);\npublic static boolean isSorted(final double[] array);\npublic static boolean isSorted(final float[] array);\npublic static boolean isSorted(final byte[] array);\npublic static boolean isSorted(final char[] array);\npublic static boolean isSorted(final boolean[] array);\npublic static boolean[] removeAllOccurences(final boolean[] array, final boolean element);\npublic static char[] removeAllOccurences(final char[] array, final char element);\npublic static byte[] removeAllOccurences(final byte[] array, final byte element);\npublic static short[] removeAllOccurences(final short[] array, final short element);\npublic static int[] removeAllOccurences(final int[] array, final int element);\npublic static long[] removeAllOccurences(final long[] array, final long element);\npublic static float[] removeAllOccurences(final float[] array, final float element);\npublic static double[] removeAllOccurences(final double[] array, final double element);\npublic static T[] removeAllOccurences(final T[] array, final T element);\npublic static String[] toStringArray(final Object[] array);\npublic static String[] toStringArray(final Object[] array, final String valueForNullElements);\npublic static boolean[] insert(final int index, final boolean[] array, final boolean... values);\npublic static byte[] insert(final int index, final byte[] array, final byte... values);\npublic static char[] insert(final int index, final char[] array, final char... values);\npublic static double[] insert(final int index, final double[] array, final double... values);\npublic static float[] insert(final int index, final float[] array, final float... values);\npublic static int[] insert(final int index, final int[] array, final int... values);\npublic static long[] insert(final int index, final long[] array, final long... values);\npublic static short[] insert(final int index, final short[] array, final short... values);\npublic static T[] insert(final int index, final T[] array, final T... values);\npublic static void shuffle(final Object[] array);\npublic static void shuffle(final Object[] array, final Random random);\npublic static void shuffle(final boolean[] array);\npublic static void shuffle(final boolean[] array, final Random random);\npublic static void shuffle(final byte[] array);\npublic static void shuffle(final byte[] array, final Random random);\npublic static void shuffle(final char[] array);\npublic static void shuffle(final char[] array, final Random random);\npublic static void shuffle(final short[] array);\npublic static void shuffle(final short[] array, final Random random);\npublic static void shuffle(final int[] array);\npublic static void shuffle(final int[] array, final Random random);\npublic static void shuffle(final long[] array);\npublic static void shuffle(final long[] array, final Random random);\npublic static void shuffle(final float[] array);\npublic static void shuffle(final float[] array, final Random random);\npublic static void shuffle(final double[] array);\npublic static void shuffle(final double[] array, final Random random);",
      "Class_name": "ArrayUtils",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/ArrayUtils###toMap",
      "Parameter_num": "1",
      "all_Import_statements": "import java.lang.reflect.Array;\n\nimport java.util.Arrays;\n\nimport java.util.BitSet;\n\nimport java.util.Comparator;\n\nimport java.util.HashMap;\n\nimport java.util.Map;\n\nimport java.util.Random;\n\nimport org.apache.commons.lang3.builder.EqualsBuilder;\n\nimport org.apache.commons.lang3.builder.HashCodeBuilder;\n\nimport org.apache.commons.lang3.builder.ToStringBuilder;\n\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport org.apache.commons.lang3.math.NumberUtils;\n\nimport org.apache.commons.lang3.mutable.MutableInt;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>Converts the given array into a {@link java.util.Map}. Each element of the array\n     * must be either a {@link java.util.Map.Entry} or an Array, containing at least two\n     * elements, where the first element is used as key and the second as\n     * value.\n     *\n     * <p>This method can be used to initialize:\n     * <pre>\n     * // Create a Map mapping colors.\n     * Map colorMap = ArrayUtils.toMap(new String[][] {\n     *     {\"RED\", \"#FF0000\"},\n     *     {\"GREEN\", \"#00FF00\"},\n     *     {\"BLUE\", \"#0000FF\"}});\n     * </pre>\n     *\n     * <p>This method returns {@code null} for a {@code null} input array.\n     *\n     * @param array  an array whose elements are either a {@link java.util.Map.Entry} or\n     *  an Array containing at least two elements, may be {@code null}\n     * @return a {@code Map} that was created from the array\n     * @throws IllegalArgumentException  if one element of this Array is\n     *  itself an Array containing less then two elements\n     * @throws IllegalArgumentException  if the array contains elements other\n     *  than {@link java.util.Map.Entry} and an Array\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static Map<Object, Object> toMap(final Object[] array);",
      "Junit_version": "4",
      "returnType": "Map<Object,Object>"
    },
    "Test_method": {
      "Method_body": "Map<?, ?> map = ArrayUtils.toMap(new String[][] { { \"foo\", \"bar\" }, { \"hello\", \"world\" } });\n\rassertEquals(\"bar\", map.get(\"foo\"));\n\rassertEquals(\"world\", map.get(\"hello\"));\n\rassertNull(ArrayUtils.toMap(null));\n\rtry {\n    ArrayUtils.toMap(new String[][] { { \"foo\", \"bar\" }, { \"short\" } });\n    fail(\"exception expected\");\n} catch (final IllegalArgumentException ex) {\n}\n\rtry {\n    ArrayUtils.toMap(new Object[] { new Object[] { \"foo\", \"bar\" }, \"illegal type\" });\n    fail(\"exception expected\");\n} catch (final IllegalArgumentException ex) {\n}\n\rtry {\n    ArrayUtils.toMap(new Object[] { new Object[] { \"foo\", \"bar\" }, null });\n    fail(\"exception expected\");\n} catch (final IllegalArgumentException ex) {\n}\n\rmap = ArrayUtils.toMap(new Object[] { new Map.Entry<Object, Object>() {\n\n    @Override\n    public Object getKey() {\n        return \"foo\";\n    }\n\n    @Override\n    public Object getValue() {\n        return \"bar\";\n    }\n\n    @Override\n    public Object setValue(final Object value) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public boolean equals(final Object o) {\n        throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public int hashCode() {\n        throw new UnsupportedOperationException();\n    }\n} });\n\rassertEquals(\"bar\", map.get(\"foo\"));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "9",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.fail;\nimport java.util.Map;\n",
      "allMethod_info": "// -----------------------------------------------------------------------\n@Test\npublic void testToMap() {\n    Map<?, ?> map = ArrayUtils.toMap(new String[][] { { \"foo\", \"bar\" }, { \"hello\", \"world\" } });\n    assertEquals(\"bar\", map.get(\"foo\"));\n    assertEquals(\"world\", map.get(\"hello\"));\n    assertNull(ArrayUtils.toMap(null));\n    try {\n        ArrayUtils.toMap(new String[][] { { \"foo\", \"bar\" }, { \"short\" } });\n        fail(\"exception expected\");\n    } catch (final IllegalArgumentException ex) {\n    }\n    try {\n        ArrayUtils.toMap(new Object[] { new Object[] { \"foo\", \"bar\" }, \"illegal type\" });\n        fail(\"exception expected\");\n    } catch (final IllegalArgumentException ex) {\n    }\n    try {\n        ArrayUtils.toMap(new Object[] { new Object[] { \"foo\", \"bar\" }, null });\n        fail(\"exception expected\");\n    } catch (final IllegalArgumentException ex) {\n    }\n    map = ArrayUtils.toMap(new Object[] { new Map.Entry<Object, Object>() {\n\n        @Override\n        public Object getKey() {\n            return \"foo\";\n        }\n\n        @Override\n        public Object getValue() {\n            return \"bar\";\n        }\n\n        @Override\n        public Object setValue(final Object value) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public boolean equals(final Object o) {\n            throw new UnsupportedOperationException();\n        }\n\n        @Override\n        public int hashCode() {\n            throw new UnsupportedOperationException();\n        }\n    } });\n    assertEquals(\"bar\", map.get(\"foo\"));\n}",
      "Method_name": "testToMap",
      "Class_declaration": "public class ArrayUtilsTest {\n",
      "constructors": "",
      "Class_name": "ArrayUtilsTest",
      "methodName_paraNum": "[toMap(1), get(1), get(1), toMap(1), toMap(1), fail(1), toMap(1), fail(1), toMap(1), fail(1), toMap(1), get(1)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ArrayUtilsTest###testToMap",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ArrayUtilsTest.java",
      "Signature": "public void testToMap() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertNotSame;\n\nimport static org.junit.Assert.assertNull;\n\nimport static org.junit.Assert.assertSame;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.junit.Assert.fail;\n\nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Modifier;\n\nimport java.util.Arrays;\n\nimport java.util.Comparator;\n\nimport java.util.Date;\n\nimport java.util.Map;\n\nimport org.junit.Test;\n",
      "comment": "-----------------------------------------------------------------------",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public synchronized boolean sync(T value) throws NullPointerException {\n    boolean pushed = push(value);\n    synced();\n    return pushed;\n}",
      "all_field_declaration": "/**\n * The stack of changes being tracked.\n */\nprivate final List<T> stack;\n/**\n * The current location in the stack. This will change as operations are\n * performed (such as changing the value, undoing a change, or redoing a\n * change).\n */\nprivate int currentLoc;\n/**\n * The location of the last value that was synchronized. It is up to the\n * client to determine when this should be set (e.g. what does it mean to be\n * synchronized).\n */\nprivate int syncLoc = -1;",
      "sub_project_name": "syphr42_prom",
      "lineNumbers": "3",
      "Filed": "",
      "Parameter_type": "T",
      "Import_statements": "",
      "public_method_signature": "public ChangeStack(T value);\npublic ChangeStack(T value, boolean sync);\npublic synchronized boolean push(T value) throws NullPointerException;\npublic synchronized boolean sync(T value) throws NullPointerException;\npublic synchronized void synced();\npublic synchronized boolean isModified();\npublic synchronized T getCurrentValue();\npublic synchronized T getSyncedValue();\npublic synchronized boolean isUndoPossible();\npublic synchronized boolean isRedoPossible();\npublic synchronized T undo();\npublic synchronized T redo();",
      "public_field": "",
      "Method_statement": "sync(T value)",
      "Method_name": "sync",
      "Class_declaration": "class ChangeStack {\n",
      "constructors": "public ChangeStack(T value) {\n    this(value, true);\n}public ChangeStack(T value, boolean sync) {\n    stack = new ArrayList<T>();\n    stack.add(value);\n    if (sync) {\n        synced();\n    }\n}",
      "all_method_signature": "public ChangeStack(T value);\npublic ChangeStack(T value, boolean sync);\npublic synchronized boolean push(T value) throws NullPointerException;\npublic synchronized boolean sync(T value) throws NullPointerException;\npublic synchronized void synced();\npublic synchronized boolean isModified();\npublic synchronized T getCurrentValue();\npublic synchronized T getSyncedValue();\npublic synchronized boolean isUndoPossible();\npublic synchronized boolean isRedoPossible();\npublic synchronized T undo();\npublic synchronized T redo();",
      "Class_name": "ChangeStack",
      "project_path": "syphr42_prom###syphr42_prom/src/main/java/org/syphr/prom/ChangeStack###sync",
      "Parameter_num": "1",
      "all_Import_statements": "import java.util.ArrayList;\n\nimport java.util.Iterator;\n\nimport java.util.List;\n",
      "comment": "\n     * This method behaves exactly like {@link #push(Object)}, except that it\n     * will mark the current value after {@link #push(Object)} as\n     * {@link #synced()}. The marking will happen regardless of whether or not\n     * the {@link #getCurrentValue() current value} changed as a result of this\n     * call.<br>\n     * <br>\n     * To put it another way, it is guaranteed that after this call\n     * {@link #getCurrentValue()} will return the given value and\n     * {@link #isModified()} will return <code>false</code>.\n     *\n     * @param value\n     *            the new value to push\n     * @return <code>true</code> if {@link #getCurrentValue()} changes as a\n     *         result of this call; <code>false</code> otherwise\n     * @throws NullPointerException\n     *             if the given value is <code>null</code>\n     ",
      "packageName": "org.syphr.prom",
      "method_signature": "public synchronized boolean sync(T value) throws NullPointerException;",
      "Junit_version": "4",
      "returnType": "boolean"
    },
    "Test_method": {
      "Method_body": "Assert.assertTrue(\"Sync'd a new value\", stack.sync(VALUE_1));\n\rAssert.assertFalse(\"Stack should not be in a modified state after sync\", stack.isModified());",
      "sub_project_name": "syphr42_prom",
      "lineNumbers": "2",
      "Filed": "private static final String VALUE_1 = \"value 1\";private ChangeStack<String> stack;",
      "Import_statements": "import junit.framework.Assert;\n",
      "allMethod_info": "@Test\npublic void testSync() {\n    Assert.assertTrue(\"Sync'd a new value\", stack.sync(VALUE_1));\n    Assert.assertFalse(\"Stack should not be in a modified state after sync\", stack.isModified());\n}",
      "Method_name": "testSync",
      "Class_declaration": "public class ChangeStackTest {\n",
      "constructors": "",
      "Class_name": "ChangeStackTest",
      "methodName_paraNum": "[sync(1), isModified(0)]",
      "project_path": "syphr42_prom###syphr42_prom/src/test/java/org/syphr/prom/ChangeStackTest###testSync",
      "relativePath": "syphr42_prom/src/test/java/org/syphr/prom/ChangeStackTest.java",
      "Signature": "public void testSync() {\n",
      "all_Import_statements": "import junit.framework.Assert;\n\nimport org.junit.Before;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.syphr.prom",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static CharSet getInstance(final String... setStrs) {\n    if (setStrs == null) {\n        return null;\n    }\n    if (setStrs.length == 1) {\n        final CharSet common = COMMON.get(setStrs[0]);\n        if (common != null) {\n            return common;\n        }\n    }\n    return new CharSet(setStrs);\n}",
      "all_field_declaration": "/**\n * Required for serialization support. Lang version 2.0.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 5947847346149275958L;\n/**\n * A CharSet defining no characters.\n * @since 2.0\n */\npublic static final CharSet EMPTY = new CharSet((String) null);\n/**\n * A CharSet defining ASCII alphabetic characters \"a-zA-Z\".\n * @since 2.0\n */\npublic static final CharSet ASCII_ALPHA = new CharSet(\"a-zA-Z\");\n/**\n * A CharSet defining ASCII alphabetic characters \"a-z\".\n * @since 2.0\n */\npublic static final CharSet ASCII_ALPHA_LOWER = new CharSet(\"a-z\");\n/**\n * A CharSet defining ASCII alphabetic characters \"A-Z\".\n * @since 2.0\n */\npublic static final CharSet ASCII_ALPHA_UPPER = new CharSet(\"A-Z\");\n/**\n * A CharSet defining ASCII alphabetic characters \"0-9\".\n * @since 2.0\n */\npublic static final CharSet ASCII_NUMERIC = new CharSet(\"0-9\");\n/**\n * A Map of the common cases used in the factory.\n * Subclasses can add more common patterns if desired\n * @since 2.0\n */\nprotected static final Map<String, CharSet> COMMON = new HashMap<String, CharSet>();\n/**\n * The set of CharRange objects.\n */\nprivate final Set<CharRange> set = new HashSet<CharRange>();",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "3",
      "Filed": "protected static final Map<String, CharSet> COMMON = new HashMap<String, CharSet>();private final Set<CharRange> set = new HashSet<CharRange>();",
      "Parameter_type": "String",
      "Import_statements": "import java.util.Set;\n",
      "public_method_signature": "public static CharSet getInstance(final String... setStrs);\npublic boolean contains(final char ch);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();",
      "public_field": "/**\n * A CharSet defining no characters.\n * @since 2.0\n */\npublic static final CharSet EMPTY = new CharSet((String) null);\n/**\n * A CharSet defining ASCII alphabetic characters \"a-zA-Z\".\n * @since 2.0\n */\npublic static final CharSet ASCII_ALPHA = new CharSet(\"a-zA-Z\");\n/**\n * A CharSet defining ASCII alphabetic characters \"a-z\".\n * @since 2.0\n */\npublic static final CharSet ASCII_ALPHA_LOWER = new CharSet(\"a-z\");\n/**\n * A CharSet defining ASCII alphabetic characters \"A-Z\".\n * @since 2.0\n */\npublic static final CharSet ASCII_ALPHA_UPPER = new CharSet(\"A-Z\");\n/**\n * A CharSet defining ASCII alphabetic characters \"0-9\".\n * @since 2.0\n */\npublic static final CharSet ASCII_NUMERIC = new CharSet(\"0-9\");",
      "Method_statement": "getInstance(final String... setStrs)",
      "Method_name": "getInstance",
      "Class_declaration": "public class CharSet {\n",
      "constructors": "protected CharSet(final String... set) {\n    super();\n    for (final String s : set) {\n        add(s);\n    }\n}",
      "all_method_signature": "public static CharSet getInstance(final String... setStrs);\nprotected CharSet(final String... set);\nprotected void add(final String str);\n CharRange[] getCharRanges();\npublic boolean contains(final char ch);\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();",
      "Class_name": "CharSet",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/CharSet###getInstance",
      "Parameter_num": "1",
      "all_Import_statements": "import java.io.Serializable;\n\nimport java.util.HashMap;\n\nimport java.util.HashSet;\n\nimport java.util.Map;\n\nimport java.util.Set;\n",
      "comment": "\n     * <p>Factory method to create a new CharSet using a special syntax.</p>\n     *\n     * <ul>\n     *  <li>{@code null} or empty string (\"\")\n     * - set containing no characters</li>\n     *  <li>Single character, such as \"a\"\n     *  - set containing just that character</li>\n     *  <li>Multi character, such as \"a-e\"\n     *  - set containing characters from one character to the other</li>\n     *  <li>Negated, such as \"^a\" or \"^a-e\"\n     *  - set containing all characters except those defined</li>\n     *  <li>Combinations, such as \"abe-g\"\n     *  - set containing all the characters from the individual sets</li>\n     * </ul>\n     *\n     * <p>The matching order is:</p>\n     * <ol>\n     *  <li>Negated multi character range, such as \"^a-e\"\n     *  <li>Ordinary multi character range, such as \"a-e\"\n     *  <li>Negated single character, such as \"^a\"\n     *  <li>Ordinary single character, such as \"a\"\n     * </ol>\n     *\n     * <p>Matching works left to right. Once a match is found the\n     * search starts again from the next character.</p>\n     *\n     * <p>If the same range is defined twice using the same syntax, only\n     * one range will be kept.\n     * Thus, \"a-ca-c\" creates only one range of \"a-c\".</p>\n     *\n     * <p>If the start and end of a range are in the wrong order,\n     * they are reversed. Thus \"a-e\" is the same as \"e-a\".\n     * As a result, \"a-ee-a\" would create only one range,\n     * as the \"a-e\" and \"e-a\" are the same.</p>\n     *\n     * <p>The set of characters represented is the union of the specified ranges.</p>\n     *\n     * <p>There are two ways to add a literal negation character ({@code ^}):</p>\n     * <ul>\n     *     <li>As the last character in a string, e.g. {@code CharSet.getInstance(\"a-z^\")}</li>\n     *     <li>As a separate element, e.g. {@code CharSet.getInstance(\"^\",\"a-z\")}</li>\n     * </ul>\n     *\n     * <p>Examples using the negation character:</p>\n     * <pre>\n     *     CharSet.getInstance(\"^a-c\").contains('a') = false\n     *     CharSet.getInstance(\"^a-c\").contains('d') = true\n     *     CharSet.getInstance(\"^^a-c\").contains('a') = true // (only '^' is negated)\n     *     CharSet.getInstance(\"^^a-c\").contains('^') = false\n     *     CharSet.getInstance(\"^a-cd-f\").contains('d') = true\n     *     CharSet.getInstance(\"a-c^\").contains('^') = true\n     *     CharSet.getInstance(\"^\", \"a-c\").contains('^') = true\n     * </pre>\n     *\n     * <p>All CharSet objects returned by this method will be immutable.</p>\n     *\n     * @param setStrs  Strings to merge into the set, may be null\n     * @return a CharSet instance\n     * @since 2.4\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static CharSet getInstance(final String... setStrs);",
      "Junit_version": "4",
      "returnType": "CharSet"
    },
    "Test_method": {
      "Method_body": "assertSame(CharSet.EMPTY, CharSet.getInstance((String) null));\n\rassertSame(CharSet.EMPTY, CharSet.getInstance(\"\"));\n\rassertSame(CharSet.ASCII_ALPHA, CharSet.getInstance(\"a-zA-Z\"));\n\rassertSame(CharSet.ASCII_ALPHA, CharSet.getInstance(\"A-Za-z\"));\n\rassertSame(CharSet.ASCII_ALPHA_LOWER, CharSet.getInstance(\"a-z\"));\n\rassertSame(CharSet.ASCII_ALPHA_UPPER, CharSet.getInstance(\"A-Z\"));\n\rassertSame(CharSet.ASCII_NUMERIC, CharSet.getInstance(\"0-9\"));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "7",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertSame;\n",
      "allMethod_info": "// -----------------------------------------------------------------------\n@Test\npublic void testGetInstance() {\n    assertSame(CharSet.EMPTY, CharSet.getInstance((String) null));\n    assertSame(CharSet.EMPTY, CharSet.getInstance(\"\"));\n    assertSame(CharSet.ASCII_ALPHA, CharSet.getInstance(\"a-zA-Z\"));\n    assertSame(CharSet.ASCII_ALPHA, CharSet.getInstance(\"A-Za-z\"));\n    assertSame(CharSet.ASCII_ALPHA_LOWER, CharSet.getInstance(\"a-z\"));\n    assertSame(CharSet.ASCII_ALPHA_UPPER, CharSet.getInstance(\"A-Z\"));\n    assertSame(CharSet.ASCII_NUMERIC, CharSet.getInstance(\"0-9\"));\n}",
      "Method_name": "testGetInstance",
      "Class_declaration": "public class CharSetTest {\n",
      "constructors": "",
      "Class_name": "CharSetTest",
      "methodName_paraNum": "[getInstance(1), getInstance(1), getInstance(1), getInstance(1), getInstance(1), getInstance(1), getInstance(1)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/CharSetTest###testGetInstance",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/CharSetTest.java",
      "Signature": "public void testGetInstance() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNull;\n\nimport static org.junit.Assert.assertSame;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.lang.reflect.Modifier;\n\nimport org.junit.Test;\n",
      "comment": "-----------------------------------------------------------------------",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public long setSize(long size) throws IOException {\n    final long nrClusters = ((size + clusterSize - 1) / clusterSize);\n    if (nrClusters > Integer.MAX_VALUE)\n        throw new IOException(\"too many clusters\");\n    setChainLength((int) nrClusters);\n    return clusterSize * nrClusters;\n}",
      "all_field_declaration": "private final Fat fat;\nprivate final BlockDevice device;\nprivate final int clusterSize;\nprivate final long dataOffset;\nprivate long startCluster;",
      "sub_project_name": "waldheinz_fat32-lib",
      "lineNumbers": "4",
      "Filed": "private final int clusterSize;",
      "Parameter_type": "long",
      "Import_statements": "import java.io.IOException;\n",
      "public_method_signature": "public ClusterChain(Fat fat, boolean readOnly);\npublic ClusterChain(Fat fat, long startCluster, boolean readOnly);\npublic int getClusterSize();\npublic Fat getFat();\npublic BlockDevice getDevice();\npublic long getStartCluster();\npublic long getLengthOnDisk();\npublic long setSize(long size) throws IOException;\npublic int getChainLength();\npublic void setChainLength(int nrClusters) throws IOException;\npublic void readData(long offset, ByteBuffer dest) throws IOException;\npublic void writeData(long offset, ByteBuffer srcBuf) throws IOException;\npublic boolean equals(Object obj);\npublic int hashCode();",
      "public_field": "",
      "Method_statement": "setSize(long size)",
      "Method_name": "setSize",
      "Class_declaration": "final class ClusterChain {\n",
      "constructors": "public ClusterChain(Fat fat, boolean readOnly) {\n    this(fat, 0, readOnly);\n}public ClusterChain(Fat fat, long startCluster, boolean readOnly) {\n    super(readOnly);\n    this.fat = fat;\n    if (startCluster != 0) {\n        this.fat.testCluster(startCluster);\n        if (this.fat.isFreeCluster(startCluster))\n            throw new IllegalArgumentException(\"cluster \" + startCluster + \" is free\");\n    }\n    this.device = fat.getDevice();\n    this.dataOffset = fat.getBootSector().getFilesOffset();\n    this.startCluster = startCluster;\n    this.clusterSize = fat.getBootSector().getBytesPerCluster();\n}",
      "all_method_signature": "public ClusterChain(Fat fat, boolean readOnly);\npublic ClusterChain(Fat fat, long startCluster, boolean readOnly);\npublic int getClusterSize();\npublic Fat getFat();\npublic BlockDevice getDevice();\npublic long getStartCluster();\nprivate long getDevOffset(long cluster, int clusterOffset);\npublic long getLengthOnDisk();\npublic long setSize(long size) throws IOException;\npublic int getChainLength();\npublic void setChainLength(int nrClusters) throws IOException;\npublic void readData(long offset, ByteBuffer dest) throws IOException;\npublic void writeData(long offset, ByteBuffer srcBuf) throws IOException;\npublic boolean equals(Object obj);\npublic int hashCode();",
      "Class_name": "ClusterChain",
      "project_path": "waldheinz_fat32-lib###waldheinz_fat32-lib/src/main/java/de/waldheinz/fs/fat/ClusterChain###setSize",
      "Parameter_num": "1",
      "all_Import_statements": "import de.waldheinz.fs.AbstractFsObject;\n\nimport de.waldheinz.fs.BlockDevice;\n\nimport java.io.EOFException;\n\nimport java.io.IOException;\n\nimport java.nio.ByteBuffer;\n",
      "comment": "\n     * Sets the length of this {@code ClusterChain} in bytes. Because a\n     * {@code ClusterChain} can only contain full clusters, the new size\n     * will always be a multiple of the cluster size.\n     *\n     * @param size the desired number of bytes the can be stored in\n     *      this {@code ClusterChain}\n     * @return the true number of bytes this {@code ClusterChain} can contain\n     * @throws IOException on error setting the new size\n     * @see #setChainLength(int) \n     ",
      "packageName": "de.waldheinz.fs.fat",
      "method_signature": "public long setSize(long size) throws IOException;",
      "Junit_version": "4",
      "returnType": "long"
    },
    "Test_method": {
      "Method_body": "System.out.println(\"setSize\");\n\rcc.setSize(bs.getBytesPerCluster());\n\rassertEquals(1, cc.getChainLength());\n\rcc.setSize(bs.getBytesPerCluster() + 1);\n\rassertEquals(2, cc.getChainLength());\n\rcc.setSize(0);\n\rassertEquals(0, cc.getChainLength());\n\rcc.setSize(1);\n\rassertEquals(1, cc.getChainLength());",
      "sub_project_name": "waldheinz_fat32-lib",
      "lineNumbers": "9",
      "Filed": "private ClusterChain cc;private BootSector bs;",
      "Import_statements": "",
      "allMethod_info": "@Test\npublic void testSetSize() throws IOException {\n    System.out.println(\"setSize\");\n    cc.setSize(bs.getBytesPerCluster());\n    assertEquals(1, cc.getChainLength());\n    cc.setSize(bs.getBytesPerCluster() + 1);\n    assertEquals(2, cc.getChainLength());\n    cc.setSize(0);\n    assertEquals(0, cc.getChainLength());\n    cc.setSize(1);\n    assertEquals(1, cc.getChainLength());\n}",
      "Method_name": "testSetSize",
      "Class_declaration": "public class ClusterChainTest {\n",
      "constructors": "",
      "Class_name": "ClusterChainTest",
      "methodName_paraNum": "[println(1), setSize(1), getBytesPerCluster(0), getChainLength(0), setSize(1), getBytesPerCluster(0), getChainLength(0), setSize(1), getChainLength(0), setSize(1), getChainLength(0)]",
      "project_path": "waldheinz_fat32-lib###waldheinz_fat32-lib/src/test/java/de/waldheinz/fs/fat/ClusterChainTest###testSetSize",
      "relativePath": "waldheinz_fat32-lib/src/test/java/de/waldheinz/fs/fat/ClusterChainTest.java",
      "Signature": "public void testSetSize() {\n",
      "all_Import_statements": "import de.waldheinz.fs.util.RamDisk;\n\nimport java.io.IOException;\n\nimport java.nio.ByteBuffer;\n\nimport org.junit.Before;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.*;\n",
      "comment": "",
      "packageName": "de.waldheinz.fs.fat",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "void checkFailed() {\n    if (!failed.compareAndSet(false, true)) {\n        return;\n    }\n    for (final Stage<?> source : sources) {\n        source.cancel();\n    }\n    sources = null;\n}",
      "all_field_declaration": "static final byte COMPLETED = 0x1;\nstatic final byte FAILED = 0x2;\nstatic final byte CANCELLED = 0x3;\nfinal int size;\nfinal Function<? super Collection<T>, ? extends U> collector;\n/**\n * A collection of all source stages.\n */\nCollection<? extends Stage<?>> sources;\nfinal Completable<? super U> target;\n/**\n * The collected results, non-final to allow for setting to null. Allows for random writes\n * since final size is known at initialization.\n */\nObject[] values;\n/**\n * Flags for all collected states.\n */\nbyte[] states;\n/**\n * maintain position separate since the is a potential race condition between getting the\n * current position and setting the entry. This is avoided by only relying on countdown to trigger\n * when we are done.\n */\nfinal AtomicInteger write;\n/**\n * Maintain a separate countdown since the write position might be out of order, this causes all\n * threads to synchronize after the write\n */\nfinal AtomicInteger countdown;\n/**\n * State of the collector.\n */\nfinal AtomicBoolean failed;\nfinal AtomicBoolean done;",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "3",
      "Filed": "Collection<? extends Stage<?>> sources;final AtomicBoolean failed;",
      "Parameter_type": "",
      "Import_statements": "",
      "public_method_signature": "public void completed(T result);\npublic void failed(Throwable e);\npublic void cancelled();",
      "public_field": "",
      "Method_statement": "checkFailed()",
      "Method_name": "checkFailed",
      "Class_declaration": "class CollectHelper {\n",
      "constructors": "CollectHelper(int size, Function<? super Collection<T>, ? extends U> collector, Collection<? extends Stage<?>> sources, Completable<? super U> target) {\n    if (size <= 0) {\n        throw new IllegalArgumentException(\"size\");\n    }\n    this.size = size;\n    this.collector = collector;\n    this.sources = sources;\n    this.target = target;\n    this.values = new Object[size];\n    this.states = new byte[size];\n    this.write = new AtomicInteger();\n    this.countdown = new AtomicInteger(size);\n    this.failed = new AtomicBoolean();\n    this.done = new AtomicBoolean();\n}",
      "all_method_signature": " CollectHelper(int size, Function<? super Collection<T>, ? extends U> collector, Collection<? extends Stage<?>> sources, Completable<? super U> target);\npublic void completed(T result);\npublic void failed(Throwable e);\npublic void cancelled();\n void checkFailed();\n void add(final byte type, final Object value);\n void writeAt(final int w, final byte state, final Object value);\n void done(Results r);\n Results collect();",
      "Class_name": "CollectHelper",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/main/java/eu/toolchain/concurrent/CollectHelper###checkFailed",
      "Parameter_num": "0",
      "all_Import_statements": "import static eu.toolchain.concurrent.CoreAsync.buildCollectedException;\n\nimport java.util.ArrayList;\n\nimport java.util.Collection;\n\nimport java.util.List;\n\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport java.util.function.Function;\n\nimport lombok.RequiredArgsConstructor;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "method_signature": " void checkFailed();",
      "Junit_version": "4",
      "returnType": "void"
    },
    "Test_method": {
      "Method_body": "final Iterator<Stage<?>> futures = ImmutableList.<Stage<?>>of(f1, f2).iterator();\n\rdoReturn(futures).when(sources).iterator();\n\rassertEquals(false, helper.failed.get());\n\rassertEquals(false, helper.done.get());\n\rassertNotNull(helper.sources);\n\rhelper.checkFailed();\n\rassertEquals(true, helper.failed.get());\n\rassertEquals(false, helper.done.get());\n\rassertNull(helper.sources);\n\rverify(f1, times(1)).cancel();\n\rverify(f2, times(1)).cancel();\n\r// should only fail once\nhelper.checkFailed();\n\rassertEquals(true, helper.failed.get());\n\rassertEquals(false, helper.done.get());\n\rassertNull(helper.sources);\n\rverify(f1, times(1)).cancel();\n\rverify(f2, times(1)).cancel();",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "17",
      "Filed": "@Mock\nprivate List<Stage<From>> sources;@Mock\nprivate Throwable e;@Mock\nprivate Stage<From> f1;@Mock\nprivate Stage<From> f2;private CollectHelper<From, To> helper;",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport com.google.common.collect.ImmutableList;\nimport java.util.Iterator;\nimport java.util.List;\n",
      "allMethod_info": "@Test\npublic void testCheckFailed() {\n    final Iterator<Stage<?>> futures = ImmutableList.<Stage<?>>of(f1, f2).iterator();\n    doReturn(futures).when(sources).iterator();\n    assertEquals(false, helper.failed.get());\n    assertEquals(false, helper.done.get());\n    assertNotNull(helper.sources);\n    helper.checkFailed();\n    assertEquals(true, helper.failed.get());\n    assertEquals(false, helper.done.get());\n    assertNull(helper.sources);\n    verify(f1, times(1)).cancel();\n    verify(f2, times(1)).cancel();\n    // should only fail once\n    helper.checkFailed();\n    assertEquals(true, helper.failed.get());\n    assertEquals(false, helper.done.get());\n    assertNull(helper.sources);\n    verify(f1, times(1)).cancel();\n    verify(f2, times(1)).cancel();\n}",
      "Method_name": "testCheckFailed",
      "Class_declaration": "public class CollectHelperTest {\n",
      "constructors": "",
      "Class_name": "CollectHelperTest",
      "methodName_paraNum": "[iterator(0), of(2), iterator(0), when(1), doReturn(1), get(0), get(0), checkFailed(0), get(0), get(0), cancel(0), verify(2), times(1), cancel(0), verify(2), times(1), checkFailed(0), get(0), get(0), cancel(0), verify(2), times(1), cancel(0), verify(2), times(1)]",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/CollectHelperTest###testCheckFailed",
      "relativePath": "udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/CollectHelperTest.java",
      "Signature": "public void testCheckFailed() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertNull;\n\nimport static org.mockito.Matchers.any;\n\nimport static org.mockito.Matchers.anyObject;\n\nimport static org.mockito.Mockito.doNothing;\n\nimport static org.mockito.Mockito.doReturn;\n\nimport static org.mockito.Mockito.mock;\n\nimport static org.mockito.Mockito.spy;\n\nimport static org.mockito.Mockito.times;\n\nimport static org.mockito.Mockito.verify;\n\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.Collection;\n\nimport java.util.Iterator;\n\nimport java.util.List;\n\nimport java.util.function.Function;\n\nimport org.junit.Before;\n\nimport org.junit.Test;\n\nimport org.junit.runner.RunWith;\n\nimport org.mockito.Mock;\n\nimport org.mockito.runners.MockitoJUnitRunner;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public CompareToBuilder appendSuper(final int superCompareTo) {\n    if (comparison != 0) {\n        return this;\n    }\n    comparison = superCompareTo;\n    return this;\n}",
      "all_field_declaration": "/**\n * Current state of the comparison as appended fields are checked.\n */\nprivate int comparison;",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "3",
      "Filed": "private int comparison;",
      "Parameter_type": "int",
      "Import_statements": "",
      "public_method_signature": "public CompareToBuilder();\npublic static int reflectionCompare(final Object lhs, final Object rhs);\npublic static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients);\npublic static int reflectionCompare(final Object lhs, final Object rhs, final Collection<String> excludeFields);\npublic static int reflectionCompare(final Object lhs, final Object rhs, final String... excludeFields);\npublic static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields);\npublic CompareToBuilder appendSuper(final int superCompareTo);\npublic CompareToBuilder append(final Object lhs, final Object rhs);\npublic CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator);\npublic CompareToBuilder append(final long lhs, final long rhs);\npublic CompareToBuilder append(final int lhs, final int rhs);\npublic CompareToBuilder append(final short lhs, final short rhs);\npublic CompareToBuilder append(final char lhs, final char rhs);\npublic CompareToBuilder append(final byte lhs, final byte rhs);\npublic CompareToBuilder append(final double lhs, final double rhs);\npublic CompareToBuilder append(final float lhs, final float rhs);\npublic CompareToBuilder append(final boolean lhs, final boolean rhs);\npublic CompareToBuilder append(final Object[] lhs, final Object[] rhs);\npublic CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator);\npublic CompareToBuilder append(final long[] lhs, final long[] rhs);\npublic CompareToBuilder append(final int[] lhs, final int[] rhs);\npublic CompareToBuilder append(final short[] lhs, final short[] rhs);\npublic CompareToBuilder append(final char[] lhs, final char[] rhs);\npublic CompareToBuilder append(final byte[] lhs, final byte[] rhs);\npublic CompareToBuilder append(final double[] lhs, final double[] rhs);\npublic CompareToBuilder append(final float[] lhs, final float[] rhs);\npublic CompareToBuilder append(final boolean[] lhs, final boolean[] rhs);\npublic int toComparison();\npublic Integer build();",
      "public_field": "",
      "Method_statement": "appendSuper(final int superCompareTo)",
      "Method_name": "appendSuper",
      "Class_declaration": "public class CompareToBuilder {\n",
      "constructors": "public CompareToBuilder() {\n    super();\n    comparison = 0;\n}",
      "all_method_signature": "public CompareToBuilder();\npublic static int reflectionCompare(final Object lhs, final Object rhs);\npublic static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients);\npublic static int reflectionCompare(final Object lhs, final Object rhs, final Collection<String> excludeFields);\npublic static int reflectionCompare(final Object lhs, final Object rhs, final String... excludeFields);\npublic static int reflectionCompare(final Object lhs, final Object rhs, final boolean compareTransients, final Class<?> reflectUpToClass, final String... excludeFields);\nprivate static void reflectionAppend(final Object lhs, final Object rhs, final Class<?> clazz, final CompareToBuilder builder, final boolean useTransients, final String[] excludeFields);\npublic CompareToBuilder appendSuper(final int superCompareTo);\npublic CompareToBuilder append(final Object lhs, final Object rhs);\npublic CompareToBuilder append(final Object lhs, final Object rhs, final Comparator<?> comparator);\nprivate void appendArray(final Object lhs, final Object rhs, final Comparator<?> comparator);\npublic CompareToBuilder append(final long lhs, final long rhs);\npublic CompareToBuilder append(final int lhs, final int rhs);\npublic CompareToBuilder append(final short lhs, final short rhs);\npublic CompareToBuilder append(final char lhs, final char rhs);\npublic CompareToBuilder append(final byte lhs, final byte rhs);\npublic CompareToBuilder append(final double lhs, final double rhs);\npublic CompareToBuilder append(final float lhs, final float rhs);\npublic CompareToBuilder append(final boolean lhs, final boolean rhs);\npublic CompareToBuilder append(final Object[] lhs, final Object[] rhs);\npublic CompareToBuilder append(final Object[] lhs, final Object[] rhs, final Comparator<?> comparator);\npublic CompareToBuilder append(final long[] lhs, final long[] rhs);\npublic CompareToBuilder append(final int[] lhs, final int[] rhs);\npublic CompareToBuilder append(final short[] lhs, final short[] rhs);\npublic CompareToBuilder append(final char[] lhs, final char[] rhs);\npublic CompareToBuilder append(final byte[] lhs, final byte[] rhs);\npublic CompareToBuilder append(final double[] lhs, final double[] rhs);\npublic CompareToBuilder append(final float[] lhs, final float[] rhs);\npublic CompareToBuilder append(final boolean[] lhs, final boolean[] rhs);\npublic int toComparison();\npublic Integer build();",
      "Class_name": "CompareToBuilder",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/builder/CompareToBuilder###appendSuper",
      "Parameter_num": "1",
      "all_Import_statements": "import java.lang.reflect.AccessibleObject;\n\nimport java.lang.reflect.Field;\n\nimport java.lang.reflect.Modifier;\n\nimport java.util.Collection;\n\nimport java.util.Comparator;\n\nimport org.apache.commons.lang3.ArrayUtils;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>Appends to the <code>builder</code> the <code>compareTo(Object)</code>\n     * result of the superclass.</p>\n     *\n     * @param superCompareTo  result of calling <code>super.compareTo(Object)</code>\n     * @return this - used to chain append calls\n     * @since 2.0\n     ",
      "packageName": "org.apache.commons.lang3.builder",
      "method_signature": "public CompareToBuilder appendSuper(final int superCompareTo);",
      "Junit_version": "4",
      "returnType": "CompareToBuilder"
    },
    "Test_method": {
      "Method_body": "final TestObject o1 = new TestObject(4);\n\rfinal TestObject o2 = new TestObject(5);\n\rassertTrue(new CompareToBuilder().appendSuper(0).append(o1, o1).toComparison() == 0);\n\rassertTrue(new CompareToBuilder().appendSuper(0).append(o1, o2).toComparison() < 0);\n\rassertTrue(new CompareToBuilder().appendSuper(0).append(o2, o1).toComparison() > 0);\n\rassertTrue(new CompareToBuilder().appendSuper(-1).append(o1, o1).toComparison() < 0);\n\rassertTrue(new CompareToBuilder().appendSuper(-1).append(o1, o2).toComparison() < 0);\n\rassertTrue(new CompareToBuilder().appendSuper(1).append(o1, o1).toComparison() > 0);\n\rassertTrue(new CompareToBuilder().appendSuper(1).append(o1, o2).toComparison() > 0);",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "9",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertTrue;\nimport org.junit.Test;\n",
      "allMethod_info": "@Test\npublic void testAppendSuper() {\n    final TestObject o1 = new TestObject(4);\n    final TestObject o2 = new TestObject(5);\n    assertTrue(new CompareToBuilder().appendSuper(0).append(o1, o1).toComparison() == 0);\n    assertTrue(new CompareToBuilder().appendSuper(0).append(o1, o2).toComparison() < 0);\n    assertTrue(new CompareToBuilder().appendSuper(0).append(o2, o1).toComparison() > 0);\n    assertTrue(new CompareToBuilder().appendSuper(-1).append(o1, o1).toComparison() < 0);\n    assertTrue(new CompareToBuilder().appendSuper(-1).append(o1, o2).toComparison() < 0);\n    assertTrue(new CompareToBuilder().appendSuper(1).append(o1, o1).toComparison() > 0);\n    assertTrue(new CompareToBuilder().appendSuper(1).append(o1, o2).toComparison() > 0);\n}",
      "Method_name": "testAppendSuper",
      "Class_declaration": "public class CompareToBuilderTest {\n",
      "constructors": "",
      "Class_name": "CompareToBuilderTest",
      "methodName_paraNum": "[toComparison(0), append(2), appendSuper(1), toComparison(0), append(2), appendSuper(1), toComparison(0), append(2), appendSuper(1), toComparison(0), append(2), appendSuper(1), toComparison(0), append(2), appendSuper(1), toComparison(0), append(2), appendSuper(1), toComparison(0), append(2), appendSuper(1)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/builder/CompareToBuilderTest###testAppendSuper",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/builder/CompareToBuilderTest.java",
      "Signature": "public void testAppendSuper() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.math.BigInteger;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3.builder",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic boolean cancel() {\n    if (!state.compareAndSet(PENDING, CANCELLED)) {\n        return false;\n    }\n    this.result = CANCEL;\n    postComplete();\n    return true;\n}",
      "all_field_declaration": "/**\n * the max number of spins allowed before {@link Thread#yield()}\n */\nstatic final int MAX_SPINS = 4;\n/**\n * Possible states of the completable. A state being set <em>does not</em> indicate that the\n * completable is no longer running, but must always be checked in concert with a {@code result !=\n * null}.\n */\nstatic final int PENDING = 0;\nstatic final int COMPLETED = 1;\nstatic final int FAILED = 2;\nstatic final int CANCELLED = 3;\n/**\n * Indicates a result containing {@code null}.\n */\nstatic final Object NULL = new Object();\nstatic final Object CANCEL = new Object();\n/**\n * pair to CAS into callbacks when done\n */\nstatic final RunnablePair END = new RunnablePair(null, null);\nprivate final Caller caller;\n/**\n * Current state of the completable.\n */\nfinal AtomicInteger state = new AtomicInteger();\n/**\n * Result of the completable.\n * Never stored null, but uses {@link #NULL} as a surrogate instead.\n */\nvolatile Object result = null;\n/**\n * a linked list of callbacks to execute\n */\nfinal AtomicReference<RunnablePair> callbacks;",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "4",
      "Filed": "static final int PENDING = 0;static final int CANCELLED = 3;static final Object CANCEL = new Object();static final RunnablePair END = new RunnablePair(null, null);final AtomicInteger state = new AtomicInteger();volatile Object result = null;",
      "Parameter_type": "",
      "Import_statements": "",
      "public_method_signature": "public ConcurrentCompletable(final Caller caller);\npublic void completed(final T result);\npublic void failed(final Throwable cause);\npublic void cancelled();\npublic boolean complete(final T result);\npublic boolean fail(final Throwable cause);\npublic boolean cancel();\npublic Stage<T> handle(final Handle<? super T> handle);\npublic Stage<T> whenDone(final Runnable finishable);\npublic Stage<T> whenComplete(final Consumer<? super T> consumer);\npublic Stage<T> whenFailed(final Consumer<? super Throwable> consumer);\npublic Stage<T> whenCancelled(final Runnable cancelled);\npublic boolean isDone();\npublic boolean isCompleted();\npublic boolean isFailed();\npublic boolean isCancelled();\npublic Throwable cause();\npublic T join() throws InterruptedException, ExecutionException;\npublic T joinNow() throws ExecutionException;\npublic T join(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;\npublic Stage<U> thenApply(Function<? super T, ? extends U> fn);\npublic Stage<U> thenCompose(final Function<? super T, ? extends Stage<U>> fn);\npublic Stage<T> thenApplyFailed(final Function<? super Throwable, ? extends T> fn);\npublic Stage<T> thenComposeCaught(final Function<? super Throwable, ? extends Stage<T>> fn);\npublic Stage<T> withCloser(final Supplier<? extends Stage<Void>> complete, final Supplier<? extends Stage<Void>> notComplete);\npublic Stage<T> withComplete(final Supplier<? extends Stage<Void>> supplier);\npublic Stage<T> withNotComplete(final Supplier<? extends Stage<Void>> supplier);\npublic Stage<U> thenFail(final Throwable cause);\npublic Stage<U> thenComplete(final U result);\npublic Stage<U> thenCancel();\npublic String toString();",
      "public_field": "",
      "Method_statement": "cancel()",
      "Method_name": "cancel",
      "Class_declaration": "public class ConcurrentCompletable {\n",
      "constructors": "public ConcurrentCompletable(final Caller caller) {\n    super(caller);\n    this.caller = caller;\n    this.callbacks = new AtomicReference<>();\n}ConcurrentCompletable(final Caller caller, final Runnable runnable) {\n    super(caller);\n    this.caller = caller;\n    this.callbacks = new AtomicReference<>(new RunnablePair(runnable, null));\n}",
      "all_method_signature": "public ConcurrentCompletable(final Caller caller);\n ConcurrentCompletable(final Caller caller, final Runnable runnable);\npublic void completed(final T result);\npublic void failed(final Throwable cause);\npublic void cancelled();\npublic boolean complete(final T result);\npublic boolean fail(final Throwable cause);\npublic boolean cancel();\npublic Stage<T> handle(final Handle<? super T> handle);\npublic Stage<T> whenDone(final Runnable finishable);\npublic Stage<T> whenComplete(final Consumer<? super T> consumer);\npublic Stage<T> whenFailed(final Consumer<? super Throwable> consumer);\npublic Stage<T> whenCancelled(final Runnable cancelled);\npublic boolean isDone();\npublic boolean isCompleted();\npublic boolean isFailed();\npublic boolean isCancelled();\npublic Throwable cause();\npublic T join() throws InterruptedException, ExecutionException;\npublic T joinNow() throws ExecutionException;\npublic T join(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;\npublic Stage<U> thenApply(Function<? super T, ? extends U> fn);\npublic Stage<U> thenCompose(final Function<? super T, ? extends Stage<U>> fn);\npublic Stage<T> thenApplyFailed(final Function<? super Throwable, ? extends T> fn);\npublic Stage<T> thenComposeCaught(final Function<? super Throwable, ? extends Stage<T>> fn);\npublic Stage<T> withCloser(final Supplier<? extends Stage<Void>> complete, final Supplier<? extends Stage<Void>> notComplete);\npublic Stage<T> withComplete(final Supplier<? extends Stage<Void>> supplier);\npublic Stage<T> withNotComplete(final Supplier<? extends Stage<Void>> supplier);\npublic Stage<U> thenFail(final Throwable cause);\npublic Stage<U> thenComplete(final U result);\npublic Stage<U> thenCancel();\n ConcurrentCompletable<U> nextStage();\n void postComplete();\n RunnablePair takeAndClear();\n boolean add(Runnable runnable);\n T doJoin() throws ExecutionException;\npublic String toString();\n T result(final Object r);\n static Throwable throwable(final Object r);\n void handleStage(final Supplier<? extends Stage<U>> supplier, final ConcurrentCompletable<U> target);",
      "Class_name": "ConcurrentCompletable",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/main/java/eu/toolchain/concurrent/ConcurrentCompletable###cancel",
      "Parameter_num": "0",
      "all_Import_statements": "import java.text.MessageFormat;\n\nimport java.util.concurrent.CancellationException;\n\nimport java.util.concurrent.ExecutionException;\n\nimport java.util.concurrent.TimeUnit;\n\nimport java.util.concurrent.TimeoutException;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport java.util.concurrent.locks.LockSupport;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport lombok.AllArgsConstructor;\n\nimport lombok.RequiredArgsConstructor;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "method_signature": "public boolean cancel();",
      "Junit_version": "4",
      "returnType": "boolean"
    },
    "Test_method": {
      "Method_body": "assertEquals(ConcurrentCompletable.PENDING, c.completable.state.get());\n\rassertTrue(c.completable.cancel());\n\rassertEquals(ConcurrentCompletable.CANCELLED, c.completable.state.get());\n\rassertEquals(ConcurrentCompletable.CANCEL, c.completable.result);\n\rverifyFinalized();",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "5",
      "Filed": "@Mock\nprivate From result;private Completable c;",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.mockito.Mockito.verify;\n",
      "allMethod_info": "@Test\npublic void testCancel() {\n    assertEquals(ConcurrentCompletable.PENDING, c.completable.state.get());\n    assertTrue(c.completable.cancel());\n    assertEquals(ConcurrentCompletable.CANCELLED, c.completable.state.get());\n    assertEquals(ConcurrentCompletable.CANCEL, c.completable.result);\n    verifyFinalized();\n}",
      "Method_name": "testCancel",
      "Class_declaration": "public class ConcurrentCompletableTest {\n",
      "constructors": "",
      "Class_name": "ConcurrentCompletableTest",
      "methodName_paraNum": "[get(0), cancel(0), get(0), verifyFinalized(0)]",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/ConcurrentCompletableTest###testCancel",
      "relativePath": "udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/ConcurrentCompletableTest.java",
      "Signature": "public void testCancel() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.mockito.Matchers.any;\n\nimport static org.mockito.Matchers.eq;\n\nimport static org.mockito.Mockito.doNothing;\n\nimport static org.mockito.Mockito.doReturn;\n\nimport static org.mockito.Mockito.doThrow;\n\nimport static org.mockito.Mockito.inOrder;\n\nimport static org.mockito.Mockito.mock;\n\nimport static org.mockito.Mockito.times;\n\nimport static org.mockito.Mockito.verify;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport org.junit.Before;\n\nimport org.junit.Rule;\n\nimport org.junit.Test;\n\nimport org.junit.rules.ExpectedException;\n\nimport org.junit.runner.RunWith;\n\nimport org.mockito.ArgumentCaptor;\n\nimport org.mockito.InOrder;\n\nimport org.mockito.Mock;\n\nimport org.mockito.Mockito;\n\nimport org.mockito.runners.MockitoJUnitRunner;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic boolean complete(final T result) {\n    if (!state.compareAndSet(PENDING, COMPLETED)) {\n        return false;\n    }\n    this.result = (result == null ? NULL : result);\n    postComplete();\n    return true;\n}",
      "all_field_declaration": "/**\n * the max number of spins allowed before {@link Thread#yield()}\n */\nstatic final int MAX_SPINS = 4;\n/**\n * Possible states of the completable. A state being set <em>does not</em> indicate that the\n * completable is no longer running, but must always be checked in concert with a {@code result !=\n * null}.\n */\nstatic final int PENDING = 0;\nstatic final int COMPLETED = 1;\nstatic final int FAILED = 2;\nstatic final int CANCELLED = 3;\n/**\n * Indicates a result containing {@code null}.\n */\nstatic final Object NULL = new Object();\nstatic final Object CANCEL = new Object();\n/**\n * pair to CAS into callbacks when done\n */\nstatic final RunnablePair END = new RunnablePair(null, null);\nprivate final Caller caller;\n/**\n * Current state of the completable.\n */\nfinal AtomicInteger state = new AtomicInteger();\n/**\n * Result of the completable.\n * Never stored null, but uses {@link #NULL} as a surrogate instead.\n */\nvolatile Object result = null;\n/**\n * a linked list of callbacks to execute\n */\nfinal AtomicReference<RunnablePair> callbacks;",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "4",
      "Filed": "static final int PENDING = 0;static final int COMPLETED = 1;static final Object NULL = new Object();static final RunnablePair END = new RunnablePair(null, null);final AtomicInteger state = new AtomicInteger();volatile Object result = null;",
      "Parameter_type": "T",
      "Import_statements": "",
      "public_method_signature": "public ConcurrentCompletable(final Caller caller);\npublic void completed(final T result);\npublic void failed(final Throwable cause);\npublic void cancelled();\npublic boolean complete(final T result);\npublic boolean fail(final Throwable cause);\npublic boolean cancel();\npublic Stage<T> handle(final Handle<? super T> handle);\npublic Stage<T> whenDone(final Runnable finishable);\npublic Stage<T> whenComplete(final Consumer<? super T> consumer);\npublic Stage<T> whenFailed(final Consumer<? super Throwable> consumer);\npublic Stage<T> whenCancelled(final Runnable cancelled);\npublic boolean isDone();\npublic boolean isCompleted();\npublic boolean isFailed();\npublic boolean isCancelled();\npublic Throwable cause();\npublic T join() throws InterruptedException, ExecutionException;\npublic T joinNow() throws ExecutionException;\npublic T join(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;\npublic Stage<U> thenApply(Function<? super T, ? extends U> fn);\npublic Stage<U> thenCompose(final Function<? super T, ? extends Stage<U>> fn);\npublic Stage<T> thenApplyFailed(final Function<? super Throwable, ? extends T> fn);\npublic Stage<T> thenComposeCaught(final Function<? super Throwable, ? extends Stage<T>> fn);\npublic Stage<T> withCloser(final Supplier<? extends Stage<Void>> complete, final Supplier<? extends Stage<Void>> notComplete);\npublic Stage<T> withComplete(final Supplier<? extends Stage<Void>> supplier);\npublic Stage<T> withNotComplete(final Supplier<? extends Stage<Void>> supplier);\npublic Stage<U> thenFail(final Throwable cause);\npublic Stage<U> thenComplete(final U result);\npublic Stage<U> thenCancel();\npublic String toString();",
      "public_field": "",
      "Method_statement": "complete(final T result)",
      "Method_name": "complete",
      "Class_declaration": "public class ConcurrentCompletable {\n",
      "constructors": "public ConcurrentCompletable(final Caller caller) {\n    super(caller);\n    this.caller = caller;\n    this.callbacks = new AtomicReference<>();\n}ConcurrentCompletable(final Caller caller, final Runnable runnable) {\n    super(caller);\n    this.caller = caller;\n    this.callbacks = new AtomicReference<>(new RunnablePair(runnable, null));\n}",
      "all_method_signature": "public ConcurrentCompletable(final Caller caller);\n ConcurrentCompletable(final Caller caller, final Runnable runnable);\npublic void completed(final T result);\npublic void failed(final Throwable cause);\npublic void cancelled();\npublic boolean complete(final T result);\npublic boolean fail(final Throwable cause);\npublic boolean cancel();\npublic Stage<T> handle(final Handle<? super T> handle);\npublic Stage<T> whenDone(final Runnable finishable);\npublic Stage<T> whenComplete(final Consumer<? super T> consumer);\npublic Stage<T> whenFailed(final Consumer<? super Throwable> consumer);\npublic Stage<T> whenCancelled(final Runnable cancelled);\npublic boolean isDone();\npublic boolean isCompleted();\npublic boolean isFailed();\npublic boolean isCancelled();\npublic Throwable cause();\npublic T join() throws InterruptedException, ExecutionException;\npublic T joinNow() throws ExecutionException;\npublic T join(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;\npublic Stage<U> thenApply(Function<? super T, ? extends U> fn);\npublic Stage<U> thenCompose(final Function<? super T, ? extends Stage<U>> fn);\npublic Stage<T> thenApplyFailed(final Function<? super Throwable, ? extends T> fn);\npublic Stage<T> thenComposeCaught(final Function<? super Throwable, ? extends Stage<T>> fn);\npublic Stage<T> withCloser(final Supplier<? extends Stage<Void>> complete, final Supplier<? extends Stage<Void>> notComplete);\npublic Stage<T> withComplete(final Supplier<? extends Stage<Void>> supplier);\npublic Stage<T> withNotComplete(final Supplier<? extends Stage<Void>> supplier);\npublic Stage<U> thenFail(final Throwable cause);\npublic Stage<U> thenComplete(final U result);\npublic Stage<U> thenCancel();\n ConcurrentCompletable<U> nextStage();\n void postComplete();\n RunnablePair takeAndClear();\n boolean add(Runnable runnable);\n T doJoin() throws ExecutionException;\npublic String toString();\n T result(final Object r);\n static Throwable throwable(final Object r);\n void handleStage(final Supplier<? extends Stage<U>> supplier, final ConcurrentCompletable<U> target);",
      "Class_name": "ConcurrentCompletable",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/main/java/eu/toolchain/concurrent/ConcurrentCompletable###complete",
      "Parameter_num": "1",
      "all_Import_statements": "import java.text.MessageFormat;\n\nimport java.util.concurrent.CancellationException;\n\nimport java.util.concurrent.ExecutionException;\n\nimport java.util.concurrent.TimeUnit;\n\nimport java.util.concurrent.TimeoutException;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport java.util.concurrent.locks.LockSupport;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport lombok.AllArgsConstructor;\n\nimport lombok.RequiredArgsConstructor;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "method_signature": "public boolean complete(final T result);",
      "Junit_version": "4",
      "returnType": "boolean"
    },
    "Test_method": {
      "Method_body": "assertEquals(ConcurrentCompletable.PENDING, c.completable.state.get());\n\rassertTrue(c.completable.complete(result));\n\rassertEquals(ConcurrentCompletable.COMPLETED, c.completable.state.get());\n\rassertEquals(result, c.completable.result);\n\rverifyFinalized();",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "5",
      "Filed": "@Mock\nprivate From result;private Completable c;",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\nimport static org.mockito.Mockito.verify;\n",
      "allMethod_info": "@Test\npublic void testComplete() {\n    assertEquals(ConcurrentCompletable.PENDING, c.completable.state.get());\n    assertTrue(c.completable.complete(result));\n    assertEquals(ConcurrentCompletable.COMPLETED, c.completable.state.get());\n    assertEquals(result, c.completable.result);\n    verifyFinalized();\n}",
      "Method_name": "testComplete",
      "Class_declaration": "public class ConcurrentCompletableTest {\n",
      "constructors": "",
      "Class_name": "ConcurrentCompletableTest",
      "methodName_paraNum": "[get(0), complete(1), get(0), verifyFinalized(0)]",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/ConcurrentCompletableTest###testComplete",
      "relativePath": "udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/ConcurrentCompletableTest.java",
      "Signature": "public void testComplete() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.mockito.Matchers.any;\n\nimport static org.mockito.Matchers.eq;\n\nimport static org.mockito.Mockito.doNothing;\n\nimport static org.mockito.Mockito.doReturn;\n\nimport static org.mockito.Mockito.doThrow;\n\nimport static org.mockito.Mockito.inOrder;\n\nimport static org.mockito.Mockito.mock;\n\nimport static org.mockito.Mockito.times;\n\nimport static org.mockito.Mockito.verify;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport org.junit.Before;\n\nimport org.junit.Rule;\n\nimport org.junit.Test;\n\nimport org.junit.rules.ExpectedException;\n\nimport org.junit.runner.RunWith;\n\nimport org.mockito.ArgumentCaptor;\n\nimport org.mockito.InOrder;\n\nimport org.mockito.Mock;\n\nimport org.mockito.Mockito;\n\nimport org.mockito.runners.MockitoJUnitRunner;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic Stage<T> whenDone(final Runnable finishable) {\n    if (add(finishable)) {\n        return this;\n    }\n    caller.execute(finishable);\n    return this;\n}",
      "all_field_declaration": "/**\n * the max number of spins allowed before {@link Thread#yield()}\n */\nstatic final int MAX_SPINS = 4;\n/**\n * Possible states of the completable. A state being set <em>does not</em> indicate that the\n * completable is no longer running, but must always be checked in concert with a {@code result !=\n * null}.\n */\nstatic final int PENDING = 0;\nstatic final int COMPLETED = 1;\nstatic final int FAILED = 2;\nstatic final int CANCELLED = 3;\n/**\n * Indicates a result containing {@code null}.\n */\nstatic final Object NULL = new Object();\nstatic final Object CANCEL = new Object();\n/**\n * pair to CAS into callbacks when done\n */\nstatic final RunnablePair END = new RunnablePair(null, null);\nprivate final Caller caller;\n/**\n * Current state of the completable.\n */\nfinal AtomicInteger state = new AtomicInteger();\n/**\n * Result of the completable.\n * Never stored null, but uses {@link #NULL} as a surrogate instead.\n */\nvolatile Object result = null;\n/**\n * a linked list of callbacks to execute\n */\nfinal AtomicReference<RunnablePair> callbacks;",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "3",
      "Filed": "private final Caller caller;",
      "Parameter_type": "Runnable",
      "Import_statements": "",
      "public_method_signature": "public ConcurrentCompletable(final Caller caller);\npublic void completed(final T result);\npublic void failed(final Throwable cause);\npublic void cancelled();\npublic boolean complete(final T result);\npublic boolean fail(final Throwable cause);\npublic boolean cancel();\npublic Stage<T> handle(final Handle<? super T> handle);\npublic Stage<T> whenDone(final Runnable finishable);\npublic Stage<T> whenComplete(final Consumer<? super T> consumer);\npublic Stage<T> whenFailed(final Consumer<? super Throwable> consumer);\npublic Stage<T> whenCancelled(final Runnable cancelled);\npublic boolean isDone();\npublic boolean isCompleted();\npublic boolean isFailed();\npublic boolean isCancelled();\npublic Throwable cause();\npublic T join() throws InterruptedException, ExecutionException;\npublic T joinNow() throws ExecutionException;\npublic T join(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;\npublic Stage<U> thenApply(Function<? super T, ? extends U> fn);\npublic Stage<U> thenCompose(final Function<? super T, ? extends Stage<U>> fn);\npublic Stage<T> thenApplyFailed(final Function<? super Throwable, ? extends T> fn);\npublic Stage<T> thenComposeCaught(final Function<? super Throwable, ? extends Stage<T>> fn);\npublic Stage<T> withCloser(final Supplier<? extends Stage<Void>> complete, final Supplier<? extends Stage<Void>> notComplete);\npublic Stage<T> withComplete(final Supplier<? extends Stage<Void>> supplier);\npublic Stage<T> withNotComplete(final Supplier<? extends Stage<Void>> supplier);\npublic Stage<U> thenFail(final Throwable cause);\npublic Stage<U> thenComplete(final U result);\npublic Stage<U> thenCancel();\npublic String toString();",
      "public_field": "",
      "Method_statement": "whenDone(final Runnable finishable)",
      "Method_name": "whenDone",
      "Class_declaration": "public class ConcurrentCompletable {\n",
      "constructors": "public ConcurrentCompletable(final Caller caller) {\n    super(caller);\n    this.caller = caller;\n    this.callbacks = new AtomicReference<>();\n}ConcurrentCompletable(final Caller caller, final Runnable runnable) {\n    super(caller);\n    this.caller = caller;\n    this.callbacks = new AtomicReference<>(new RunnablePair(runnable, null));\n}",
      "all_method_signature": "public ConcurrentCompletable(final Caller caller);\n ConcurrentCompletable(final Caller caller, final Runnable runnable);\npublic void completed(final T result);\npublic void failed(final Throwable cause);\npublic void cancelled();\npublic boolean complete(final T result);\npublic boolean fail(final Throwable cause);\npublic boolean cancel();\npublic Stage<T> handle(final Handle<? super T> handle);\npublic Stage<T> whenDone(final Runnable finishable);\npublic Stage<T> whenComplete(final Consumer<? super T> consumer);\npublic Stage<T> whenFailed(final Consumer<? super Throwable> consumer);\npublic Stage<T> whenCancelled(final Runnable cancelled);\npublic boolean isDone();\npublic boolean isCompleted();\npublic boolean isFailed();\npublic boolean isCancelled();\npublic Throwable cause();\npublic T join() throws InterruptedException, ExecutionException;\npublic T joinNow() throws ExecutionException;\npublic T join(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;\npublic Stage<U> thenApply(Function<? super T, ? extends U> fn);\npublic Stage<U> thenCompose(final Function<? super T, ? extends Stage<U>> fn);\npublic Stage<T> thenApplyFailed(final Function<? super Throwable, ? extends T> fn);\npublic Stage<T> thenComposeCaught(final Function<? super Throwable, ? extends Stage<T>> fn);\npublic Stage<T> withCloser(final Supplier<? extends Stage<Void>> complete, final Supplier<? extends Stage<Void>> notComplete);\npublic Stage<T> withComplete(final Supplier<? extends Stage<Void>> supplier);\npublic Stage<T> withNotComplete(final Supplier<? extends Stage<Void>> supplier);\npublic Stage<U> thenFail(final Throwable cause);\npublic Stage<U> thenComplete(final U result);\npublic Stage<U> thenCancel();\n ConcurrentCompletable<U> nextStage();\n void postComplete();\n RunnablePair takeAndClear();\n boolean add(Runnable runnable);\n T doJoin() throws ExecutionException;\npublic String toString();\n T result(final Object r);\n static Throwable throwable(final Object r);\n void handleStage(final Supplier<? extends Stage<U>> supplier, final ConcurrentCompletable<U> target);",
      "Class_name": "ConcurrentCompletable",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/main/java/eu/toolchain/concurrent/ConcurrentCompletable###whenDone",
      "Parameter_num": "1",
      "all_Import_statements": "import java.text.MessageFormat;\n\nimport java.util.concurrent.CancellationException;\n\nimport java.util.concurrent.ExecutionException;\n\nimport java.util.concurrent.TimeUnit;\n\nimport java.util.concurrent.TimeoutException;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport java.util.concurrent.locks.LockSupport;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport lombok.AllArgsConstructor;\n\nimport lombok.RequiredArgsConstructor;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "method_signature": "public Stage<T> whenDone(final Runnable finishable);",
      "Junit_version": "4",
      "returnType": "Stage<T>"
    },
    "Test_method": {
      "Method_body": "final Runnable runnable = mock(Runnable.class);\n\rdoReturn(false).when(c.completable).add(runnable);\n\rc.completable.whenDone(runnable);\n\rdoReturn(true).when(c.completable).add(runnable);\n\rc.completable.whenDone(runnable);\n\rfinal InOrder order = inOrder(c.completable, caller, runnable);\n\rorder.verify(c.completable).add(runnable);\n\rorder.verify(caller).execute(runnable);\n\rorder.verify(c.completable).add(runnable);\n\rorder.verifyNoMoreInteractions();",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "10",
      "Filed": "@Mock\nprivate Caller caller;private Completable c;",
      "Import_statements": "import static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.inOrder;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.verify;\nimport org.mockito.InOrder;\n",
      "allMethod_info": "@Test\npublic void testWhenDone() {\n    final Runnable runnable = mock(Runnable.class);\n    doReturn(false).when(c.completable).add(runnable);\n    c.completable.whenDone(runnable);\n    doReturn(true).when(c.completable).add(runnable);\n    c.completable.whenDone(runnable);\n    final InOrder order = inOrder(c.completable, caller, runnable);\n    order.verify(c.completable).add(runnable);\n    order.verify(caller).execute(runnable);\n    order.verify(c.completable).add(runnable);\n    order.verifyNoMoreInteractions();\n}",
      "Method_name": "testWhenDone",
      "Class_declaration": "public class ConcurrentCompletableTest {\n",
      "constructors": "",
      "Class_name": "ConcurrentCompletableTest",
      "methodName_paraNum": "[mock(1), add(1), when(1), doReturn(1), whenDone(1), add(1), when(1), doReturn(1), whenDone(1), inOrder(3), add(1), verify(1), execute(1), verify(1), add(1), verify(1), verifyNoMoreInteractions(0)]",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/ConcurrentCompletableTest###testWhenDone",
      "relativePath": "udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/ConcurrentCompletableTest.java",
      "Signature": "public void testWhenDone() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.mockito.Matchers.any;\n\nimport static org.mockito.Matchers.eq;\n\nimport static org.mockito.Mockito.doNothing;\n\nimport static org.mockito.Mockito.doReturn;\n\nimport static org.mockito.Mockito.doThrow;\n\nimport static org.mockito.Mockito.inOrder;\n\nimport static org.mockito.Mockito.mock;\n\nimport static org.mockito.Mockito.times;\n\nimport static org.mockito.Mockito.verify;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport org.junit.Before;\n\nimport org.junit.Rule;\n\nimport org.junit.Test;\n\nimport org.junit.rules.ExpectedException;\n\nimport org.junit.runner.RunWith;\n\nimport org.mockito.ArgumentCaptor;\n\nimport org.mockito.InOrder;\n\nimport org.mockito.Mock;\n\nimport org.mockito.Mockito;\n\nimport org.mockito.runners.MockitoJUnitRunner;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic Borrowed<T> borrow() {\n    retain();\n    final T value = reference.get();\n    if (value == null) {\n        release();\n        return invalid();\n    }\n    final ValidBorrowed b = new ValidBorrowed(value, getStackTrace());\n    if (traces != null) {\n        traces.add(b);\n    }\n    return b;\n}",
      "all_field_declaration": "private static final InvalidBorrowed<?> INVALID = new InvalidBorrowed<>();\nprivate static final StackTraceElement[] EMPTY_STACK = new StackTraceElement[0];\nprivate final Caller caller;\nprivate final Supplier<? extends Stage<T>> setup;\n// the managed reference.\nfinal AtomicReference<T> reference = new AtomicReference<>();\n// acts to allow only a single thread to setup the reference.\nprivate final Completable<Void> startFuture;\nprivate final Completable<Void> zeroLeaseFuture;\nprivate final Completable<T> stopReferenceFuture;\n// composite completable that depends on zero-lease, and stop-reference.\nprivate final Stage<Void> stopFuture;\nprivate final boolean captureStack;\nfinal Set<ValidBorrowed> traces;\nfinal AtomicReference<ManagedState> state = new AtomicReference<>(ManagedState.INITIALIZED);\n/**\n * The number of borrowed references that are out in the wild.\n */\nfinal AtomicInteger leases = new AtomicInteger(1);",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "6",
      "Filed": "final AtomicReference<T> reference = new AtomicReference<>();final Set<ValidBorrowed> traces;",
      "Parameter_type": "",
      "Import_statements": "",
      "public_method_signature": "public static ConcurrentManaged<T> newManaged(final Async async, final Caller caller, final ManagedOptions options, final Supplier<? extends Stage<T>> setup, final Function<? super T, ? extends Stage<Void>> teardown);\npublic Stage<R> doto(final Function<? super T, ? extends Stage<R>> action);\npublic Borrowed<T> borrow();\npublic boolean isReady();\npublic Stage<Void> start();\npublic Stage<Void> stop();\npublic String toString();",
      "public_field": "",
      "Method_statement": "borrow()",
      "Method_name": "borrow",
      "Class_declaration": "public class ConcurrentManaged {\n",
      "constructors": "ConcurrentManaged(final Caller caller, final ManagedOptions options, final Supplier<? extends Stage<T>> setup, final Completable<Void> startFuture, final Completable<Void> zeroLeaseFuture, final Completable<T> stopReferenceFuture, final Stage<Void> stopFuture) {\n    this.caller = caller;\n    this.setup = setup;\n    this.startFuture = startFuture;\n    this.zeroLeaseFuture = zeroLeaseFuture;\n    this.stopReferenceFuture = stopReferenceFuture;\n    this.stopFuture = stopFuture;\n    this.captureStack = options.isCaptureStack();\n    if (options.isTracing()) {\n        traces = Collections.newSetFromMap(new ConcurrentHashMap<ValidBorrowed, Boolean>());\n    } else {\n        traces = null;\n    }\n}",
      "all_method_signature": "public static ConcurrentManaged<T> newManaged(final Async async, final Caller caller, final ManagedOptions options, final Supplier<? extends Stage<T>> setup, final Function<? super T, ? extends Stage<Void>> teardown);\n ConcurrentManaged(final Caller caller, final ManagedOptions options, final Supplier<? extends Stage<T>> setup, final Completable<Void> startFuture, final Completable<Void> zeroLeaseFuture, final Completable<T> stopReferenceFuture, final Stage<Void> stopFuture);\npublic Stage<R> doto(final Function<? super T, ? extends Stage<R>> action);\npublic Borrowed<T> borrow();\npublic boolean isReady();\npublic Stage<Void> start();\npublic Stage<Void> stop();\n void retain();\n void release();\npublic String toString();\n String toStringTracing(final T reference, List<ValidBorrowed> traces);\n StackTraceElement[] getStackTrace();\n static Borrowed<T> invalid();",
      "Class_name": "ConcurrentManaged",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/main/java/eu/toolchain/concurrent/ConcurrentManaged###borrow",
      "Parameter_num": "0",
      "all_Import_statements": "import static eu.toolchain.concurrent.CoreAsync.formatStack;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collections;\n\nimport java.util.List;\n\nimport java.util.Set;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport lombok.RequiredArgsConstructor;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "method_signature": "public Borrowed<T> borrow();",
      "Junit_version": "4",
      "returnType": "Borrowed<T>"
    },
    "Test_method": {
      "Method_body": "setupBorrow(true);\n\rassertTrue(underTest.borrow().isValid());\n\rverifyBorrow(true);",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "3",
      "Filed": "private static final RuntimeException e = new RuntimeException();private ConcurrentManaged<Object> underTest;@Mock\nprivate Supplier<? extends Stage<Object>> setup;",
      "Import_statements": "import static org.junit.Assert.assertTrue;\nimport static org.mockito.Mockito.verify;\nimport org.junit.Test;\n",
      "allMethod_info": "@Test\npublic void testBorrow() throws Exception {\n    setupBorrow(true);\n    assertTrue(underTest.borrow().isValid());\n    verifyBorrow(true);\n}",
      "Method_name": "testBorrow",
      "Class_declaration": "public class ConcurrentManagedTest {\n",
      "constructors": "",
      "Class_name": "ConcurrentManagedTest",
      "methodName_paraNum": "[setupBorrow(1), isValid(0), borrow(0), verifyBorrow(1)]",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/ConcurrentManagedTest###testBorrow",
      "relativePath": "udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/ConcurrentManagedTest.java",
      "Signature": "public void testBorrow() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertNull;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.junit.Assert.fail;\n\nimport static org.mockito.Matchers.any;\n\nimport static org.mockito.Mockito.doAnswer;\n\nimport static org.mockito.Mockito.doNothing;\n\nimport static org.mockito.Mockito.doReturn;\n\nimport static org.mockito.Mockito.doThrow;\n\nimport static org.mockito.Mockito.mock;\n\nimport static org.mockito.Mockito.never;\n\nimport static org.mockito.Mockito.spy;\n\nimport static org.mockito.Mockito.times;\n\nimport static org.mockito.Mockito.verify;\n\nimport static org.mockito.Mockito.when;\n\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport org.junit.Before;\n\nimport org.junit.Test;\n\nimport org.junit.runner.RunWith;\n\nimport org.mockito.Mock;\n\nimport org.mockito.invocation.InvocationOnMock;\n\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport org.mockito.stubbing.Answer;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic <R> Stage<R> doto(final Function<? super T, ? extends Stage<R>> action) {\n    final Borrowed<T> b = borrow();\n    if (!b.isValid()) {\n        return new ImmediateCancelled<>(caller);\n    }\n    final T reference = b.get();\n    final Stage<R> f;\n    try {\n        f = action.apply(reference);\n    } catch (final Exception e) {\n        b.release();\n        return new ImmediateFailed<>(caller, e);\n    }\n    return f.whenDone(b::release);\n}",
      "all_field_declaration": "private static final InvalidBorrowed<?> INVALID = new InvalidBorrowed<>();\nprivate static final StackTraceElement[] EMPTY_STACK = new StackTraceElement[0];\nprivate final Caller caller;\nprivate final Supplier<? extends Stage<T>> setup;\n// the managed reference.\nfinal AtomicReference<T> reference = new AtomicReference<>();\n// acts to allow only a single thread to setup the reference.\nprivate final Completable<Void> startFuture;\nprivate final Completable<Void> zeroLeaseFuture;\nprivate final Completable<T> stopReferenceFuture;\n// composite completable that depends on zero-lease, and stop-reference.\nprivate final Stage<Void> stopFuture;\nprivate final boolean captureStack;\nfinal Set<ValidBorrowed> traces;\nfinal AtomicReference<ManagedState> state = new AtomicReference<>(ManagedState.INITIALIZED);\n/**\n * The number of borrowed references that are out in the wild.\n */\nfinal AtomicInteger leases = new AtomicInteger(1);",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "6",
      "Filed": "private final Caller caller;final AtomicReference<T> reference = new AtomicReference<>();",
      "Parameter_type": "Function<? super T, ? extends Stage<R>>",
      "Import_statements": "import java.util.function.Function;\n",
      "public_method_signature": "public static ConcurrentManaged<T> newManaged(final Async async, final Caller caller, final ManagedOptions options, final Supplier<? extends Stage<T>> setup, final Function<? super T, ? extends Stage<Void>> teardown);\npublic Stage<R> doto(final Function<? super T, ? extends Stage<R>> action);\npublic Borrowed<T> borrow();\npublic boolean isReady();\npublic Stage<Void> start();\npublic Stage<Void> stop();\npublic String toString();",
      "public_field": "",
      "Method_statement": "doto(final Function<? super T, ? extends Stage<R>> action)",
      "Method_name": "doto",
      "Class_declaration": "public class ConcurrentManaged {\n",
      "constructors": "ConcurrentManaged(final Caller caller, final ManagedOptions options, final Supplier<? extends Stage<T>> setup, final Completable<Void> startFuture, final Completable<Void> zeroLeaseFuture, final Completable<T> stopReferenceFuture, final Stage<Void> stopFuture) {\n    this.caller = caller;\n    this.setup = setup;\n    this.startFuture = startFuture;\n    this.zeroLeaseFuture = zeroLeaseFuture;\n    this.stopReferenceFuture = stopReferenceFuture;\n    this.stopFuture = stopFuture;\n    this.captureStack = options.isCaptureStack();\n    if (options.isTracing()) {\n        traces = Collections.newSetFromMap(new ConcurrentHashMap<ValidBorrowed, Boolean>());\n    } else {\n        traces = null;\n    }\n}",
      "all_method_signature": "public static ConcurrentManaged<T> newManaged(final Async async, final Caller caller, final ManagedOptions options, final Supplier<? extends Stage<T>> setup, final Function<? super T, ? extends Stage<Void>> teardown);\n ConcurrentManaged(final Caller caller, final ManagedOptions options, final Supplier<? extends Stage<T>> setup, final Completable<Void> startFuture, final Completable<Void> zeroLeaseFuture, final Completable<T> stopReferenceFuture, final Stage<Void> stopFuture);\npublic Stage<R> doto(final Function<? super T, ? extends Stage<R>> action);\npublic Borrowed<T> borrow();\npublic boolean isReady();\npublic Stage<Void> start();\npublic Stage<Void> stop();\n void retain();\n void release();\npublic String toString();\n String toStringTracing(final T reference, List<ValidBorrowed> traces);\n StackTraceElement[] getStackTrace();\n static Borrowed<T> invalid();",
      "Class_name": "ConcurrentManaged",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/main/java/eu/toolchain/concurrent/ConcurrentManaged###doto",
      "Parameter_num": "1",
      "all_Import_statements": "import static eu.toolchain.concurrent.CoreAsync.formatStack;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collections;\n\nimport java.util.List;\n\nimport java.util.Set;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport lombok.RequiredArgsConstructor;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "method_signature": "public Stage<R> doto(final Function<? super T, ? extends Stage<R>> action);",
      "Junit_version": "4",
      "returnType": "Stage<R>"
    },
    "Test_method": {
      "Method_body": "setupDoto(true, false);\n\rassertEquals(stage, underTest.doto(action));\n\rverifyDoto(true, false);",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "3",
      "Filed": "private static final RuntimeException e = new RuntimeException();private ConcurrentManaged<Object> underTest;@Mock\nprivate Supplier<? extends Stage<Object>> setup;@Mock\nprivate Function<Object, Stage<Object>> action;@Mock\nprivate Stage<Object> stage;",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.verify;\nimport org.junit.Test;\n",
      "allMethod_info": "@Test\npublic void testDoto() throws Exception {\n    setupDoto(true, false);\n    assertEquals(stage, underTest.doto(action));\n    verifyDoto(true, false);\n}",
      "Method_name": "testDoto",
      "Class_declaration": "public class ConcurrentManagedTest {\n",
      "constructors": "",
      "Class_name": "ConcurrentManagedTest",
      "methodName_paraNum": "[setupDoto(2), doto(1), verifyDoto(2)]",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/ConcurrentManagedTest###testDoto",
      "relativePath": "udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/ConcurrentManagedTest.java",
      "Signature": "public void testDoto() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertNull;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.junit.Assert.fail;\n\nimport static org.mockito.Matchers.any;\n\nimport static org.mockito.Mockito.doAnswer;\n\nimport static org.mockito.Mockito.doNothing;\n\nimport static org.mockito.Mockito.doReturn;\n\nimport static org.mockito.Mockito.doThrow;\n\nimport static org.mockito.Mockito.mock;\n\nimport static org.mockito.Mockito.never;\n\nimport static org.mockito.Mockito.spy;\n\nimport static org.mockito.Mockito.times;\n\nimport static org.mockito.Mockito.verify;\n\nimport static org.mockito.Mockito.when;\n\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport org.junit.Before;\n\nimport org.junit.Test;\n\nimport org.junit.runner.RunWith;\n\nimport org.mockito.Mock;\n\nimport org.mockito.invocation.InvocationOnMock;\n\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport org.mockito.stubbing.Answer;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic Stage<Void> stop() {\n    if (!state.compareAndSet(ManagedState.STARTED, ManagedState.STOPPED)) {\n        return stopFuture;\n    }\n    stopReferenceFuture.complete(this.reference.getAndSet(null));\n    release();\n    return stopFuture;\n}",
      "all_field_declaration": "private static final InvalidBorrowed<?> INVALID = new InvalidBorrowed<>();\nprivate static final StackTraceElement[] EMPTY_STACK = new StackTraceElement[0];\nprivate final Caller caller;\nprivate final Supplier<? extends Stage<T>> setup;\n// the managed reference.\nfinal AtomicReference<T> reference = new AtomicReference<>();\n// acts to allow only a single thread to setup the reference.\nprivate final Completable<Void> startFuture;\nprivate final Completable<Void> zeroLeaseFuture;\nprivate final Completable<T> stopReferenceFuture;\n// composite completable that depends on zero-lease, and stop-reference.\nprivate final Stage<Void> stopFuture;\nprivate final boolean captureStack;\nfinal Set<ValidBorrowed> traces;\nfinal AtomicReference<ManagedState> state = new AtomicReference<>(ManagedState.INITIALIZED);\n/**\n * The number of borrowed references that are out in the wild.\n */\nfinal AtomicInteger leases = new AtomicInteger(1);",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "4",
      "Filed": "final AtomicReference<T> reference = new AtomicReference<>();private final Completable<T> stopReferenceFuture;private final Stage<Void> stopFuture;final AtomicReference<ManagedState> state = new AtomicReference<>(ManagedState.INITIALIZED);",
      "Parameter_type": "",
      "Import_statements": "import java.util.Set;\n",
      "public_method_signature": "public static ConcurrentManaged<T> newManaged(final Async async, final Caller caller, final ManagedOptions options, final Supplier<? extends Stage<T>> setup, final Function<? super T, ? extends Stage<Void>> teardown);\npublic Stage<R> doto(final Function<? super T, ? extends Stage<R>> action);\npublic Borrowed<T> borrow();\npublic boolean isReady();\npublic Stage<Void> start();\npublic Stage<Void> stop();\npublic String toString();",
      "public_field": "",
      "Method_statement": "stop()",
      "Method_name": "stop",
      "Class_declaration": "public class ConcurrentManaged {\n",
      "constructors": "ConcurrentManaged(final Caller caller, final ManagedOptions options, final Supplier<? extends Stage<T>> setup, final Completable<Void> startFuture, final Completable<Void> zeroLeaseFuture, final Completable<T> stopReferenceFuture, final Stage<Void> stopFuture) {\n    this.caller = caller;\n    this.setup = setup;\n    this.startFuture = startFuture;\n    this.zeroLeaseFuture = zeroLeaseFuture;\n    this.stopReferenceFuture = stopReferenceFuture;\n    this.stopFuture = stopFuture;\n    this.captureStack = options.isCaptureStack();\n    if (options.isTracing()) {\n        traces = Collections.newSetFromMap(new ConcurrentHashMap<ValidBorrowed, Boolean>());\n    } else {\n        traces = null;\n    }\n}",
      "all_method_signature": "public static ConcurrentManaged<T> newManaged(final Async async, final Caller caller, final ManagedOptions options, final Supplier<? extends Stage<T>> setup, final Function<? super T, ? extends Stage<Void>> teardown);\n ConcurrentManaged(final Caller caller, final ManagedOptions options, final Supplier<? extends Stage<T>> setup, final Completable<Void> startFuture, final Completable<Void> zeroLeaseFuture, final Completable<T> stopReferenceFuture, final Stage<Void> stopFuture);\npublic Stage<R> doto(final Function<? super T, ? extends Stage<R>> action);\npublic Borrowed<T> borrow();\npublic boolean isReady();\npublic Stage<Void> start();\npublic Stage<Void> stop();\n void retain();\n void release();\npublic String toString();\n String toStringTracing(final T reference, List<ValidBorrowed> traces);\n StackTraceElement[] getStackTrace();\n static Borrowed<T> invalid();",
      "Class_name": "ConcurrentManaged",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/main/java/eu/toolchain/concurrent/ConcurrentManaged###stop",
      "Parameter_num": "0",
      "all_Import_statements": "import static eu.toolchain.concurrent.CoreAsync.formatStack;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collections;\n\nimport java.util.List;\n\nimport java.util.Set;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport lombok.RequiredArgsConstructor;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "method_signature": "public Stage<Void> stop();",
      "Junit_version": "4",
      "returnType": "Stage<Void>"
    },
    "Test_method": {
      "Method_body": "underTest.state.set(ConcurrentManaged.ManagedState.STARTED);\n\runderTest.reference.set(reference);\n\rassertEquals(stopFuture, underTest.stop());\n\rassertNull(underTest.reference.get());\n\rverify(underTest).release();",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "5",
      "Filed": "private static final Object reference = new Object();private static final RuntimeException e = new RuntimeException();private ConcurrentManaged<Object> underTest;@Mock\nprivate Completable<Void> stopFuture;",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport static org.mockito.Mockito.verify;\nimport org.junit.Test;\n",
      "allMethod_info": "@Test\npublic void testStop() {\n    underTest.state.set(ConcurrentManaged.ManagedState.STARTED);\n    underTest.reference.set(reference);\n    assertEquals(stopFuture, underTest.stop());\n    assertNull(underTest.reference.get());\n    verify(underTest).release();\n}",
      "Method_name": "testStop",
      "Class_declaration": "public class ConcurrentManagedTest {\n",
      "constructors": "",
      "Class_name": "ConcurrentManagedTest",
      "methodName_paraNum": "[set(1), set(1), stop(0), get(0), release(0), verify(1)]",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/ConcurrentManagedTest###testStop",
      "relativePath": "udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/ConcurrentManagedTest.java",
      "Signature": "public void testStop() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertNull;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.junit.Assert.fail;\n\nimport static org.mockito.Matchers.any;\n\nimport static org.mockito.Mockito.doAnswer;\n\nimport static org.mockito.Mockito.doNothing;\n\nimport static org.mockito.Mockito.doReturn;\n\nimport static org.mockito.Mockito.doThrow;\n\nimport static org.mockito.Mockito.mock;\n\nimport static org.mockito.Mockito.never;\n\nimport static org.mockito.Mockito.spy;\n\nimport static org.mockito.Mockito.times;\n\nimport static org.mockito.Mockito.verify;\n\nimport static org.mockito.Mockito.when;\n\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport org.junit.Before;\n\nimport org.junit.Test;\n\nimport org.junit.runner.RunWith;\n\nimport org.mockito.Mock;\n\nimport org.mockito.invocation.InvocationOnMock;\n\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport org.mockito.stubbing.Answer;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "String toStringTracing(final T reference, List<ValidBorrowed> traces) {\n    final StringBuilder builder = new StringBuilder();\n    builder.append(String.format(\"Managed(%s, %s:\\n\", state, reference));\n    for (final ValidBorrowed b : traces) {\n        builder.append(b.toString());\n    }\n    builder.append(\")\");\n    return builder.toString();\n}",
      "all_field_declaration": "private static final InvalidBorrowed<?> INVALID = new InvalidBorrowed<>();\nprivate static final StackTraceElement[] EMPTY_STACK = new StackTraceElement[0];\nprivate final Caller caller;\nprivate final Supplier<? extends Stage<T>> setup;\n// the managed reference.\nfinal AtomicReference<T> reference = new AtomicReference<>();\n// acts to allow only a single thread to setup the reference.\nprivate final Completable<Void> startFuture;\nprivate final Completable<Void> zeroLeaseFuture;\nprivate final Completable<T> stopReferenceFuture;\n// composite completable that depends on zero-lease, and stop-reference.\nprivate final Stage<Void> stopFuture;\nprivate final boolean captureStack;\nfinal Set<ValidBorrowed> traces;\nfinal AtomicReference<ManagedState> state = new AtomicReference<>(ManagedState.INITIALIZED);\n/**\n * The number of borrowed references that are out in the wild.\n */\nfinal AtomicInteger leases = new AtomicInteger(1);",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "5",
      "Filed": "final AtomicReference<T> reference = new AtomicReference<>();final Set<ValidBorrowed> traces;final AtomicReference<ManagedState> state = new AtomicReference<>(ManagedState.INITIALIZED);",
      "Parameter_type": "T,List<ValidBorrowed>",
      "Import_statements": "import java.util.List;\n",
      "public_method_signature": "public static ConcurrentManaged<T> newManaged(final Async async, final Caller caller, final ManagedOptions options, final Supplier<? extends Stage<T>> setup, final Function<? super T, ? extends Stage<Void>> teardown);\npublic Stage<R> doto(final Function<? super T, ? extends Stage<R>> action);\npublic Borrowed<T> borrow();\npublic boolean isReady();\npublic Stage<Void> start();\npublic Stage<Void> stop();\npublic String toString();",
      "public_field": "",
      "Method_statement": "toStringTracing(final T reference, List<ValidBorrowed> traces)",
      "Method_name": "toStringTracing",
      "Class_declaration": "public class ConcurrentManaged {\n",
      "constructors": "ConcurrentManaged(final Caller caller, final ManagedOptions options, final Supplier<? extends Stage<T>> setup, final Completable<Void> startFuture, final Completable<Void> zeroLeaseFuture, final Completable<T> stopReferenceFuture, final Stage<Void> stopFuture) {\n    this.caller = caller;\n    this.setup = setup;\n    this.startFuture = startFuture;\n    this.zeroLeaseFuture = zeroLeaseFuture;\n    this.stopReferenceFuture = stopReferenceFuture;\n    this.stopFuture = stopFuture;\n    this.captureStack = options.isCaptureStack();\n    if (options.isTracing()) {\n        traces = Collections.newSetFromMap(new ConcurrentHashMap<ValidBorrowed, Boolean>());\n    } else {\n        traces = null;\n    }\n}",
      "all_method_signature": "public static ConcurrentManaged<T> newManaged(final Async async, final Caller caller, final ManagedOptions options, final Supplier<? extends Stage<T>> setup, final Function<? super T, ? extends Stage<Void>> teardown);\n ConcurrentManaged(final Caller caller, final ManagedOptions options, final Supplier<? extends Stage<T>> setup, final Completable<Void> startFuture, final Completable<Void> zeroLeaseFuture, final Completable<T> stopReferenceFuture, final Stage<Void> stopFuture);\npublic Stage<R> doto(final Function<? super T, ? extends Stage<R>> action);\npublic Borrowed<T> borrow();\npublic boolean isReady();\npublic Stage<Void> start();\npublic Stage<Void> stop();\n void retain();\n void release();\npublic String toString();\n String toStringTracing(final T reference, List<ValidBorrowed> traces);\n StackTraceElement[] getStackTrace();\n static Borrowed<T> invalid();",
      "Class_name": "ConcurrentManaged",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/main/java/eu/toolchain/concurrent/ConcurrentManaged###toStringTracing",
      "Parameter_num": "2",
      "all_Import_statements": "import static eu.toolchain.concurrent.CoreAsync.formatStack;\n\nimport java.util.ArrayList;\n\nimport java.util.Arrays;\n\nimport java.util.Collections;\n\nimport java.util.List;\n\nimport java.util.Set;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport lombok.RequiredArgsConstructor;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "method_signature": " String toStringTracing(final T reference, List<ValidBorrowed> traces);",
      "Junit_version": "4",
      "returnType": "String"
    },
    "Test_method": {
      "Method_body": "assertNotNull(underTest.toStringTracing(reference, ImmutableList.of(underTest.new ValidBorrowed(reference, stack))));",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "1",
      "Filed": "private static final Object reference = new Object();private static final RuntimeException e = new RuntimeException();private static final StackTraceElement[] stack = new StackTraceElement[0];private ConcurrentManaged<Object> underTest;",
      "Import_statements": "import static org.junit.Assert.assertNotNull;\nimport com.google.common.collect.ImmutableList;\nimport org.junit.Test;\n",
      "allMethod_info": "@SuppressWarnings(\"unchecked\")\n@Test\npublic void testToStringTracing() {\n    assertNotNull(underTest.toStringTracing(reference, ImmutableList.of(underTest.new ValidBorrowed(reference, stack))));\n}",
      "Method_name": "testToStringTracing",
      "Class_declaration": "public class ConcurrentManagedTest {\n",
      "constructors": "",
      "Class_name": "ConcurrentManagedTest",
      "methodName_paraNum": "[toStringTracing(2), of(1)]",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/ConcurrentManagedTest###testToStringTracing",
      "relativePath": "udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/ConcurrentManagedTest.java",
      "Signature": "public void testToStringTracing() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertNull;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.junit.Assert.fail;\n\nimport static org.mockito.Matchers.any;\n\nimport static org.mockito.Mockito.doAnswer;\n\nimport static org.mockito.Mockito.doNothing;\n\nimport static org.mockito.Mockito.doReturn;\n\nimport static org.mockito.Mockito.doThrow;\n\nimport static org.mockito.Mockito.mock;\n\nimport static org.mockito.Mockito.never;\n\nimport static org.mockito.Mockito.spy;\n\nimport static org.mockito.Mockito.times;\n\nimport static org.mockito.Mockito.verify;\n\nimport static org.mockito.Mockito.when;\n\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport org.junit.Before;\n\nimport org.junit.Test;\n\nimport org.junit.runner.RunWith;\n\nimport org.mockito.Mock;\n\nimport org.mockito.invocation.InvocationOnMock;\n\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport org.mockito.stubbing.Answer;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts) {\n    if (src.length == 0 && srcPos == 0 || 0 == nInts) {\n        return dstInit;\n    }\n    if ((nInts - 1) * 32 + dstPos >= 64) {\n        throw new IllegalArgumentException(\"(nInts-1)*32+dstPos is greater or equal to than 64\");\n    }\n    long out = dstInit;\n    for (int i = 0; i < nInts; i++) {\n        final int shift = i * 32 + dstPos;\n        final long bits = (0xffffffffL & src[i + srcPos]) << shift;\n        final long mask = 0xffffffffL << shift;\n        out = (out & ~mask) | bits;\n    }\n    return out;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "int[],int,long,int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "intArrayToLong(final int() src, final int srcPos, final long dstInit, final int dstPos, final int nInts)",
      "Method_name": "intArrayToLong",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###intArrayToLong",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts an array of int into a long using the default (little endian, Lsb0) byte and bit\n     * ordering.\n     * </p>\n     *\n     * @param src the int array to convert\n     * @param srcPos the position in {@code src}, in int unit, from where to start the\n     *            conversion\n     * @param dstInit initial value of the destination long\n     * @param dstPos the position of the lsb, in bits, in the result long\n     * @param nInts the number of ints to convert\n     * @return a long containing the selected bits\n     * @throws IllegalArgumentException if {@code (nInts-1)*32+dstPos >= 64}\n     * @throws NullPointerException if {@code src} is {@code null}\n     * @throws ArrayIndexOutOfBoundsException if {@code srcPos + nInts > src.length}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);",
      "Junit_version": "4",
      "returnType": "long"
    },
    "Test_method": {
      "Method_body": "final int[] src = new int[] { 0xCDF1F0C1, 0x0F123456, 0x78000000 };\n\rassertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 0, 0L, 0, 0));\n\rassertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 1, 0L, 0, 0));\n\rassertEquals(0x00000000CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 1));\n\rassertEquals(0x0F123456CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 2));\n\rassertEquals(0x000000000F123456L, Conversion.intArrayToLong(src, 1, 0L, 0, 1));\n\rassertEquals(0x123456789ABCDEF0L, Conversion.intArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0));\n\rassertEquals(0x1234567878000000L, Conversion.intArrayToLong(src, 2, 0x123456789ABCDEF0L, 0, 1));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "8",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}.\n */\n@Test\npublic void testIntArrayToLong() {\n    final int[] src = new int[] { 0xCDF1F0C1, 0x0F123456, 0x78000000 };\n    assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 0, 0L, 0, 0));\n    assertEquals(0x0000000000000000L, Conversion.intArrayToLong(src, 1, 0L, 0, 0));\n    assertEquals(0x00000000CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 1));\n    assertEquals(0x0F123456CDF1F0C1L, Conversion.intArrayToLong(src, 0, 0L, 0, 2));\n    assertEquals(0x000000000F123456L, Conversion.intArrayToLong(src, 1, 0L, 0, 1));\n    assertEquals(0x123456789ABCDEF0L, Conversion.intArrayToLong(src, 0, 0x123456789ABCDEF0L, 0, 0));\n    assertEquals(0x1234567878000000L, Conversion.intArrayToLong(src, 2, 0x123456789ABCDEF0L, 0, 1));\n    // assertEquals(0x0F12345678000000L,Conversion.intsToLong(src,1,0x123456789ABCDEF0L,32,2));\n}",
      "Method_name": "testIntArrayToLong",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[intArrayToLong(5), intArrayToLong(5), intArrayToLong(5), intArrayToLong(5), intArrayToLong(5), intArrayToLong(5), intArrayToLong(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testIntArrayToLong",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testIntArrayToLong() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#intArrayToLong(int[], int, long, int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {\n    if (0 == nBytes) {\n        return dst;\n    }\n    if ((nBytes - 1) * 8 + srcPos >= 32) {\n        throw new IllegalArgumentException(\"(nBytes-1)*8+srcPos is greater or equal to than 32\");\n    }\n    for (int i = 0; i < nBytes; i++) {\n        final int shift = i * 8 + srcPos;\n        dst[dstPos + i] = (byte) (0xff & (src >> shift));\n    }\n    return dst;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "int,int,byte[],int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "intToByteArray(final int src, final int srcPos, final byte() dst, final int dstPos, final int nBytes)",
      "Method_name": "intToByteArray",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###intToByteArray",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts an int into an array of byte using the default (little endian, Lsb0) byte and bit\n     * ordering.\n     * </p>\n     *\n     * @param src the int to convert\n     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n     * @param dst the destination array\n     * @param dstPos the position in {@code dst} where to copy the result\n     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to the\n     *            width of the input (from srcPos to msb)\n     * @return {@code dst}\n     * @throws NullPointerException if {@code dst} is {@code null}\n     * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 32}\n     * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBytes > dst.length}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);",
      "Junit_version": "4",
      "returnType": "byte[]"
    },
    "Test_method": {
      "Method_body": "assertArrayEquals(new byte[] {}, Conversion.intToByteArray(0x00000000, 0, new byte[] {}, 0, 0));\n\rassertArrayEquals(new byte[] {}, Conversion.intToByteArray(0x00000000, 100, new byte[] {}, 0, 0));\n\rassertArrayEquals(new byte[] {}, Conversion.intToByteArray(0x00000000, 0, new byte[] {}, 100, 0));\n\rassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 0));\n\rassertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n\rassertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 2));\n\rassertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 4));\n\rassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 1));\n\rassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 2));\n\rassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 4));\n\rassertArrayEquals(new byte[] { (byte) 0xF7, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 1, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n\rassertArrayEquals(new byte[] { (byte) 0x7B, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 2, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n\rassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x6F, (byte) 0x5E, (byte) 0x85, (byte) 0xFC, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 5, new byte[] { -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 4));\n\r// assertArrayEquals(new\n// byte[]{(byte)0xFF,(byte)0x00,(byte)0xFF,(byte)0x5E,(byte)0x85,(byte)0xFC,(byte)0x00,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF},Conversion.intToByteArray(0x90ABCDEF,13,new\n// byte[]{-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1},3,4));//rejected by assertion\nassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x5E, (byte) 0x85, (byte) 0xFC, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 13, new byte[] { -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 3));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "14",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertArrayEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#intToByteArray(int, int, byte[], int, int)}.\n */\n@Test\npublic void testIntToByteArray() {\n    assertArrayEquals(new byte[] {}, Conversion.intToByteArray(0x00000000, 0, new byte[] {}, 0, 0));\n    assertArrayEquals(new byte[] {}, Conversion.intToByteArray(0x00000000, 100, new byte[] {}, 0, 0));\n    assertArrayEquals(new byte[] {}, Conversion.intToByteArray(0x00000000, 0, new byte[] {}, 100, 0));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 0));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 2));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 4));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 1));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 2));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 4));\n    assertArrayEquals(new byte[] { (byte) 0xF7, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 1, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0x7B, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 2, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x6F, (byte) 0x5E, (byte) 0x85, (byte) 0xFC, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 5, new byte[] { -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 4));\n    // assertArrayEquals(new\n    // byte[]{(byte)0xFF,(byte)0x00,(byte)0xFF,(byte)0x5E,(byte)0x85,(byte)0xFC,(byte)0x00,(byte)0xFF,(byte)0xFF,(byte)0xFF,(byte)0xFF},Conversion.intToByteArray(0x90ABCDEF,13,new\n    // byte[]{-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1},3,4));//rejected by assertion\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x5E, (byte) 0x85, (byte) 0xFC, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.intToByteArray(0x90ABCDEF, 13, new byte[] { -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 3));\n}",
      "Method_name": "testIntToByteArray",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[intToByteArray(5), intToByteArray(5), intToByteArray(5), intToByteArray(5), intToByteArray(5), intToByteArray(5), intToByteArray(5), intToByteArray(5), intToByteArray(5), intToByteArray(5), intToByteArray(5), intToByteArray(5), intToByteArray(5), intToByteArray(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testIntToByteArray",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testIntToByteArray() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#intToByteArray(int, int, byte[], int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) {\n    if (0 == nShorts) {\n        return dst;\n    }\n    if ((nShorts - 1) * 16 + srcPos >= 32) {\n        throw new IllegalArgumentException(\"(nShorts-1)*16+srcPos is greater or equal to than 32\");\n    }\n    for (int i = 0; i < nShorts; i++) {\n        final int shift = i * 16 + srcPos;\n        dst[dstPos + i] = (short) (0xffff & (src >> shift));\n    }\n    return dst;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "int,int,short[],int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "intToShortArray(final int src, final int srcPos, final short() dst, final int dstPos, final int nShorts)",
      "Method_name": "intToShortArray",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###intToShortArray",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts an int into an array of short using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the int to convert\n     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n     * @param dst the destination array\n     * @param dstPos the position in {@code dst} where to copy the result\n     * @param nShorts the number of shorts to copy to {@code dst}, must be smaller or equal to\n     *            the width of the input (from srcPos to msb)\n     * @return {@code dst}\n     * @throws NullPointerException if {@code dst} is {@code null}\n     * @throws IllegalArgumentException if {@code (nShorts-1)*16+srcPos >= 32}\n     * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nShorts > dst.length}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);",
      "Junit_version": "4",
      "returnType": "short[]"
    },
    "Test_method": {
      "Method_body": "assertArrayEquals(new short[] {}, Conversion.intToShortArray(0x00000000, 0, new short[] {}, 0, 0));\n\rassertArrayEquals(new short[] {}, Conversion.intToShortArray(0x00000000, 100, new short[] {}, 0, 0));\n\rassertArrayEquals(new short[] {}, Conversion.intToShortArray(0x00000000, 0, new short[] {}, 100, 0));\n\rassertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 0, 0));\n\rassertArrayEquals(new short[] { (short) 0x5678, (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 0, 1));\n\rassertArrayEquals(new short[] { (short) 0x5678, (short) 0x1234, (short) 0xFFFF, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 0, 2));\n\r// assertArrayEquals(new\n// short[]{(short)0x5678,(short)0x1234,(short)0x5678,(short)0xFFFF},Conversion.intToShortArray(0x12345678,\n// 0,new short[]{-1,-1,-1,-1},0,3));//rejected by assertion\n// assertArrayEquals(new\n// short[]{(short)0x5678,(short)0x1234,(short)0x5678,(short)0x1234},Conversion.intToShortArray(0x12345678,\n// 0,new short[]{-1,-1,-1,-1},0,4));\n// assertArrayEquals(new\n// short[]{(short)0xFFFF,(short)0x5678,(short)0x1234,(short)0x5678},Conversion.intToShortArray(0x12345678,\n// 0,new short[]{-1,-1,-1,-1},1,3));\nassertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x5678, (short) 0x1234 }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 2, 2));\n\rassertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x5678, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 2, 1));\n\rassertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF, (short) 0x5678 }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 3, 1));\n\rassertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x2B3C, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 1, new short[] { -1, -1, -1, -1 }, 2, 1));\n\rassertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x159E, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 2, new short[] { -1, -1, -1, -1 }, 2, 1));\n\rassertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x8ACF, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 3, new short[] { -1, -1, -1, -1 }, 2, 1));\n\rassertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x4567, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 4, new short[] { -1, -1, -1, -1 }, 2, 1));\n\r// assertArrayEquals(new\n// short[]{(short)0xE6F7,(short)0x4855,(short)0x2B3C,(short)0x091A},Conversion.intToShortArray(0x12345678,\n// 1,new short[]{-1,-1,-1,-1},0,4));//rejected by assertion\n// assertArrayEquals(new\n// short[]{(short)0x2B3C},Conversion.intToShortArray(0x12345678,33,new\n// short[]{0},0,1));//rejected by assertion\nassertArrayEquals(new short[] { (short) 0x091A }, Conversion.intToShortArray(0x12345678, 17, new short[] { 0 }, 0, 1));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "14",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertArrayEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#intToShortArray(int, int, short[], int, int)}.\n */\n@Test\npublic void testIntToShortArray() {\n    assertArrayEquals(new short[] {}, Conversion.intToShortArray(0x00000000, 0, new short[] {}, 0, 0));\n    assertArrayEquals(new short[] {}, Conversion.intToShortArray(0x00000000, 100, new short[] {}, 0, 0));\n    assertArrayEquals(new short[] {}, Conversion.intToShortArray(0x00000000, 0, new short[] {}, 100, 0));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 0, 0));\n    assertArrayEquals(new short[] { (short) 0x5678, (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new short[] { (short) 0x5678, (short) 0x1234, (short) 0xFFFF, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 0, 2));\n    // assertArrayEquals(new\n    // short[]{(short)0x5678,(short)0x1234,(short)0x5678,(short)0xFFFF},Conversion.intToShortArray(0x12345678,\n    // 0,new short[]{-1,-1,-1,-1},0,3));//rejected by assertion\n    // assertArrayEquals(new\n    // short[]{(short)0x5678,(short)0x1234,(short)0x5678,(short)0x1234},Conversion.intToShortArray(0x12345678,\n    // 0,new short[]{-1,-1,-1,-1},0,4));\n    // assertArrayEquals(new\n    // short[]{(short)0xFFFF,(short)0x5678,(short)0x1234,(short)0x5678},Conversion.intToShortArray(0x12345678,\n    // 0,new short[]{-1,-1,-1,-1},1,3));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x5678, (short) 0x1234 }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 2, 2));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x5678, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF, (short) 0x5678 }, Conversion.intToShortArray(0x12345678, 0, new short[] { -1, -1, -1, -1 }, 3, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x2B3C, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 1, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x159E, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 2, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x8ACF, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 3, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x4567, (short) 0xFFFF }, Conversion.intToShortArray(0x12345678, 4, new short[] { -1, -1, -1, -1 }, 2, 1));\n    // assertArrayEquals(new\n    // short[]{(short)0xE6F7,(short)0x4855,(short)0x2B3C,(short)0x091A},Conversion.intToShortArray(0x12345678,\n    // 1,new short[]{-1,-1,-1,-1},0,4));//rejected by assertion\n    // assertArrayEquals(new\n    // short[]{(short)0x2B3C},Conversion.intToShortArray(0x12345678,33,new\n    // short[]{0},0,1));//rejected by assertion\n    assertArrayEquals(new short[] { (short) 0x091A }, Conversion.intToShortArray(0x12345678, 17, new short[] { 0 }, 0, 1));\n}",
      "Method_name": "testIntToShortArray",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[intToShortArray(5), intToShortArray(5), intToShortArray(5), intToShortArray(5), intToShortArray(5), intToShortArray(5), intToShortArray(5), intToShortArray(5), intToShortArray(5), intToShortArray(5), intToShortArray(5), intToShortArray(5), intToShortArray(5), intToShortArray(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testIntToShortArray",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testIntToShortArray() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#intToShortArray(int, int, short[], int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {\n    if (0 == nBytes) {\n        return dst;\n    }\n    if ((nBytes - 1) * 8 + srcPos >= 64) {\n        throw new IllegalArgumentException(\"(nBytes-1)*8+srcPos is greater or equal to than 64\");\n    }\n    for (int i = 0; i < nBytes; i++) {\n        final int shift = i * 8 + srcPos;\n        dst[dstPos + i] = (byte) (0xff & (src >> shift));\n    }\n    return dst;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "long,int,byte[],int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "longToByteArray(final long src, final int srcPos, final byte() dst, final int dstPos, final int nBytes)",
      "Method_name": "longToByteArray",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###longToByteArray",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts a long into an array of byte using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the long to convert\n     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n     * @param dst the destination array\n     * @param dstPos the position in {@code dst} where to copy the result\n     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to the\n     *            width of the input (from srcPos to msb)\n     * @return {@code dst}\n     * @throws NullPointerException if {@code dst} is {@code null}\n     * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 64}\n     * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBytes > dst.length}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);",
      "Junit_version": "4",
      "returnType": "byte[]"
    },
    "Test_method": {
      "Method_body": "assertArrayEquals(new byte[] {}, Conversion.longToByteArray(0x0000000000000000L, 0, new byte[] {}, 0, 0));\n\rassertArrayEquals(new byte[] {}, Conversion.longToByteArray(0x0000000000000000L, 100, new byte[] {}, 0, 0));\n\rassertArrayEquals(new byte[] {}, Conversion.longToByteArray(0x0000000000000000L, 0, new byte[] {}, 100, 0));\n\rassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 0));\n\rassertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n\rassertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 2));\n\rassertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 4));\n\rassertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0x78, (byte) 0x56, (byte) 0x34, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 7));\n\rassertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0x78, (byte) 0x56, (byte) 0x34, (byte) 0x12, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 8));\n\rassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 1));\n\rassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 2));\n\rassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 4));\n\rassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0x78, (byte) 0x56, (byte) 0x34, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 7));\n\rassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0x78, (byte) 0x56, (byte) 0x34, (byte) 0x12 }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 8));\n\rassertArrayEquals(new byte[] { (byte) 0xF7, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 1, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n\rassertArrayEquals(new byte[] { (byte) 0x7B, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 2, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n\rassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x6F, (byte) 0x5E, (byte) 0x85, (byte) 0xC4, (byte) 0xB3, (byte) 0xA2, (byte) 0x91, (byte) 0x00 }, Conversion.longToByteArray(0x1234567890ABCDEFL, 5, new byte[] { -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 8));\n\r// assertArrayEquals(new\n// byte[]{(byte)0xFF,(byte)0x00,(byte)0xFF,(byte)0x5E,(byte)0x85,(byte)0xC4,(byte)0xB3,(byte)0xA2,(byte)0x91,(byte)0x00,(byte)0x00},Conversion.longToByteArray(0x1234567890ABCDEFL,13,new\n// byte[]{-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1},3,8));//rejected by assertion\nassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x5E, (byte) 0x85, (byte) 0xC4, (byte) 0xB3, (byte) 0xA2, (byte) 0x91, (byte) 0x00, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 13, new byte[] { -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 7));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "18",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertArrayEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#longToByteArray(long, int, byte[], int, int)}.\n */\n@Test\npublic void testLongToByteArray() {\n    assertArrayEquals(new byte[] {}, Conversion.longToByteArray(0x0000000000000000L, 0, new byte[] {}, 0, 0));\n    assertArrayEquals(new byte[] {}, Conversion.longToByteArray(0x0000000000000000L, 100, new byte[] {}, 0, 0));\n    assertArrayEquals(new byte[] {}, Conversion.longToByteArray(0x0000000000000000L, 0, new byte[] {}, 100, 0));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 0));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 2));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 4));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0x78, (byte) 0x56, (byte) 0x34, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 7));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0x78, (byte) 0x56, (byte) 0x34, (byte) 0x12, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 8));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 1));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 2));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 4));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0x78, (byte) 0x56, (byte) 0x34, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 7));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xAB, (byte) 0x90, (byte) 0x78, (byte) 0x56, (byte) 0x34, (byte) 0x12 }, Conversion.longToByteArray(0x1234567890ABCDEFL, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 8));\n    assertArrayEquals(new byte[] { (byte) 0xF7, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 1, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0x7B, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 2, new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x6F, (byte) 0x5E, (byte) 0x85, (byte) 0xC4, (byte) 0xB3, (byte) 0xA2, (byte) 0x91, (byte) 0x00 }, Conversion.longToByteArray(0x1234567890ABCDEFL, 5, new byte[] { -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 8));\n    // assertArrayEquals(new\n    // byte[]{(byte)0xFF,(byte)0x00,(byte)0xFF,(byte)0x5E,(byte)0x85,(byte)0xC4,(byte)0xB3,(byte)0xA2,(byte)0x91,(byte)0x00,(byte)0x00},Conversion.longToByteArray(0x1234567890ABCDEFL,13,new\n    // byte[]{-1, 0,-1,-1,-1,-1,-1,-1,-1,-1,-1},3,8));//rejected by assertion\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x5E, (byte) 0x85, (byte) 0xC4, (byte) 0xB3, (byte) 0xA2, (byte) 0x91, (byte) 0x00, (byte) 0xFF }, Conversion.longToByteArray(0x1234567890ABCDEFL, 13, new byte[] { -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1 }, 3, 7));\n}",
      "Method_name": "testLongToByteArray",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[longToByteArray(5), longToByteArray(5), longToByteArray(5), longToByteArray(5), longToByteArray(5), longToByteArray(5), longToByteArray(5), longToByteArray(5), longToByteArray(5), longToByteArray(5), longToByteArray(5), longToByteArray(5), longToByteArray(5), longToByteArray(5), longToByteArray(5), longToByteArray(5), longToByteArray(5), longToByteArray(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testLongToByteArray",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testLongToByteArray() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#longToByteArray(long, int, byte[], int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts) {\n    if (0 == nShorts) {\n        return dst;\n    }\n    if ((nShorts - 1) * 16 + srcPos >= 64) {\n        throw new IllegalArgumentException(\"(nShorts-1)*16+srcPos is greater or equal to than 64\");\n    }\n    for (int i = 0; i < nShorts; i++) {\n        final int shift = i * 16 + srcPos;\n        dst[dstPos + i] = (short) (0xffff & (src >> shift));\n    }\n    return dst;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "long,int,short[],int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "longToShortArray(final long src, final int srcPos, final short() dst, final int dstPos, final int nShorts)",
      "Method_name": "longToShortArray",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###longToShortArray",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts a long into an array of short using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the long to convert\n     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n     * @param dst the destination array\n     * @param dstPos the position in {@code dst} where to copy the result\n     * @param nShorts the number of shorts to copy to {@code dst}, must be smaller or equal to\n     *            the width of the input (from srcPos to msb)\n     * @return {@code dst}\n     * @throws NullPointerException if {@code dst} is {@code null}\n     * @throws IllegalArgumentException if {@code (nShorts-1)*16+srcPos >= 64}\n     * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nShorts > dst.length}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);",
      "Junit_version": "4",
      "returnType": "short[]"
    },
    "Test_method": {
      "Method_body": "assertArrayEquals(new short[] {}, Conversion.longToShortArray(0x0000000000000000L, 0, new short[] {}, 0, 0));\n\rassertArrayEquals(new short[] {}, Conversion.longToShortArray(0x0000000000000000L, 100, new short[] {}, 0, 0));\n\rassertArrayEquals(new short[] {}, Conversion.longToShortArray(0x0000000000000000L, 0, new short[] {}, 100, 0));\n\rassertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 0, 0));\n\rassertArrayEquals(new short[] { (short) 0xCDEF, (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 0, 1));\n\rassertArrayEquals(new short[] { (short) 0xCDEF, (short) 0x90AB, (short) 0xFFFF, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 0, 2));\n\rassertArrayEquals(new short[] { (short) 0xCDEF, (short) 0x90AB, (short) 0x5678, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 0, 3));\n\rassertArrayEquals(new short[] { (short) 0xCDEF, (short) 0x90AB, (short) 0x5678, (short) 0x1234 }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 0, 4));\n\rassertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xCDEF, (short) 0x90AB, (short) 0x5678 }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 1, 3));\n\rassertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xCDEF, (short) 0x90AB }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 2, 2));\n\rassertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xCDEF, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 2, 1));\n\rassertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF, (short) 0xCDEF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 3, 1));\n\rassertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xE6F7, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 1, new short[] { -1, -1, -1, -1 }, 2, 1));\n\rassertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xF37B, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 2, new short[] { -1, -1, -1, -1 }, 2, 1));\n\rassertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x79BD, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 3, new short[] { -1, -1, -1, -1 }, 2, 1));\n\rassertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xBCDE, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 4, new short[] { -1, -1, -1, -1 }, 2, 1));\n\rassertArrayEquals(new short[] { (short) 0xE6F7, (short) 0x4855, (short) 0x2B3C, (short) 0x091A }, Conversion.longToShortArray(0x1234567890ABCDEFL, 1, new short[] { -1, -1, -1, -1 }, 0, 4));\n\rassertArrayEquals(new short[] { (short) 0x2B3C }, Conversion.longToShortArray(0x1234567890ABCDEFL, 33, new short[] { 0 }, 0, 1));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "18",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertArrayEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#longToShortArray(long, int, short[], int, int)}.\n */\n@Test\npublic void testLongToShortArray() {\n    assertArrayEquals(new short[] {}, Conversion.longToShortArray(0x0000000000000000L, 0, new short[] {}, 0, 0));\n    assertArrayEquals(new short[] {}, Conversion.longToShortArray(0x0000000000000000L, 100, new short[] {}, 0, 0));\n    assertArrayEquals(new short[] {}, Conversion.longToShortArray(0x0000000000000000L, 0, new short[] {}, 100, 0));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 0, 0));\n    assertArrayEquals(new short[] { (short) 0xCDEF, (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new short[] { (short) 0xCDEF, (short) 0x90AB, (short) 0xFFFF, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 0, 2));\n    assertArrayEquals(new short[] { (short) 0xCDEF, (short) 0x90AB, (short) 0x5678, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 0, 3));\n    assertArrayEquals(new short[] { (short) 0xCDEF, (short) 0x90AB, (short) 0x5678, (short) 0x1234 }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 0, 4));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xCDEF, (short) 0x90AB, (short) 0x5678 }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 1, 3));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xCDEF, (short) 0x90AB }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 2, 2));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xCDEF, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xFFFF, (short) 0xCDEF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 0, new short[] { -1, -1, -1, -1 }, 3, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xE6F7, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 1, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xF37B, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 2, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0x79BD, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 3, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xFFFF, (short) 0xFFFF, (short) 0xBCDE, (short) 0xFFFF }, Conversion.longToShortArray(0x1234567890ABCDEFL, 4, new short[] { -1, -1, -1, -1 }, 2, 1));\n    assertArrayEquals(new short[] { (short) 0xE6F7, (short) 0x4855, (short) 0x2B3C, (short) 0x091A }, Conversion.longToShortArray(0x1234567890ABCDEFL, 1, new short[] { -1, -1, -1, -1 }, 0, 4));\n    assertArrayEquals(new short[] { (short) 0x2B3C }, Conversion.longToShortArray(0x1234567890ABCDEFL, 33, new short[] { 0 }, 0, 1));\n}",
      "Method_name": "testLongToShortArray",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[longToShortArray(5), longToShortArray(5), longToShortArray(5), longToShortArray(5), longToShortArray(5), longToShortArray(5), longToShortArray(5), longToShortArray(5), longToShortArray(5), longToShortArray(5), longToShortArray(5), longToShortArray(5), longToShortArray(5), longToShortArray(5), longToShortArray(5), longToShortArray(5), longToShortArray(5), longToShortArray(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testLongToShortArray",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testLongToShortArray() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#longToShortArray(long, int, short[], int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes) {\n    if (0 == nBytes) {\n        return dst;\n    }\n    if ((nBytes - 1) * 8 + srcPos >= 16) {\n        throw new IllegalArgumentException(\"(nBytes-1)*8+srcPos is greater or equal to than 16\");\n    }\n    for (int i = 0; i < nBytes; i++) {\n        final int shift = i * 8 + srcPos;\n        dst[dstPos + i] = (byte) (0xff & (src >> shift));\n    }\n    return dst;\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "short,int,byte[],int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "shortToByteArray(final short src, final int srcPos, final byte() dst, final int dstPos, final int nBytes)",
      "Method_name": "shortToByteArray",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###shortToByteArray",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts a short into an array of byte using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the short to convert\n     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n     * @param dst the destination array\n     * @param dstPos the position in {@code dst} where to copy the result\n     * @param nBytes the number of bytes to copy to {@code dst}, must be smaller or equal to the\n     *            width of the input (from srcPos to msb)\n     * @return {@code dst}\n     * @throws NullPointerException if {@code dst} is {@code null}\n     * @throws IllegalArgumentException if {@code (nBytes-1)*8+srcPos >= 16}\n     * @throws ArrayIndexOutOfBoundsException if {@code dstPos + nBytes > dst.length}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);",
      "Junit_version": "4",
      "returnType": "byte[]"
    },
    "Test_method": {
      "Method_body": "assertArrayEquals(new byte[] {}, Conversion.shortToByteArray((short) 0x0000, 0, new byte[] {}, 0, 0));\n\rassertArrayEquals(new byte[] {}, Conversion.shortToByteArray((short) 0x0000, 100, new byte[] {}, 0, 0));\n\rassertArrayEquals(new byte[] {}, Conversion.shortToByteArray((short) 0x0000, 0, new byte[] {}, 100, 0));\n\rassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 0, 0));\n\rassertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n\rassertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 0, 2));\n\rassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 3, 1));\n\rassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 3, 2));\n\rassertArrayEquals(new byte[] { (byte) 0xF7, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 1, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n\rassertArrayEquals(new byte[] { (byte) 0x7B, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 2, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n\rassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x6F, (byte) 0xFE, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 5, new byte[] { -1, 0, -1, -1, -1, -1, -1 }, 3, 2));\n\r// assertArrayEquals(new\n// byte[]{(byte)0xFF,(byte)0x00,(byte)0xFF,(byte)0x5E,(byte)0xFF,(byte)0xFF,(byte)0xFF},Conversion.shortToByteArray((short)0xCDEF,13,new\n// byte[]{-1, 0,-1,-1,-1,-1,-1},3,2));//rejected by assertion\nassertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0xFE, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 13, new byte[] { -1, 0, -1, -1, -1, -1, -1 }, 3, 1));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "12",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertArrayEquals;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#shortToByteArray(short, int, byte[], int, int)}.\n */\n@Test\npublic void testShortToByteArray() {\n    assertArrayEquals(new byte[] {}, Conversion.shortToByteArray((short) 0x0000, 0, new byte[] {}, 0, 0));\n    assertArrayEquals(new byte[] {}, Conversion.shortToByteArray((short) 0x0000, 100, new byte[] {}, 0, 0));\n    assertArrayEquals(new byte[] {}, Conversion.shortToByteArray((short) 0x0000, 0, new byte[] {}, 100, 0));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 0, 0));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 0, 2));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 3, 1));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xEF, (byte) 0xCD, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 0, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 3, 2));\n    assertArrayEquals(new byte[] { (byte) 0xF7, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 1, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0x7B, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 2, new byte[] { -1, -1, -1, -1, -1, -1, -1 }, 0, 1));\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0x6F, (byte) 0xFE, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 5, new byte[] { -1, 0, -1, -1, -1, -1, -1 }, 3, 2));\n    // assertArrayEquals(new\n    // byte[]{(byte)0xFF,(byte)0x00,(byte)0xFF,(byte)0x5E,(byte)0xFF,(byte)0xFF,(byte)0xFF},Conversion.shortToByteArray((short)0xCDEF,13,new\n    // byte[]{-1, 0,-1,-1,-1,-1,-1},3,2));//rejected by assertion\n    assertArrayEquals(new byte[] { (byte) 0xFF, (byte) 0x00, (byte) 0xFF, (byte) 0xFE, (byte) 0xFF, (byte) 0xFF, (byte) 0xFF }, Conversion.shortToByteArray((short) 0xCDEF, 13, new byte[] { -1, 0, -1, -1, -1, -1, -1 }, 3, 1));\n}",
      "Method_name": "testShortToByteArray",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[shortToByteArray(5), shortToByteArray(5), shortToByteArray(5), shortToByteArray(5), shortToByteArray(5), shortToByteArray(5), shortToByteArray(5), shortToByteArray(5), shortToByteArray(5), shortToByteArray(5), shortToByteArray(5), shortToByteArray(5)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testShortToByteArray",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testShortToByteArray() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#shortToByteArray(short, int, byte[], int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs) {\n    if (0 == nHexs) {\n        return dstInit;\n    }\n    if ((nHexs - 1) * 4 + srcPos >= 16) {\n        throw new IllegalArgumentException(\"(nHexs-1)*4+srcPos is greater or equal to than 16\");\n    }\n    final StringBuilder sb = new StringBuilder(dstInit);\n    int append = sb.length();\n    for (int i = 0; i < nHexs; i++) {\n        final int shift = i * 4 + srcPos;\n        final int bits = 0xF & (src >> shift);\n        if (dstPos + i == append) {\n            ++append;\n            sb.append(intToHexDigit(bits));\n        } else {\n            sb.setCharAt(dstPos + i, intToHexDigit(bits));\n        }\n    }\n    return sb.toString();\n}",
      "all_field_declaration": "",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "6",
      "Filed": "",
      "Parameter_type": "short,int,String,int,int",
      "Import_statements": "",
      "public_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "public_field": "",
      "Method_statement": "shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs)",
      "Method_name": "shortToHex",
      "Class_declaration": "public class Conversion {\n",
      "constructors": "",
      "all_method_signature": "public static int hexDigitToInt(final char hexDigit);\npublic static int hexDigitMsb0ToInt(final char hexDigit);\npublic static boolean[] hexDigitToBinary(final char hexDigit);\npublic static boolean[] hexDigitMsb0ToBinary(final char hexDigit);\npublic static char binaryToHexDigit(final boolean[] src);\npublic static char binaryToHexDigit(final boolean[] src, final int srcPos);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src);\npublic static char binaryToHexDigitMsb0_4bits(final boolean[] src, final int srcPos);\npublic static char binaryBeMsb0ToHexDigit(final boolean[] src);\npublic static char binaryBeMsb0ToHexDigit(boolean[] src, int srcPos);\npublic static char intToHexDigit(final int nibble);\npublic static char intToHexDigitMsb0(final int nibble);\npublic static long intArrayToLong(final int[] src, final int srcPos, final long dstInit, final int dstPos, final int nInts);\npublic static long shortArrayToLong(final short[] src, final int srcPos, final long dstInit, final int dstPos, final int nShorts);\npublic static int shortArrayToInt(final short[] src, final int srcPos, final int dstInit, final int dstPos, final int nShorts);\npublic static long byteArrayToLong(final byte[] src, final int srcPos, final long dstInit, final int dstPos, final int nBytes);\npublic static int byteArrayToInt(final byte[] src, final int srcPos, final int dstInit, final int dstPos, final int nBytes);\npublic static short byteArrayToShort(final byte[] src, final int srcPos, final short dstInit, final int dstPos, final int nBytes);\npublic static long hexToLong(final String src, final int srcPos, final long dstInit, final int dstPos, final int nHex);\npublic static int hexToInt(final String src, final int srcPos, final int dstInit, final int dstPos, final int nHex);\npublic static short hexToShort(final String src, final int srcPos, final short dstInit, final int dstPos, final int nHex);\npublic static byte hexToByte(final String src, final int srcPos, final byte dstInit, final int dstPos, final int nHex);\npublic static long binaryToLong(final boolean[] src, final int srcPos, final long dstInit, final int dstPos, final int nBools);\npublic static int binaryToInt(final boolean[] src, final int srcPos, final int dstInit, final int dstPos, final int nBools);\npublic static short binaryToShort(final boolean[] src, final int srcPos, final short dstInit, final int dstPos, final int nBools);\npublic static byte binaryToByte(final boolean[] src, final int srcPos, final byte dstInit, final int dstPos, final int nBools);\npublic static int[] longToIntArray(final long src, final int srcPos, final int[] dst, final int dstPos, final int nInts);\npublic static short[] longToShortArray(final long src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static short[] intToShortArray(final int src, final int srcPos, final short[] dst, final int dstPos, final int nShorts);\npublic static byte[] longToByteArray(final long src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] intToByteArray(final int src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static byte[] shortToByteArray(final short src, final int srcPos, final byte[] dst, final int dstPos, final int nBytes);\npublic static String longToHex(final long src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String intToHex(final int src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static String byteToHex(final byte src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);\npublic static boolean[] longToBinary(final long src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] intToBinary(final int src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] shortToBinary(final short src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static boolean[] byteToBinary(final byte src, final int srcPos, final boolean[] dst, final int dstPos, final int nBools);\npublic static byte[] uuidToByteArray(final UUID src, final byte[] dst, final int dstPos, final int nBytes);\npublic static UUID byteArrayToUuid(final byte[] src, final int srcPos);",
      "Class_name": "Conversion",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/Conversion###shortToHex",
      "Parameter_num": "5",
      "all_Import_statements": "import java.util.UUID;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>\n     * Converts a short into an array of Char using the default (little endian, Lsb0) byte and\n     * bit ordering.\n     * </p>\n     *\n     * @param src the short to convert\n     * @param srcPos the position in {@code src}, in bits, from where to start the conversion\n     * @param dstInit the initial value for the result String\n     * @param dstPos the position in {@code dst} where to copy the result\n     * @param nHexs the number of Chars to copy to {@code dst}, must be smaller or equal to the\n     *            width of the input (from srcPos to msb)\n     * @return {@code dst}\n     * @throws IllegalArgumentException if {@code (nHexs-1)*4+srcPos >= 16}\n     * @throws StringIndexOutOfBoundsException if {@code dst.init.length() < dstPos}\n     ",
      "packageName": "org.apache.commons.lang3",
      "method_signature": "public static String shortToHex(final short src, final int srcPos, final String dstInit, final int dstPos, final int nHexs);",
      "Junit_version": "4",
      "returnType": "String"
    },
    "Test_method": {
      "Method_body": "assertEquals(\"\", Conversion.shortToHex((short) 0x0000, 0, \"\", 0, 0));\n\rassertEquals(\"\", Conversion.shortToHex((short) 0x0000, 100, \"\", 0, 0));\n\rassertEquals(\"\", Conversion.shortToHex((short) 0x0000, 0, \"\", 100, 0));\n\rassertEquals(\"ffffffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 0, \"ffffffffffffffffffffffff\", 0, 0));\n\rassertEquals(\"3fffffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDE3, 0, \"ffffffffffffffffffffffff\", 0, 1));\n\rassertEquals(\"feffffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 0, \"ffffffffffffffffffffffff\", 0, 2));\n\rassertEquals(\"fedfffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 0, \"ffffffffffffffffffffffff\", 0, 3));\n\rassertEquals(\"fedcffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 0, \"ffffffffffffffffffffffff\", 0, 4));\n\rassertEquals(\"fff3ffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDE3, 0, \"ffffffffffffffffffffffff\", 3, 1));\n\rassertEquals(\"ffffefffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 0, \"ffffffffffffffffffffffff\", 3, 2));\n\rassertEquals(\"7fffffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 1, \"ffffffffffffffffffffffff\", 0, 1));\n\rassertEquals(\"bfffffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 2, \"ffffffffffffffffffffffff\", 0, 1));\n\rassertEquals(\"fffdb9ffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 3, \"ffffffffffffffffffffffff\", 3, 4));\n\r// assertEquals(\"ffffffffffffffffffffffff\",Conversion.shortToHex((short)0xCDEF,\n// 4,\"ffffffffffffffffffffffff\",3,4));//rejected by assertion\nassertEquals(\"fffedcffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 4, \"ffffffffffffffffffffffff\", 3, 3));\n\rassertEquals(\"fedc\", Conversion.shortToHex((short) 0xCDEF, 0, \"\", 0, 4));\n\rtry {\n    Conversion.shortToHex((short) 0xCDEF, 0, \"\", 1, 4);\n    fail(\"Thrown \" + StringIndexOutOfBoundsException.class.getName() + \" expected\");\n} catch (final StringIndexOutOfBoundsException e) {\n    // OK\n}",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "16",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\n",
      "allMethod_info": "/**\n * Tests {@link Conversion#shortToHex(short, int, String, int, int)}.\n */\n@Test\npublic void testShortToHex() {\n    assertEquals(\"\", Conversion.shortToHex((short) 0x0000, 0, \"\", 0, 0));\n    assertEquals(\"\", Conversion.shortToHex((short) 0x0000, 100, \"\", 0, 0));\n    assertEquals(\"\", Conversion.shortToHex((short) 0x0000, 0, \"\", 100, 0));\n    assertEquals(\"ffffffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 0, \"ffffffffffffffffffffffff\", 0, 0));\n    assertEquals(\"3fffffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDE3, 0, \"ffffffffffffffffffffffff\", 0, 1));\n    assertEquals(\"feffffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 0, \"ffffffffffffffffffffffff\", 0, 2));\n    assertEquals(\"fedfffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 0, \"ffffffffffffffffffffffff\", 0, 3));\n    assertEquals(\"fedcffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 0, \"ffffffffffffffffffffffff\", 0, 4));\n    assertEquals(\"fff3ffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDE3, 0, \"ffffffffffffffffffffffff\", 3, 1));\n    assertEquals(\"ffffefffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 0, \"ffffffffffffffffffffffff\", 3, 2));\n    assertEquals(\"7fffffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 1, \"ffffffffffffffffffffffff\", 0, 1));\n    assertEquals(\"bfffffffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 2, \"ffffffffffffffffffffffff\", 0, 1));\n    assertEquals(\"fffdb9ffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 3, \"ffffffffffffffffffffffff\", 3, 4));\n    // assertEquals(\"ffffffffffffffffffffffff\",Conversion.shortToHex((short)0xCDEF,\n    // 4,\"ffffffffffffffffffffffff\",3,4));//rejected by assertion\n    assertEquals(\"fffedcffffffffffffffffff\", Conversion.shortToHex((short) 0xCDEF, 4, \"ffffffffffffffffffffffff\", 3, 3));\n    assertEquals(\"fedc\", Conversion.shortToHex((short) 0xCDEF, 0, \"\", 0, 4));\n    try {\n        Conversion.shortToHex((short) 0xCDEF, 0, \"\", 1, 4);\n        fail(\"Thrown \" + StringIndexOutOfBoundsException.class.getName() + \" expected\");\n    } catch (final StringIndexOutOfBoundsException e) {\n        // OK\n    }\n}",
      "Method_name": "testShortToHex",
      "Class_declaration": "public class ConversionTest {\n",
      "constructors": "",
      "Class_name": "ConversionTest",
      "methodName_paraNum": "[shortToHex(5), shortToHex(5), shortToHex(5), shortToHex(5), shortToHex(5), shortToHex(5), shortToHex(5), shortToHex(5), shortToHex(5), shortToHex(5), shortToHex(5), shortToHex(5), shortToHex(5), shortToHex(5), shortToHex(5), shortToHex(5), fail(1), getName(0)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest###testShortToHex",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/ConversionTest.java",
      "Signature": "public void testShortToHex() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.fail;\n\nimport java.util.UUID;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests {@link Conversion#shortToHex(short, int, String, int, int)}.\n     ",
      "packageName": "org.apache.commons.lang3",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "protected <C, T> Stage<T> doCollect(final Collection<? extends Stage<? extends C>> stages, final Function<? super Collection<C>, ? extends T> collector) {\n    final Completable<T> target = completable();\n    final CollectHelper<? super C, ? extends T> done = new CollectHelper<>(stages.size(), collector, stages, target);\n    for (final Stage<? extends C> q : stages) {\n        q.handle(done);\n    }\n    bindSignals(target, stages);\n    return target;\n}",
      "all_field_declaration": "private static final Collection<Object> EMPTY_RESULTS = Collections.emptyList();\n/**\n * Default executor to use when resolving asynchronously.\n */\nprivate final ExecutorService executor;\nprivate final ScheduledExecutorService scheduler;\n/**\n * Default set of helper functions for calling callbacks.\n */\n@NonNull\nprivate final Caller caller;\n@NonNull\nprivate final ClockSource clockSource;\n@NonNull\nprivate final ManagedOptions managedOptions;",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "Collection<? extends Stage<? extends C>>,Function<? super Collection<C>, ? extends T>",
      "Import_statements": "import java.util.Collection;\nimport java.util.function.Function;\n",
      "public_method_signature": "public ExecutorService executor();\npublic Caller caller();\npublic Stage<C> call(final Callable<? extends C> callable);\npublic Stage<C> call(final Callable<? extends C> callable, final ExecutorService executor);\npublic Stage<C> doCall(final Callable<? extends C> callable, final ExecutorService executor, final Completable<C> stage);\npublic Completable<T> completable();\npublic Stage<Void> completed();\npublic Stage<T> completed(T value);\npublic Stage<T> failed(Throwable e);\npublic Stage<T> cancelled();\npublic Stage<Collection<T>> collect(final Collection<? extends Stage<? extends T>> stages);\npublic Stage<T> collect(final Collection<? extends Stage<? extends C>> stages, final Function<? super Collection<C>, ? extends T> collector);\npublic Stage<U> streamCollect(final Collection<? extends Stage<? extends T>> stages, final Consumer<? super T> consumer, final Supplier<? extends U> supplier);\npublic Stage<T> eventuallyCollect(final Collection<? extends Callable<? extends Stage<? extends C>>> callables, final Consumer<? super C> consumer, Supplier<? extends T> supplier, int parallelism);\npublic Stage<Void> collectAndDiscard(Collection<? extends Stage<?>> stages);\npublic Managed<C> managed(Supplier<? extends Stage<C>> setup, Function<? super C, ? extends Stage<Void>> teardown);\npublic ReloadableManaged<C> reloadableManaged(final Supplier<? extends Stage<C>> setup, final Function<? super C, ? extends Stage<Void>> teardown);\npublic Stage<RetryResult<T>> retryUntilCompleted(final Callable<? extends Stage<T>> callable, final RetryPolicy policy);\npublic Stage<RetryResult<T>> retryUntilCompleted(final Callable<? extends Stage<T>> callable, final RetryPolicy policy, final ClockSource clockSource);\npublic static Builder builder();",
      "public_field": "",
      "Method_statement": "doCollect(final Collection<? extends Stage<? extends C>> stages, final Function<? super Collection<C>, ? extends T> collector)",
      "Method_name": "doCollect",
      "Class_declaration": "public class CoreAsync {\n",
      "constructors": "",
      "all_method_signature": "public ExecutorService executor();\npublic Caller caller();\npublic Stage<C> call(final Callable<? extends C> callable);\npublic Stage<C> call(final Callable<? extends C> callable, final ExecutorService executor);\npublic Stage<C> doCall(final Callable<? extends C> callable, final ExecutorService executor, final Completable<C> stage);\npublic Completable<T> completable();\npublic Stage<Void> completed();\npublic Stage<T> completed(T value);\npublic Stage<T> failed(Throwable e);\npublic Stage<T> cancelled();\npublic Stage<Collection<T>> collect(final Collection<? extends Stage<? extends T>> stages);\npublic Stage<T> collect(final Collection<? extends Stage<? extends C>> stages, final Function<? super Collection<C>, ? extends T> collector);\nprotected Stage<T> doCollect(final Collection<? extends Stage<? extends C>> stages, final Function<? super Collection<C>, ? extends T> collector);\n Stage<T> doCollectEmpty(final Function<? super Collection<C>, ? extends T> collector);\npublic Stage<U> streamCollect(final Collection<? extends Stage<? extends T>> stages, final Consumer<? super T> consumer, final Supplier<? extends U> supplier);\n Stage<U> doStreamCollectEmpty(final Consumer<? super T> consumer, final Supplier<? extends U> supplier);\n Stage<U> doStreamCollect(final Collection<? extends Stage<? extends T>> stages, final Consumer<? super T> consumer, final Supplier<? extends U> supplier);\npublic Stage<T> eventuallyCollect(final Collection<? extends Callable<? extends Stage<? extends C>>> callables, final Consumer<? super C> consumer, Supplier<? extends T> supplier, int parallelism);\n Stage<T> doEventuallyCollectEmpty(final Consumer<? super C> consumer, Supplier<? extends T> supplier);\n Stage<T> doEventuallyCollectImmediate(final Collection<? extends Callable<? extends Stage<? extends C>>> callables, final Consumer<? super C> consumer, Supplier<? extends T> supplier);\n Stage<U> doEventuallyCollect(final Collection<? extends Callable<? extends Stage<? extends T>>> tasks, final Consumer<? super T> consumer, Supplier<? extends U> supplier, int parallelism);\npublic Stage<Void> collectAndDiscard(Collection<? extends Stage<?>> stages);\n Stage<Void> doCollectAndDiscard(Collection<? extends Stage<?>> stages);\npublic Managed<C> managed(Supplier<? extends Stage<C>> setup, Function<? super C, ? extends Stage<Void>> teardown);\npublic ReloadableManaged<C> reloadableManaged(final Supplier<? extends Stage<C>> setup, final Function<? super C, ? extends Stage<Void>> teardown);\n void bindSignals(final Stage<?> target, final Collection<? extends Stage<?>> stages);\npublic Stage<RetryResult<T>> retryUntilCompleted(final Callable<? extends Stage<T>> callable, final RetryPolicy policy);\npublic Stage<RetryResult<T>> retryUntilCompleted(final Callable<? extends Stage<T>> callable, final RetryPolicy policy, final ClockSource clockSource);\n static String formatStack(final Stream<StackTraceElement> stack, final String prefix);\n static Throwable buildCollectedException(Collection<Throwable> errors);\npublic static Builder builder();",
      "Class_name": "CoreAsync",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/main/java/eu/toolchain/concurrent/CoreAsync###doCollect",
      "Parameter_num": "2",
      "all_Import_statements": "import java.util.ArrayList;\n\nimport java.util.Collection;\n\nimport java.util.Collections;\n\nimport java.util.Iterator;\n\nimport java.util.List;\n\nimport java.util.Objects;\n\nimport java.util.StringJoiner;\n\nimport java.util.concurrent.Callable;\n\nimport java.util.concurrent.ExecutorService;\n\nimport java.util.concurrent.Future;\n\nimport java.util.concurrent.ScheduledExecutorService;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport java.util.stream.Stream;\n\nimport lombok.NonNull;\n\nimport lombok.RequiredArgsConstructor;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "method_signature": "protected Stage<T> doCollect(final Collection<? extends Stage<? extends C>> stages, final Function<? super Collection<C>, ? extends T> collector);",
      "Junit_version": "4",
      "returnType": "Stage<T>"
    },
    "Test_method": {
      "Method_body": "final Collection<Stage<Object>> futures = ImmutableList.of(f1, f2);\n\rdoReturn(completable).when(underTest).completable();\n\rdoNothing().when(underTest).bindSignals(completable, futures);\n\rassertEquals(completable, underTest.doCollect(futures, collector));\n\rverify(underTest).completable();\n\rverify(underTest).bindSignals(completable, futures);\n\rverify(f1).handle(any(CollectHelper.class));\n\rverify(f2).handle(any(CollectHelper.class));",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "8",
      "Filed": "private static final RuntimeException e = new RuntimeException();@Mock\nprivate Function<Collection<Object>, Object> collector;@Mock\nprivate Completable<Object> completable;@Mock\nprivate Stage<Object> future;@Mock\nprivate Stage<Object> f1;@Mock\nprivate Stage<Object> f2;@Mock\nprivate Callable<Stage<Object>> c;@Mock\nprivate List<Stage<Object>> futures;private CoreAsync underTest;",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Mockito.doNothing;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\nimport com.google.common.collect.ImmutableList;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.Test;\n",
      "allMethod_info": "@SuppressWarnings(\"unchecked\")\n@Test\npublic void testDoCollect() throws Exception {\n    final Collection<Stage<Object>> futures = ImmutableList.of(f1, f2);\n    doReturn(completable).when(underTest).completable();\n    doNothing().when(underTest).bindSignals(completable, futures);\n    assertEquals(completable, underTest.doCollect(futures, collector));\n    verify(underTest).completable();\n    verify(underTest).bindSignals(completable, futures);\n    verify(f1).handle(any(CollectHelper.class));\n    verify(f2).handle(any(CollectHelper.class));\n}",
      "Method_name": "testDoCollect",
      "Class_declaration": "public class CoreAsyncTest {\n",
      "constructors": "",
      "Class_name": "CoreAsyncTest",
      "methodName_paraNum": "[of(2), completable(0), when(1), doReturn(1), bindSignals(2), when(1), doNothing(0), doCollect(2), completable(0), verify(1), bindSignals(2), verify(1), handle(1), verify(1), any(1), handle(1), verify(1), any(1)]",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/CoreAsyncTest###testDoCollect",
      "relativePath": "udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/CoreAsyncTest.java",
      "Signature": "public void testDoCollect() {\n",
      "all_Import_statements": "import static eu.toolchain.concurrent.CoreAsync.buildCollectedException;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.mockito.Matchers.any;\n\nimport static org.mockito.Matchers.anyCollection;\n\nimport static org.mockito.Matchers.eq;\n\nimport static org.mockito.Mockito.doAnswer;\n\nimport static org.mockito.Mockito.doNothing;\n\nimport static org.mockito.Mockito.doReturn;\n\nimport static org.mockito.Mockito.doThrow;\n\nimport static org.mockito.Mockito.inOrder;\n\nimport static org.mockito.Mockito.mock;\n\nimport static org.mockito.Mockito.never;\n\nimport static org.mockito.Mockito.spy;\n\nimport static org.mockito.Mockito.times;\n\nimport static org.mockito.Mockito.verify;\n\nimport static org.mockito.Mockito.when;\n\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.ArrayList;\n\nimport java.util.Collection;\n\nimport java.util.List;\n\nimport java.util.concurrent.Callable;\n\nimport java.util.concurrent.ExecutorService;\n\nimport java.util.concurrent.Future;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport org.junit.Before;\n\nimport org.junit.Rule;\n\nimport org.junit.Test;\n\nimport org.junit.rules.ExpectedException;\n\nimport org.junit.runner.RunWith;\n\nimport org.mockito.InOrder;\n\nimport org.mockito.Mock;\n\nimport org.mockito.invocation.InvocationOnMock;\n\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport org.mockito.stubbing.Answer;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "Stage<Void> doCollectAndDiscard(Collection<? extends Stage<?>> stages) {\n    final Completable<Void> target = completable();\n    final CollectAndDiscardHelper done = new CollectAndDiscardHelper(stages.size(), target);\n    for (final Stage<?> q : stages) {\n        q.handle(done);\n    }\n    bindSignals(target, stages);\n    return target;\n}",
      "all_field_declaration": "private static final Collection<Object> EMPTY_RESULTS = Collections.emptyList();\n/**\n * Default executor to use when resolving asynchronously.\n */\nprivate final ExecutorService executor;\nprivate final ScheduledExecutorService scheduler;\n/**\n * Default set of helper functions for calling callbacks.\n */\n@NonNull\nprivate final Caller caller;\n@NonNull\nprivate final ClockSource clockSource;\n@NonNull\nprivate final ManagedOptions managedOptions;",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "5",
      "Filed": "",
      "Parameter_type": "Collection<? extends Stage<?>>",
      "Import_statements": "import java.util.Collection;\n",
      "public_method_signature": "public ExecutorService executor();\npublic Caller caller();\npublic Stage<C> call(final Callable<? extends C> callable);\npublic Stage<C> call(final Callable<? extends C> callable, final ExecutorService executor);\npublic Stage<C> doCall(final Callable<? extends C> callable, final ExecutorService executor, final Completable<C> stage);\npublic Completable<T> completable();\npublic Stage<Void> completed();\npublic Stage<T> completed(T value);\npublic Stage<T> failed(Throwable e);\npublic Stage<T> cancelled();\npublic Stage<Collection<T>> collect(final Collection<? extends Stage<? extends T>> stages);\npublic Stage<T> collect(final Collection<? extends Stage<? extends C>> stages, final Function<? super Collection<C>, ? extends T> collector);\npublic Stage<U> streamCollect(final Collection<? extends Stage<? extends T>> stages, final Consumer<? super T> consumer, final Supplier<? extends U> supplier);\npublic Stage<T> eventuallyCollect(final Collection<? extends Callable<? extends Stage<? extends C>>> callables, final Consumer<? super C> consumer, Supplier<? extends T> supplier, int parallelism);\npublic Stage<Void> collectAndDiscard(Collection<? extends Stage<?>> stages);\npublic Managed<C> managed(Supplier<? extends Stage<C>> setup, Function<? super C, ? extends Stage<Void>> teardown);\npublic ReloadableManaged<C> reloadableManaged(final Supplier<? extends Stage<C>> setup, final Function<? super C, ? extends Stage<Void>> teardown);\npublic Stage<RetryResult<T>> retryUntilCompleted(final Callable<? extends Stage<T>> callable, final RetryPolicy policy);\npublic Stage<RetryResult<T>> retryUntilCompleted(final Callable<? extends Stage<T>> callable, final RetryPolicy policy, final ClockSource clockSource);\npublic static Builder builder();",
      "public_field": "",
      "Method_statement": "doCollectAndDiscard(Collection<? extends Stage<?>> stages)",
      "Method_name": "doCollectAndDiscard",
      "Class_declaration": "public class CoreAsync {\n",
      "constructors": "",
      "all_method_signature": "public ExecutorService executor();\npublic Caller caller();\npublic Stage<C> call(final Callable<? extends C> callable);\npublic Stage<C> call(final Callable<? extends C> callable, final ExecutorService executor);\npublic Stage<C> doCall(final Callable<? extends C> callable, final ExecutorService executor, final Completable<C> stage);\npublic Completable<T> completable();\npublic Stage<Void> completed();\npublic Stage<T> completed(T value);\npublic Stage<T> failed(Throwable e);\npublic Stage<T> cancelled();\npublic Stage<Collection<T>> collect(final Collection<? extends Stage<? extends T>> stages);\npublic Stage<T> collect(final Collection<? extends Stage<? extends C>> stages, final Function<? super Collection<C>, ? extends T> collector);\nprotected Stage<T> doCollect(final Collection<? extends Stage<? extends C>> stages, final Function<? super Collection<C>, ? extends T> collector);\n Stage<T> doCollectEmpty(final Function<? super Collection<C>, ? extends T> collector);\npublic Stage<U> streamCollect(final Collection<? extends Stage<? extends T>> stages, final Consumer<? super T> consumer, final Supplier<? extends U> supplier);\n Stage<U> doStreamCollectEmpty(final Consumer<? super T> consumer, final Supplier<? extends U> supplier);\n Stage<U> doStreamCollect(final Collection<? extends Stage<? extends T>> stages, final Consumer<? super T> consumer, final Supplier<? extends U> supplier);\npublic Stage<T> eventuallyCollect(final Collection<? extends Callable<? extends Stage<? extends C>>> callables, final Consumer<? super C> consumer, Supplier<? extends T> supplier, int parallelism);\n Stage<T> doEventuallyCollectEmpty(final Consumer<? super C> consumer, Supplier<? extends T> supplier);\n Stage<T> doEventuallyCollectImmediate(final Collection<? extends Callable<? extends Stage<? extends C>>> callables, final Consumer<? super C> consumer, Supplier<? extends T> supplier);\n Stage<U> doEventuallyCollect(final Collection<? extends Callable<? extends Stage<? extends T>>> tasks, final Consumer<? super T> consumer, Supplier<? extends U> supplier, int parallelism);\npublic Stage<Void> collectAndDiscard(Collection<? extends Stage<?>> stages);\n Stage<Void> doCollectAndDiscard(Collection<? extends Stage<?>> stages);\npublic Managed<C> managed(Supplier<? extends Stage<C>> setup, Function<? super C, ? extends Stage<Void>> teardown);\npublic ReloadableManaged<C> reloadableManaged(final Supplier<? extends Stage<C>> setup, final Function<? super C, ? extends Stage<Void>> teardown);\n void bindSignals(final Stage<?> target, final Collection<? extends Stage<?>> stages);\npublic Stage<RetryResult<T>> retryUntilCompleted(final Callable<? extends Stage<T>> callable, final RetryPolicy policy);\npublic Stage<RetryResult<T>> retryUntilCompleted(final Callable<? extends Stage<T>> callable, final RetryPolicy policy, final ClockSource clockSource);\n static String formatStack(final Stream<StackTraceElement> stack, final String prefix);\n static Throwable buildCollectedException(Collection<Throwable> errors);\npublic static Builder builder();",
      "Class_name": "CoreAsync",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/main/java/eu/toolchain/concurrent/CoreAsync###doCollectAndDiscard",
      "Parameter_num": "1",
      "all_Import_statements": "import java.util.ArrayList;\n\nimport java.util.Collection;\n\nimport java.util.Collections;\n\nimport java.util.Iterator;\n\nimport java.util.List;\n\nimport java.util.Objects;\n\nimport java.util.StringJoiner;\n\nimport java.util.concurrent.Callable;\n\nimport java.util.concurrent.ExecutorService;\n\nimport java.util.concurrent.Future;\n\nimport java.util.concurrent.ScheduledExecutorService;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport java.util.stream.Stream;\n\nimport lombok.NonNull;\n\nimport lombok.RequiredArgsConstructor;\n",
      "comment": "\n   * Perform a collect and discard.\n   *\n   * @param stages stages to discard\n   * @return a completable\n   ",
      "packageName": "eu.toolchain.concurrent",
      "method_signature": " Stage<Void> doCollectAndDiscard(Collection<? extends Stage<?>> stages);",
      "Junit_version": "4",
      "returnType": "Stage<Void>"
    },
    "Test_method": {
      "Method_body": "final Collection<Stage<Object>> futures = ImmutableList.of(f1, f2);\n\rdoReturn(completable).when(underTest).completable();\n\rdoNothing().when(underTest).bindSignals(completable, futures);\n\rassertEquals(completable, underTest.doCollectAndDiscard(futures));\n\rverify(underTest).completable();\n\rverify(underTest).bindSignals(completable, futures);\n\rverify(f1).handle(any(CollectAndDiscardHelper.class));\n\rverify(f2).handle(any(CollectAndDiscardHelper.class));",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "8",
      "Filed": "private static final RuntimeException e = new RuntimeException();@Mock\nprivate Completable<Object> completable;@Mock\nprivate Stage<Object> future;@Mock\nprivate Stage<Object> f1;@Mock\nprivate Stage<Object> f2;@Mock\nprivate Callable<Stage<Object>> c;@Mock\nprivate List<Stage<Object>> futures;private CoreAsync underTest;",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Mockito.doNothing;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\nimport com.google.common.collect.ImmutableList;\nimport java.util.Collection;\nimport java.util.List;\nimport org.junit.Test;\n",
      "allMethod_info": "@SuppressWarnings(\"unchecked\")\n@Test\npublic void testDoCollectAndDiscard() throws Exception {\n    final Collection<Stage<Object>> futures = ImmutableList.of(f1, f2);\n    doReturn(completable).when(underTest).completable();\n    doNothing().when(underTest).bindSignals(completable, futures);\n    assertEquals(completable, underTest.doCollectAndDiscard(futures));\n    verify(underTest).completable();\n    verify(underTest).bindSignals(completable, futures);\n    verify(f1).handle(any(CollectAndDiscardHelper.class));\n    verify(f2).handle(any(CollectAndDiscardHelper.class));\n}",
      "Method_name": "testDoCollectAndDiscard",
      "Class_declaration": "public class CoreAsyncTest {\n",
      "constructors": "",
      "Class_name": "CoreAsyncTest",
      "methodName_paraNum": "[of(2), completable(0), when(1), doReturn(1), bindSignals(2), when(1), doNothing(0), doCollectAndDiscard(1), completable(0), verify(1), bindSignals(2), verify(1), handle(1), verify(1), any(1), handle(1), verify(1), any(1)]",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/CoreAsyncTest###testDoCollectAndDiscard",
      "relativePath": "udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/CoreAsyncTest.java",
      "Signature": "public void testDoCollectAndDiscard() {\n",
      "all_Import_statements": "import static eu.toolchain.concurrent.CoreAsync.buildCollectedException;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.mockito.Matchers.any;\n\nimport static org.mockito.Matchers.anyCollection;\n\nimport static org.mockito.Matchers.eq;\n\nimport static org.mockito.Mockito.doAnswer;\n\nimport static org.mockito.Mockito.doNothing;\n\nimport static org.mockito.Mockito.doReturn;\n\nimport static org.mockito.Mockito.doThrow;\n\nimport static org.mockito.Mockito.inOrder;\n\nimport static org.mockito.Mockito.mock;\n\nimport static org.mockito.Mockito.never;\n\nimport static org.mockito.Mockito.spy;\n\nimport static org.mockito.Mockito.times;\n\nimport static org.mockito.Mockito.verify;\n\nimport static org.mockito.Mockito.when;\n\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.ArrayList;\n\nimport java.util.Collection;\n\nimport java.util.List;\n\nimport java.util.concurrent.Callable;\n\nimport java.util.concurrent.ExecutorService;\n\nimport java.util.concurrent.Future;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport org.junit.Before;\n\nimport org.junit.Rule;\n\nimport org.junit.Test;\n\nimport org.junit.rules.ExpectedException;\n\nimport org.junit.runner.RunWith;\n\nimport org.mockito.InOrder;\n\nimport org.mockito.Mock;\n\nimport org.mockito.invocation.InvocationOnMock;\n\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport org.mockito.stubbing.Answer;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "<T, U> Stage<U> doEventuallyCollect(final Collection<? extends Callable<? extends Stage<? extends T>>> tasks, final Consumer<? super T> consumer, Supplier<? extends U> supplier, int parallelism) {\n    final ExecutorService executor = executor();\n    final Completable<U> stage = completable();\n    executor.execute(new DelayedCollectCoordinator<>(caller, tasks, consumer, supplier, stage, parallelism));\n    return stage;\n}",
      "all_field_declaration": "private static final Collection<Object> EMPTY_RESULTS = Collections.emptyList();\n/**\n * Default executor to use when resolving asynchronously.\n */\nprivate final ExecutorService executor;\nprivate final ScheduledExecutorService scheduler;\n/**\n * Default set of helper functions for calling callbacks.\n */\n@NonNull\nprivate final Caller caller;\n@NonNull\nprivate final ClockSource clockSource;\n@NonNull\nprivate final ManagedOptions managedOptions;",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "4",
      "Filed": "private final ExecutorService executor;@NonNull\nprivate final Caller caller;",
      "Parameter_type": "Collection<? extends Callable<? extends Stage<? extends T>>>,Consumer<? super T>,Supplier<? extends U>,int",
      "Import_statements": "import java.util.Collection;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutorService;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n",
      "public_method_signature": "public ExecutorService executor();\npublic Caller caller();\npublic Stage<C> call(final Callable<? extends C> callable);\npublic Stage<C> call(final Callable<? extends C> callable, final ExecutorService executor);\npublic Stage<C> doCall(final Callable<? extends C> callable, final ExecutorService executor, final Completable<C> stage);\npublic Completable<T> completable();\npublic Stage<Void> completed();\npublic Stage<T> completed(T value);\npublic Stage<T> failed(Throwable e);\npublic Stage<T> cancelled();\npublic Stage<Collection<T>> collect(final Collection<? extends Stage<? extends T>> stages);\npublic Stage<T> collect(final Collection<? extends Stage<? extends C>> stages, final Function<? super Collection<C>, ? extends T> collector);\npublic Stage<U> streamCollect(final Collection<? extends Stage<? extends T>> stages, final Consumer<? super T> consumer, final Supplier<? extends U> supplier);\npublic Stage<T> eventuallyCollect(final Collection<? extends Callable<? extends Stage<? extends C>>> callables, final Consumer<? super C> consumer, Supplier<? extends T> supplier, int parallelism);\npublic Stage<Void> collectAndDiscard(Collection<? extends Stage<?>> stages);\npublic Managed<C> managed(Supplier<? extends Stage<C>> setup, Function<? super C, ? extends Stage<Void>> teardown);\npublic ReloadableManaged<C> reloadableManaged(final Supplier<? extends Stage<C>> setup, final Function<? super C, ? extends Stage<Void>> teardown);\npublic Stage<RetryResult<T>> retryUntilCompleted(final Callable<? extends Stage<T>> callable, final RetryPolicy policy);\npublic Stage<RetryResult<T>> retryUntilCompleted(final Callable<? extends Stage<T>> callable, final RetryPolicy policy, final ClockSource clockSource);\npublic static Builder builder();",
      "public_field": "",
      "Method_statement": "doEventuallyCollect(final Collection<? extends Callable<? extends Stage<? extends T>>> tasks, final Consumer<? super T> consumer, Supplier<? extends U> supplier, int parallelism)",
      "Method_name": "doEventuallyCollect",
      "Class_declaration": "public class CoreAsync {\n",
      "constructors": "",
      "all_method_signature": "public ExecutorService executor();\npublic Caller caller();\npublic Stage<C> call(final Callable<? extends C> callable);\npublic Stage<C> call(final Callable<? extends C> callable, final ExecutorService executor);\npublic Stage<C> doCall(final Callable<? extends C> callable, final ExecutorService executor, final Completable<C> stage);\npublic Completable<T> completable();\npublic Stage<Void> completed();\npublic Stage<T> completed(T value);\npublic Stage<T> failed(Throwable e);\npublic Stage<T> cancelled();\npublic Stage<Collection<T>> collect(final Collection<? extends Stage<? extends T>> stages);\npublic Stage<T> collect(final Collection<? extends Stage<? extends C>> stages, final Function<? super Collection<C>, ? extends T> collector);\nprotected Stage<T> doCollect(final Collection<? extends Stage<? extends C>> stages, final Function<? super Collection<C>, ? extends T> collector);\n Stage<T> doCollectEmpty(final Function<? super Collection<C>, ? extends T> collector);\npublic Stage<U> streamCollect(final Collection<? extends Stage<? extends T>> stages, final Consumer<? super T> consumer, final Supplier<? extends U> supplier);\n Stage<U> doStreamCollectEmpty(final Consumer<? super T> consumer, final Supplier<? extends U> supplier);\n Stage<U> doStreamCollect(final Collection<? extends Stage<? extends T>> stages, final Consumer<? super T> consumer, final Supplier<? extends U> supplier);\npublic Stage<T> eventuallyCollect(final Collection<? extends Callable<? extends Stage<? extends C>>> callables, final Consumer<? super C> consumer, Supplier<? extends T> supplier, int parallelism);\n Stage<T> doEventuallyCollectEmpty(final Consumer<? super C> consumer, Supplier<? extends T> supplier);\n Stage<T> doEventuallyCollectImmediate(final Collection<? extends Callable<? extends Stage<? extends C>>> callables, final Consumer<? super C> consumer, Supplier<? extends T> supplier);\n Stage<U> doEventuallyCollect(final Collection<? extends Callable<? extends Stage<? extends T>>> tasks, final Consumer<? super T> consumer, Supplier<? extends U> supplier, int parallelism);\npublic Stage<Void> collectAndDiscard(Collection<? extends Stage<?>> stages);\n Stage<Void> doCollectAndDiscard(Collection<? extends Stage<?>> stages);\npublic Managed<C> managed(Supplier<? extends Stage<C>> setup, Function<? super C, ? extends Stage<Void>> teardown);\npublic ReloadableManaged<C> reloadableManaged(final Supplier<? extends Stage<C>> setup, final Function<? super C, ? extends Stage<Void>> teardown);\n void bindSignals(final Stage<?> target, final Collection<? extends Stage<?>> stages);\npublic Stage<RetryResult<T>> retryUntilCompleted(final Callable<? extends Stage<T>> callable, final RetryPolicy policy);\npublic Stage<RetryResult<T>> retryUntilCompleted(final Callable<? extends Stage<T>> callable, final RetryPolicy policy, final ClockSource clockSource);\n static String formatStack(final Stream<StackTraceElement> stack, final String prefix);\n static Throwable buildCollectedException(Collection<Throwable> errors);\npublic static Builder builder();",
      "Class_name": "CoreAsync",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/main/java/eu/toolchain/concurrent/CoreAsync###doEventuallyCollect",
      "Parameter_num": "4",
      "all_Import_statements": "import java.util.ArrayList;\n\nimport java.util.Collection;\n\nimport java.util.Collections;\n\nimport java.util.Iterator;\n\nimport java.util.List;\n\nimport java.util.Objects;\n\nimport java.util.StringJoiner;\n\nimport java.util.concurrent.Callable;\n\nimport java.util.concurrent.ExecutorService;\n\nimport java.util.concurrent.Future;\n\nimport java.util.concurrent.ScheduledExecutorService;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport java.util.stream.Stream;\n\nimport lombok.NonNull;\n\nimport lombok.RequiredArgsConstructor;\n",
      "comment": "\n   * Perform an eventual collection.\n   *\n   * @param tasks tasks to invoke for stages\n   * @param consumer consumer to apply\n   * @param supplier supplier to provide result\n   * @param parallelism number of tasks to run in parallel\n   * @param <T> source type\n   * @param <U> target type\n   * @return a completable\n   ",
      "packageName": "eu.toolchain.concurrent",
      "method_signature": " Stage<U> doEventuallyCollect(final Collection<? extends Callable<? extends Stage<? extends T>>> tasks, final Consumer<? super T> consumer, Supplier<? extends U> supplier, int parallelism);",
      "Junit_version": "4",
      "returnType": "Stage<U>"
    },
    "Test_method": {
      "Method_body": "final List<Callable<Stage<Object>>> callables = ImmutableList.of(c, c2);\n\rdoReturn(executor).when(underTest).executor();\n\rdoReturn(completable).when(underTest).completable();\n\rassertEquals(completable, underTest.doEventuallyCollect(callables, consumer, supplier, 10));\n\rverify(executor).execute(any(DelayedCollectCoordinator.class));\n\rverify(underTest).executor();",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "6",
      "Filed": "private static final RuntimeException e = new RuntimeException();@Mock\nprivate ExecutorService executor;@Mock\nprivate Consumer<Object> consumer;@Mock\nprivate Supplier<Object> supplier;@Mock\nprivate Completable<Object> completable;@Mock\nprivate Callable<Object> callable;@Mock\nprivate Callable<Stage<Object>> c;@Mock\nprivate Callable<Stage<Object>> c2;@Mock\nprivate Collection<Callable<Stage<Object>>> callables;private CoreAsync underTest;",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\nimport com.google.common.collect.ImmutableList;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport org.junit.Test;\n",
      "allMethod_info": "@Test\npublic void testDoEventuallyCollect() throws Exception {\n    final List<Callable<Stage<Object>>> callables = ImmutableList.of(c, c2);\n    doReturn(executor).when(underTest).executor();\n    doReturn(completable).when(underTest).completable();\n    assertEquals(completable, underTest.doEventuallyCollect(callables, consumer, supplier, 10));\n    verify(executor).execute(any(DelayedCollectCoordinator.class));\n    verify(underTest).executor();\n}",
      "Method_name": "testDoEventuallyCollect",
      "Class_declaration": "public class CoreAsyncTest {\n",
      "constructors": "",
      "Class_name": "CoreAsyncTest",
      "methodName_paraNum": "[of(2), executor(0), when(1), doReturn(1), completable(0), when(1), doReturn(1), doEventuallyCollect(4), execute(1), verify(1), any(1), executor(0), verify(1)]",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/CoreAsyncTest###testDoEventuallyCollect",
      "relativePath": "udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/CoreAsyncTest.java",
      "Signature": "public void testDoEventuallyCollect() {\n",
      "all_Import_statements": "import static eu.toolchain.concurrent.CoreAsync.buildCollectedException;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.mockito.Matchers.any;\n\nimport static org.mockito.Matchers.anyCollection;\n\nimport static org.mockito.Matchers.eq;\n\nimport static org.mockito.Mockito.doAnswer;\n\nimport static org.mockito.Mockito.doNothing;\n\nimport static org.mockito.Mockito.doReturn;\n\nimport static org.mockito.Mockito.doThrow;\n\nimport static org.mockito.Mockito.inOrder;\n\nimport static org.mockito.Mockito.mock;\n\nimport static org.mockito.Mockito.never;\n\nimport static org.mockito.Mockito.spy;\n\nimport static org.mockito.Mockito.times;\n\nimport static org.mockito.Mockito.verify;\n\nimport static org.mockito.Mockito.when;\n\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.ArrayList;\n\nimport java.util.Collection;\n\nimport java.util.List;\n\nimport java.util.concurrent.Callable;\n\nimport java.util.concurrent.ExecutorService;\n\nimport java.util.concurrent.Future;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport org.junit.Before;\n\nimport org.junit.Rule;\n\nimport org.junit.Test;\n\nimport org.junit.rules.ExpectedException;\n\nimport org.junit.runner.RunWith;\n\nimport org.mockito.InOrder;\n\nimport org.mockito.Mock;\n\nimport org.mockito.invocation.InvocationOnMock;\n\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport org.mockito.stubbing.Answer;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "<C, T> Stage<T> doEventuallyCollectImmediate(final Collection<? extends Callable<? extends Stage<? extends C>>> callables, final Consumer<? super C> consumer, Supplier<? extends T> supplier) {\n    final List<Stage<? extends C>> stages = new ArrayList<>(callables.size());\n    for (final Callable<? extends Stage<? extends C>> c : callables) {\n        final Stage<? extends C> stage;\n        try {\n            stage = c.call();\n        } catch (final Exception e) {\n            stages.add(this.failed(e));\n            continue;\n        }\n        stages.add(stage);\n    }\n    return streamCollect(stages, consumer, supplier);\n}",
      "all_field_declaration": "private static final Collection<Object> EMPTY_RESULTS = Collections.emptyList();\n/**\n * Default executor to use when resolving asynchronously.\n */\nprivate final ExecutorService executor;\nprivate final ScheduledExecutorService scheduler;\n/**\n * Default set of helper functions for calling callbacks.\n */\n@NonNull\nprivate final Caller caller;\n@NonNull\nprivate final ClockSource clockSource;\n@NonNull\nprivate final ManagedOptions managedOptions;",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "3",
      "Filed": "",
      "Parameter_type": "Collection<? extends Callable<? extends Stage<? extends C>>>,Consumer<? super C>,Supplier<? extends T>",
      "Import_statements": "import java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.function.Consumer;\nimport java.util.function.Supplier;\n",
      "public_method_signature": "public ExecutorService executor();\npublic Caller caller();\npublic Stage<C> call(final Callable<? extends C> callable);\npublic Stage<C> call(final Callable<? extends C> callable, final ExecutorService executor);\npublic Stage<C> doCall(final Callable<? extends C> callable, final ExecutorService executor, final Completable<C> stage);\npublic Completable<T> completable();\npublic Stage<Void> completed();\npublic Stage<T> completed(T value);\npublic Stage<T> failed(Throwable e);\npublic Stage<T> cancelled();\npublic Stage<Collection<T>> collect(final Collection<? extends Stage<? extends T>> stages);\npublic Stage<T> collect(final Collection<? extends Stage<? extends C>> stages, final Function<? super Collection<C>, ? extends T> collector);\npublic Stage<U> streamCollect(final Collection<? extends Stage<? extends T>> stages, final Consumer<? super T> consumer, final Supplier<? extends U> supplier);\npublic Stage<T> eventuallyCollect(final Collection<? extends Callable<? extends Stage<? extends C>>> callables, final Consumer<? super C> consumer, Supplier<? extends T> supplier, int parallelism);\npublic Stage<Void> collectAndDiscard(Collection<? extends Stage<?>> stages);\npublic Managed<C> managed(Supplier<? extends Stage<C>> setup, Function<? super C, ? extends Stage<Void>> teardown);\npublic ReloadableManaged<C> reloadableManaged(final Supplier<? extends Stage<C>> setup, final Function<? super C, ? extends Stage<Void>> teardown);\npublic Stage<RetryResult<T>> retryUntilCompleted(final Callable<? extends Stage<T>> callable, final RetryPolicy policy);\npublic Stage<RetryResult<T>> retryUntilCompleted(final Callable<? extends Stage<T>> callable, final RetryPolicy policy, final ClockSource clockSource);\npublic static Builder builder();",
      "public_field": "",
      "Method_statement": "doEventuallyCollectImmediate(final Collection<? extends Callable<? extends Stage<? extends C>>> callables, final Consumer<? super C> consumer, Supplier<? extends T> supplier)",
      "Method_name": "doEventuallyCollectImmediate",
      "Class_declaration": "public class CoreAsync {\n",
      "constructors": "",
      "all_method_signature": "public ExecutorService executor();\npublic Caller caller();\npublic Stage<C> call(final Callable<? extends C> callable);\npublic Stage<C> call(final Callable<? extends C> callable, final ExecutorService executor);\npublic Stage<C> doCall(final Callable<? extends C> callable, final ExecutorService executor, final Completable<C> stage);\npublic Completable<T> completable();\npublic Stage<Void> completed();\npublic Stage<T> completed(T value);\npublic Stage<T> failed(Throwable e);\npublic Stage<T> cancelled();\npublic Stage<Collection<T>> collect(final Collection<? extends Stage<? extends T>> stages);\npublic Stage<T> collect(final Collection<? extends Stage<? extends C>> stages, final Function<? super Collection<C>, ? extends T> collector);\nprotected Stage<T> doCollect(final Collection<? extends Stage<? extends C>> stages, final Function<? super Collection<C>, ? extends T> collector);\n Stage<T> doCollectEmpty(final Function<? super Collection<C>, ? extends T> collector);\npublic Stage<U> streamCollect(final Collection<? extends Stage<? extends T>> stages, final Consumer<? super T> consumer, final Supplier<? extends U> supplier);\n Stage<U> doStreamCollectEmpty(final Consumer<? super T> consumer, final Supplier<? extends U> supplier);\n Stage<U> doStreamCollect(final Collection<? extends Stage<? extends T>> stages, final Consumer<? super T> consumer, final Supplier<? extends U> supplier);\npublic Stage<T> eventuallyCollect(final Collection<? extends Callable<? extends Stage<? extends C>>> callables, final Consumer<? super C> consumer, Supplier<? extends T> supplier, int parallelism);\n Stage<T> doEventuallyCollectEmpty(final Consumer<? super C> consumer, Supplier<? extends T> supplier);\n Stage<T> doEventuallyCollectImmediate(final Collection<? extends Callable<? extends Stage<? extends C>>> callables, final Consumer<? super C> consumer, Supplier<? extends T> supplier);\n Stage<U> doEventuallyCollect(final Collection<? extends Callable<? extends Stage<? extends T>>> tasks, final Consumer<? super T> consumer, Supplier<? extends U> supplier, int parallelism);\npublic Stage<Void> collectAndDiscard(Collection<? extends Stage<?>> stages);\n Stage<Void> doCollectAndDiscard(Collection<? extends Stage<?>> stages);\npublic Managed<C> managed(Supplier<? extends Stage<C>> setup, Function<? super C, ? extends Stage<Void>> teardown);\npublic ReloadableManaged<C> reloadableManaged(final Supplier<? extends Stage<C>> setup, final Function<? super C, ? extends Stage<Void>> teardown);\n void bindSignals(final Stage<?> target, final Collection<? extends Stage<?>> stages);\npublic Stage<RetryResult<T>> retryUntilCompleted(final Callable<? extends Stage<T>> callable, final RetryPolicy policy);\npublic Stage<RetryResult<T>> retryUntilCompleted(final Callable<? extends Stage<T>> callable, final RetryPolicy policy, final ClockSource clockSource);\n static String formatStack(final Stream<StackTraceElement> stack, final String prefix);\n static Throwable buildCollectedException(Collection<Throwable> errors);\npublic static Builder builder();",
      "Class_name": "CoreAsync",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/main/java/eu/toolchain/concurrent/CoreAsync###doEventuallyCollectImmediate",
      "Parameter_num": "3",
      "all_Import_statements": "import java.util.ArrayList;\n\nimport java.util.Collection;\n\nimport java.util.Collections;\n\nimport java.util.Iterator;\n\nimport java.util.List;\n\nimport java.util.Objects;\n\nimport java.util.StringJoiner;\n\nimport java.util.concurrent.Callable;\n\nimport java.util.concurrent.ExecutorService;\n\nimport java.util.concurrent.Future;\n\nimport java.util.concurrent.ScheduledExecutorService;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport java.util.stream.Stream;\n\nimport lombok.NonNull;\n\nimport lombok.RequiredArgsConstructor;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "method_signature": " Stage<T> doEventuallyCollectImmediate(final Collection<? extends Callable<? extends Stage<? extends C>>> callables, final Consumer<? super C> consumer, Supplier<? extends T> supplier);",
      "Junit_version": "4",
      "returnType": "Stage<T>"
    },
    "Test_method": {
      "Method_body": "final List<Callable<Stage<Object>>> callables = ImmutableList.of(c, c2);\n\rfinal List<Stage<Object>> futures = ImmutableList.of(f1, f2);\n\rdoReturn(f1).when(c).call();\n\rdoThrow(e).when(c2).call();\n\rdoReturn(f2).when(underTest).failed(e);\n\rdoReturn(future).when(underTest).streamCollect(futures, consumer, supplier);\n\rassertEquals(future, underTest.doEventuallyCollectImmediate(callables, consumer, supplier));\n\rverify(c).call();\n\rverify(c2).call();\n\rverify(underTest).failed(e);\n\rverify(underTest).streamCollect(futures, consumer, supplier);",
      "sub_project_name": "tiny-async-core",
      "lineNumbers": "11",
      "Filed": "private static final RuntimeException e = new RuntimeException();@Mock\nprivate Consumer<Object> consumer;@Mock\nprivate Supplier<Object> supplier;@Mock\nprivate Stage<Object> future;@Mock\nprivate Callable<Object> callable;@Mock\nprivate Stage<Object> f1;@Mock\nprivate Stage<Object> f2;@Mock\nprivate Callable<Stage<Object>> c;@Mock\nprivate Callable<Stage<Object>> c2;@Mock\nprivate Collection<Callable<Stage<Object>>> callables;@Mock\nprivate List<Stage<Object>> futures;private CoreAsync underTest;",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.doThrow;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\nimport com.google.common.collect.ImmutableList;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport org.junit.Test;\n",
      "allMethod_info": "@Test\npublic void testDoEventuallyCollectImmediate() throws Exception {\n    final List<Callable<Stage<Object>>> callables = ImmutableList.of(c, c2);\n    final List<Stage<Object>> futures = ImmutableList.of(f1, f2);\n    doReturn(f1).when(c).call();\n    doThrow(e).when(c2).call();\n    doReturn(f2).when(underTest).failed(e);\n    doReturn(future).when(underTest).streamCollect(futures, consumer, supplier);\n    assertEquals(future, underTest.doEventuallyCollectImmediate(callables, consumer, supplier));\n    verify(c).call();\n    verify(c2).call();\n    verify(underTest).failed(e);\n    verify(underTest).streamCollect(futures, consumer, supplier);\n}",
      "Method_name": "testDoEventuallyCollectImmediate",
      "Class_declaration": "public class CoreAsyncTest {\n",
      "constructors": "",
      "Class_name": "CoreAsyncTest",
      "methodName_paraNum": "[of(2), of(2), call(0), when(1), doReturn(1), call(0), when(1), doThrow(1), failed(1), when(1), doReturn(1), streamCollect(3), when(1), doReturn(1), doEventuallyCollectImmediate(3), call(0), verify(1), call(0), verify(1), failed(1), verify(1), streamCollect(3), verify(1)]",
      "project_path": "udoprog_tiny-async-java###udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/CoreAsyncTest###testDoEventuallyCollectImmediate",
      "relativePath": "udoprog_tiny-async-java/tiny-async-core/src/test/java/eu/toolchain/concurrent/CoreAsyncTest.java",
      "Signature": "public void testDoEventuallyCollectImmediate() {\n",
      "all_Import_statements": "import static eu.toolchain.concurrent.CoreAsync.buildCollectedException;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.mockito.Matchers.any;\n\nimport static org.mockito.Matchers.anyCollection;\n\nimport static org.mockito.Matchers.eq;\n\nimport static org.mockito.Mockito.doAnswer;\n\nimport static org.mockito.Mockito.doNothing;\n\nimport static org.mockito.Mockito.doReturn;\n\nimport static org.mockito.Mockito.doThrow;\n\nimport static org.mockito.Mockito.inOrder;\n\nimport static org.mockito.Mockito.mock;\n\nimport static org.mockito.Mockito.never;\n\nimport static org.mockito.Mockito.spy;\n\nimport static org.mockito.Mockito.times;\n\nimport static org.mockito.Mockito.verify;\n\nimport static org.mockito.Mockito.when;\n\nimport com.google.common.collect.ImmutableList;\n\nimport java.util.ArrayList;\n\nimport java.util.Collection;\n\nimport java.util.List;\n\nimport java.util.concurrent.Callable;\n\nimport java.util.concurrent.ExecutorService;\n\nimport java.util.concurrent.Future;\n\nimport java.util.function.Consumer;\n\nimport java.util.function.Function;\n\nimport java.util.function.Supplier;\n\nimport org.junit.Before;\n\nimport org.junit.Rule;\n\nimport org.junit.Test;\n\nimport org.junit.rules.ExpectedException;\n\nimport org.junit.runner.RunWith;\n\nimport org.mockito.InOrder;\n\nimport org.mockito.Mock;\n\nimport org.mockito.invocation.InvocationOnMock;\n\nimport org.mockito.runners.MockitoJUnitRunner;\n\nimport org.mockito.stubbing.Answer;\n",
      "comment": "",
      "packageName": "eu.toolchain.concurrent",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "public static Calendar truncate(final Calendar date, final int field) {\n    if (date == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    final Calendar truncated = (Calendar) date.clone();\n    modify(truncated, field, ModifyType.TRUNCATE);\n    return truncated;\n}",
      "all_field_declaration": "/**\n * Number of milliseconds in a standard second.\n * @since 2.1\n */\npublic static final long MILLIS_PER_SECOND = 1000;\n/**\n * Number of milliseconds in a standard minute.\n * @since 2.1\n */\npublic static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n/**\n * Number of milliseconds in a standard hour.\n * @since 2.1\n */\npublic static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n/**\n * Number of milliseconds in a standard day.\n * @since 2.1\n */\npublic static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n/**\n * This is half a month, so this represents whether a date is in the top\n * or bottom half of the month.\n */\npublic static final int SEMI_MONTH = 1001;\nprivate static final int[][] fields = { { Calendar.MILLISECOND }, { Calendar.SECOND }, { Calendar.MINUTE }, { Calendar.HOUR_OF_DAY, Calendar.HOUR }, { Calendar.DATE, Calendar.DAY_OF_MONTH, Calendar.AM_PM /* Calendar.DAY_OF_YEAR, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH */\n}, { Calendar.MONTH, DateUtils.SEMI_MONTH }, { Calendar.YEAR }, { Calendar.ERA } };\n/**\n * A week range, starting on Sunday.\n */\npublic static final int RANGE_WEEK_SUNDAY = 1;\n/**\n * A week range, starting on Monday.\n */\npublic static final int RANGE_WEEK_MONDAY = 2;\n/**\n * A week range, starting on the day focused.\n */\npublic static final int RANGE_WEEK_RELATIVE = 3;\n/**\n * A week range, centered around the day focused.\n */\npublic static final int RANGE_WEEK_CENTER = 4;\n/**\n * A month range, the week starting on Sunday.\n */\npublic static final int RANGE_MONTH_SUNDAY = 5;\n/**\n * A month range, the week starting on Monday.\n */\npublic static final int RANGE_MONTH_MONDAY = 6;",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "Calendar,int",
      "Import_statements": "import java.util.Calendar;\n",
      "public_method_signature": "public DateUtils();\npublic static boolean isSameDay(final Date date1, final Date date2);\npublic static boolean isSameDay(final Calendar cal1, final Calendar cal2);\npublic static boolean isSameInstant(final Date date1, final Date date2);\npublic static boolean isSameInstant(final Calendar cal1, final Calendar cal2);\npublic static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2);\npublic static Date parseDate(final String str, final String... parsePatterns) throws ParseException;\npublic static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException;\npublic static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException;\npublic static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException;\npublic static Date addYears(final Date date, final int amount);\npublic static Date addMonths(final Date date, final int amount);\npublic static Date addWeeks(final Date date, final int amount);\npublic static Date addDays(final Date date, final int amount);\npublic static Date addHours(final Date date, final int amount);\npublic static Date addMinutes(final Date date, final int amount);\npublic static Date addSeconds(final Date date, final int amount);\npublic static Date addMilliseconds(final Date date, final int amount);\npublic static Date setYears(final Date date, final int amount);\npublic static Date setMonths(final Date date, final int amount);\npublic static Date setDays(final Date date, final int amount);\npublic static Date setHours(final Date date, final int amount);\npublic static Date setMinutes(final Date date, final int amount);\npublic static Date setSeconds(final Date date, final int amount);\npublic static Date setMilliseconds(final Date date, final int amount);\npublic static Calendar toCalendar(final Date date);\npublic static Calendar toCalendar(final Date date, final TimeZone tz);\npublic static Date round(final Date date, final int field);\npublic static Calendar round(final Calendar date, final int field);\npublic static Date round(final Object date, final int field);\npublic static Date truncate(final Date date, final int field);\npublic static Calendar truncate(final Calendar date, final int field);\npublic static Date truncate(final Object date, final int field);\npublic static Date ceiling(final Date date, final int field);\npublic static Calendar ceiling(final Calendar date, final int field);\npublic static Date ceiling(final Object date, final int field);\npublic static Iterator<Calendar> iterator(final Date focus, final int rangeStyle);\npublic static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle);\npublic static Iterator<?> iterator(final Object focus, final int rangeStyle);\npublic static long getFragmentInMilliseconds(final Date date, final int fragment);\npublic static long getFragmentInSeconds(final Date date, final int fragment);\npublic static long getFragmentInMinutes(final Date date, final int fragment);\npublic static long getFragmentInHours(final Date date, final int fragment);\npublic static long getFragmentInDays(final Date date, final int fragment);\npublic static long getFragmentInMilliseconds(final Calendar calendar, final int fragment);\npublic static long getFragmentInSeconds(final Calendar calendar, final int fragment);\npublic static long getFragmentInMinutes(final Calendar calendar, final int fragment);\npublic static long getFragmentInHours(final Calendar calendar, final int fragment);\npublic static long getFragmentInDays(final Calendar calendar, final int fragment);\npublic static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field);\npublic static boolean truncatedEquals(final Date date1, final Date date2, final int field);\npublic static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field);\npublic static int truncatedCompareTo(final Date date1, final Date date2, final int field);",
      "public_field": "/**\n * Number of milliseconds in a standard second.\n * @since 2.1\n */\npublic static final long MILLIS_PER_SECOND = 1000;\n/**\n * Number of milliseconds in a standard minute.\n * @since 2.1\n */\npublic static final long MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;\n/**\n * Number of milliseconds in a standard hour.\n * @since 2.1\n */\npublic static final long MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;\n/**\n * Number of milliseconds in a standard day.\n * @since 2.1\n */\npublic static final long MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;\n/**\n * This is half a month, so this represents whether a date is in the top\n * or bottom half of the month.\n */\npublic static final int SEMI_MONTH = 1001;\n/**\n * A week range, starting on Sunday.\n */\npublic static final int RANGE_WEEK_SUNDAY = 1;\n/**\n * A week range, starting on Monday.\n */\npublic static final int RANGE_WEEK_MONDAY = 2;\n/**\n * A week range, starting on the day focused.\n */\npublic static final int RANGE_WEEK_RELATIVE = 3;\n/**\n * A week range, centered around the day focused.\n */\npublic static final int RANGE_WEEK_CENTER = 4;\n/**\n * A month range, the week starting on Sunday.\n */\npublic static final int RANGE_MONTH_SUNDAY = 5;\n/**\n * A month range, the week starting on Monday.\n */\npublic static final int RANGE_MONTH_MONDAY = 6;",
      "Method_statement": "truncate(final Calendar date, final int field)",
      "Method_name": "truncate",
      "Class_declaration": "public class DateUtils {\n",
      "constructors": "public DateUtils() {\n    super();\n}",
      "all_method_signature": "public DateUtils();\npublic static boolean isSameDay(final Date date1, final Date date2);\npublic static boolean isSameDay(final Calendar cal1, final Calendar cal2);\npublic static boolean isSameInstant(final Date date1, final Date date2);\npublic static boolean isSameInstant(final Calendar cal1, final Calendar cal2);\npublic static boolean isSameLocalTime(final Calendar cal1, final Calendar cal2);\npublic static Date parseDate(final String str, final String... parsePatterns) throws ParseException;\npublic static Date parseDate(final String str, final Locale locale, final String... parsePatterns) throws ParseException;\npublic static Date parseDateStrictly(final String str, final String... parsePatterns) throws ParseException;\npublic static Date parseDateStrictly(final String str, final Locale locale, final String... parsePatterns) throws ParseException;\nprivate static Date parseDateWithLeniency(final String str, final Locale locale, final String[] parsePatterns, final boolean lenient) throws ParseException;\npublic static Date addYears(final Date date, final int amount);\npublic static Date addMonths(final Date date, final int amount);\npublic static Date addWeeks(final Date date, final int amount);\npublic static Date addDays(final Date date, final int amount);\npublic static Date addHours(final Date date, final int amount);\npublic static Date addMinutes(final Date date, final int amount);\npublic static Date addSeconds(final Date date, final int amount);\npublic static Date addMilliseconds(final Date date, final int amount);\nprivate static Date add(final Date date, final int calendarField, final int amount);\npublic static Date setYears(final Date date, final int amount);\npublic static Date setMonths(final Date date, final int amount);\npublic static Date setDays(final Date date, final int amount);\npublic static Date setHours(final Date date, final int amount);\npublic static Date setMinutes(final Date date, final int amount);\npublic static Date setSeconds(final Date date, final int amount);\npublic static Date setMilliseconds(final Date date, final int amount);\nprivate static Date set(final Date date, final int calendarField, final int amount);\npublic static Calendar toCalendar(final Date date);\npublic static Calendar toCalendar(final Date date, final TimeZone tz);\npublic static Date round(final Date date, final int field);\npublic static Calendar round(final Calendar date, final int field);\npublic static Date round(final Object date, final int field);\npublic static Date truncate(final Date date, final int field);\npublic static Calendar truncate(final Calendar date, final int field);\npublic static Date truncate(final Object date, final int field);\npublic static Date ceiling(final Date date, final int field);\npublic static Calendar ceiling(final Calendar date, final int field);\npublic static Date ceiling(final Object date, final int field);\nprivate static void modify(final Calendar val, final int field, final ModifyType modType);\npublic static Iterator<Calendar> iterator(final Date focus, final int rangeStyle);\npublic static Iterator<Calendar> iterator(final Calendar focus, final int rangeStyle);\npublic static Iterator<?> iterator(final Object focus, final int rangeStyle);\npublic static long getFragmentInMilliseconds(final Date date, final int fragment);\npublic static long getFragmentInSeconds(final Date date, final int fragment);\npublic static long getFragmentInMinutes(final Date date, final int fragment);\npublic static long getFragmentInHours(final Date date, final int fragment);\npublic static long getFragmentInDays(final Date date, final int fragment);\npublic static long getFragmentInMilliseconds(final Calendar calendar, final int fragment);\npublic static long getFragmentInSeconds(final Calendar calendar, final int fragment);\npublic static long getFragmentInMinutes(final Calendar calendar, final int fragment);\npublic static long getFragmentInHours(final Calendar calendar, final int fragment);\npublic static long getFragmentInDays(final Calendar calendar, final int fragment);\nprivate static long getFragment(final Date date, final int fragment, final TimeUnit unit);\nprivate static long getFragment(final Calendar calendar, final int fragment, final TimeUnit unit);\npublic static boolean truncatedEquals(final Calendar cal1, final Calendar cal2, final int field);\npublic static boolean truncatedEquals(final Date date1, final Date date2, final int field);\npublic static int truncatedCompareTo(final Calendar cal1, final Calendar cal2, final int field);\npublic static int truncatedCompareTo(final Date date1, final Date date2, final int field);\nprivate static void validateDateNotNull(final Date date);",
      "Class_name": "DateUtils",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/time/DateUtils###truncate",
      "Parameter_num": "2",
      "all_Import_statements": "import java.text.ParseException;\n\nimport java.text.ParsePosition;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n\nimport java.util.Iterator;\n\nimport java.util.Locale;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.TimeZone;\n\nimport java.util.concurrent.TimeUnit;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n\nimport org.apache.commons.lang3.Validate;\n",
      "comment": "\n     * <p>Truncates a date, leaving the field specified as the most\n     * significant field.</p>\n     *\n     * <p>For example, if you had the date-time of 28 Mar 2002\n     * 13:45:01.231, if you passed with HOUR, it would return 28 Mar\n     * 2002 13:00:00.000.  If this was passed with MONTH, it would\n     * return 1 Mar 2002 0:00:00.000.</p>\n     *\n     * @param date  the date to work with, not null\n     * @param field  the field from {@code Calendar} or <code>SEMI_MONTH</code>\n     * @return the different truncated date, not null\n     * @throws IllegalArgumentException if the date is <code>null</code>\n     * @throws ArithmeticException if the year is over 280 million\n     ",
      "packageName": "org.apache.commons.lang3.time",
      "method_signature": "public static Calendar truncate(final Calendar date, final int field);",
      "Junit_version": "4",
      "returnType": "Calendar"
    },
    "Test_method": {
      "Method_body": "// tests public static Date truncate(Date date, int field)\nassertEquals(\"truncate year-1 failed\", dateParser.parse(\"January 1, 2002\"), DateUtils.truncate(date1, Calendar.YEAR));\n\rassertEquals(\"truncate year-2 failed\", dateParser.parse(\"January 1, 2001\"), DateUtils.truncate(date2, Calendar.YEAR));\n\rassertEquals(\"truncate month-1 failed\", dateParser.parse(\"February 1, 2002\"), DateUtils.truncate(date1, Calendar.MONTH));\n\rassertEquals(\"truncate month-2 failed\", dateParser.parse(\"November 1, 2001\"), DateUtils.truncate(date2, Calendar.MONTH));\n\rassertEquals(\"truncate semimonth-1 failed\", dateParser.parse(\"February 1, 2002\"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH));\n\rassertEquals(\"truncate semimonth-2 failed\", dateParser.parse(\"November 16, 2001\"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH));\n\rassertEquals(\"truncate date-1 failed\", dateParser.parse(\"February 12, 2002\"), DateUtils.truncate(date1, Calendar.DATE));\n\rassertEquals(\"truncate date-2 failed\", dateParser.parse(\"November 18, 2001\"), DateUtils.truncate(date2, Calendar.DATE));\n\rassertEquals(\"truncate hour-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:00:00.000\"), DateUtils.truncate(date1, Calendar.HOUR));\n\rassertEquals(\"truncate hour-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"), DateUtils.truncate(date2, Calendar.HOUR));\n\rassertEquals(\"truncate minute-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:34:00.000\"), DateUtils.truncate(date1, Calendar.MINUTE));\n\rassertEquals(\"truncate minute-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"), DateUtils.truncate(date2, Calendar.MINUTE));\n\rassertEquals(\"truncate second-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:34:56.000\"), DateUtils.truncate(date1, Calendar.SECOND));\n\rassertEquals(\"truncate second-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.truncate(date2, Calendar.SECOND));\n\rassertEquals(\"truncate ampm-1 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate(dateAmPm1, Calendar.AM_PM));\n\rassertEquals(\"truncate ampm-2 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate(dateAmPm2, Calendar.AM_PM));\n\rassertEquals(\"truncate ampm-3 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate(dateAmPm3, Calendar.AM_PM));\n\rassertEquals(\"truncate ampm-4 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate(dateAmPm4, Calendar.AM_PM));\n\r// tests public static Date truncate(Object date, int field)\nassertEquals(\"truncate year-1 failed\", dateParser.parse(\"January 1, 2002\"), DateUtils.truncate((Object) date1, Calendar.YEAR));\n\rassertEquals(\"truncate year-2 failed\", dateParser.parse(\"January 1, 2001\"), DateUtils.truncate((Object) date2, Calendar.YEAR));\n\rassertEquals(\"truncate month-1 failed\", dateParser.parse(\"February 1, 2002\"), DateUtils.truncate((Object) date1, Calendar.MONTH));\n\rassertEquals(\"truncate month-2 failed\", dateParser.parse(\"November 1, 2001\"), DateUtils.truncate((Object) date2, Calendar.MONTH));\n\rassertEquals(\"truncate semimonth-1 failed\", dateParser.parse(\"February 1, 2002\"), DateUtils.truncate((Object) date1, DateUtils.SEMI_MONTH));\n\rassertEquals(\"truncate semimonth-2 failed\", dateParser.parse(\"November 16, 2001\"), DateUtils.truncate((Object) date2, DateUtils.SEMI_MONTH));\n\rassertEquals(\"truncate date-1 failed\", dateParser.parse(\"February 12, 2002\"), DateUtils.truncate((Object) date1, Calendar.DATE));\n\rassertEquals(\"truncate date-2 failed\", dateParser.parse(\"November 18, 2001\"), DateUtils.truncate((Object) date2, Calendar.DATE));\n\rassertEquals(\"truncate hour-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:00:00.000\"), DateUtils.truncate((Object) date1, Calendar.HOUR));\n\rassertEquals(\"truncate hour-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"), DateUtils.truncate((Object) date2, Calendar.HOUR));\n\rassertEquals(\"truncate minute-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:34:00.000\"), DateUtils.truncate((Object) date1, Calendar.MINUTE));\n\rassertEquals(\"truncate minute-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"), DateUtils.truncate((Object) date2, Calendar.MINUTE));\n\rassertEquals(\"truncate second-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:34:56.000\"), DateUtils.truncate((Object) date1, Calendar.SECOND));\n\rassertEquals(\"truncate second-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.truncate((Object) date2, Calendar.SECOND));\n\rassertEquals(\"truncate ampm-1 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate((Object) dateAmPm1, Calendar.AM_PM));\n\rassertEquals(\"truncate ampm-2 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate((Object) dateAmPm2, Calendar.AM_PM));\n\rassertEquals(\"truncate ampm-3 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate((Object) dateAmPm3, Calendar.AM_PM));\n\rassertEquals(\"truncate ampm-4 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate((Object) dateAmPm4, Calendar.AM_PM));\n\rassertEquals(\"truncate calendar second-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:34:56.000\"), DateUtils.truncate((Object) cal1, Calendar.SECOND));\n\rassertEquals(\"truncate calendar second-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.truncate((Object) cal2, Calendar.SECOND));\n\rassertEquals(\"truncate ampm-1 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate((Object) calAmPm1, Calendar.AM_PM));\n\rassertEquals(\"truncate ampm-2 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate((Object) calAmPm2, Calendar.AM_PM));\n\rassertEquals(\"truncate ampm-3 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate((Object) calAmPm3, Calendar.AM_PM));\n\rassertEquals(\"truncate ampm-4 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate((Object) calAmPm4, Calendar.AM_PM));\n\rtry {\n    DateUtils.truncate((Date) null, Calendar.SECOND);\n    fail();\n} catch (final IllegalArgumentException ex) {\n}\n\rtry {\n    DateUtils.truncate((Calendar) null, Calendar.SECOND);\n    fail();\n} catch (final IllegalArgumentException ex) {\n}\n\rtry {\n    DateUtils.truncate((Object) null, Calendar.SECOND);\n    fail();\n} catch (final IllegalArgumentException ex) {\n}\n\rtry {\n    DateUtils.truncate(\"\", Calendar.SECOND);\n    fail();\n} catch (final ClassCastException ex) {\n}\n\r// Fix for http://issues.apache.org/bugzilla/show_bug.cgi?id=25560\n// Test truncate across beginning of daylight saving time\ntry {\n    TimeZone.setDefault(zone);\n    dateTimeParser.setTimeZone(zone);\n    assertEquals(\"truncate MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.truncate(date3, Calendar.DATE));\n    assertEquals(\"truncate MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.truncate((Object) cal3, Calendar.DATE));\n    // Test truncate across end of daylight saving time\n    assertEquals(\"truncate MET date across DST change-over\", dateTimeParser.parse(\"October 26, 2003 00:00:00.000\"), DateUtils.truncate(date8, Calendar.DATE));\n    assertEquals(\"truncate MET date across DST change-over\", dateTimeParser.parse(\"October 26, 2003 00:00:00.000\"), DateUtils.truncate((Object) cal8, Calendar.DATE));\n} finally {\n    TimeZone.setDefault(defaultZone);\n    dateTimeParser.setTimeZone(defaultZone);\n}\n\r// Bug 31395, large dates\n// fyi: Sun Aug 17 07:12:55 CET 292278994 -- 807 millis\nfinal Date endOfTime = new Date(Long.MAX_VALUE);\n\rfinal GregorianCalendar endCal = new GregorianCalendar();\n\rendCal.setTime(endOfTime);\n\rtry {\n    DateUtils.truncate(endCal, Calendar.DATE);\n    fail();\n} catch (final ArithmeticException ex) {\n}\n\rendCal.set(Calendar.YEAR, 280000001);\n\rtry {\n    DateUtils.truncate(endCal, Calendar.DATE);\n    fail();\n} catch (final ArithmeticException ex) {\n}\n\rendCal.set(Calendar.YEAR, 280000000);\n\rfinal Calendar cal = DateUtils.truncate(endCal, Calendar.DATE);\n\rassertEquals(0, cal.get(Calendar.HOUR));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "56",
      "Filed": "private DateFormat dateParser = null;private DateFormat dateTimeParser = null;private Date dateAmPm1 = null;private Date dateAmPm2 = null;private Date dateAmPm3 = null;private Date dateAmPm4 = null;private Date date1 = null;private Date date2 = null;private Date date3 = null;private Date date8 = null;private Calendar calAmPm1 = null;private Calendar calAmPm2 = null;private Calendar calAmPm3 = null;private Calendar calAmPm4 = null;private Calendar cal1 = null;private Calendar cal2 = null;private Calendar cal3 = null;private Calendar cal8 = null;private TimeZone zone = null;private TimeZone defaultZone = null;",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.TimeZone;\nimport org.junit.Test;\n",
      "allMethod_info": "/**\n * Tests various values with the trunc method\n *\n * @throws java.lang.Exception so we don't have to catch it\n */\n@Test\npublic void testTruncate() throws Exception {\n    // tests public static Date truncate(Date date, int field)\n    assertEquals(\"truncate year-1 failed\", dateParser.parse(\"January 1, 2002\"), DateUtils.truncate(date1, Calendar.YEAR));\n    assertEquals(\"truncate year-2 failed\", dateParser.parse(\"January 1, 2001\"), DateUtils.truncate(date2, Calendar.YEAR));\n    assertEquals(\"truncate month-1 failed\", dateParser.parse(\"February 1, 2002\"), DateUtils.truncate(date1, Calendar.MONTH));\n    assertEquals(\"truncate month-2 failed\", dateParser.parse(\"November 1, 2001\"), DateUtils.truncate(date2, Calendar.MONTH));\n    assertEquals(\"truncate semimonth-1 failed\", dateParser.parse(\"February 1, 2002\"), DateUtils.truncate(date1, DateUtils.SEMI_MONTH));\n    assertEquals(\"truncate semimonth-2 failed\", dateParser.parse(\"November 16, 2001\"), DateUtils.truncate(date2, DateUtils.SEMI_MONTH));\n    assertEquals(\"truncate date-1 failed\", dateParser.parse(\"February 12, 2002\"), DateUtils.truncate(date1, Calendar.DATE));\n    assertEquals(\"truncate date-2 failed\", dateParser.parse(\"November 18, 2001\"), DateUtils.truncate(date2, Calendar.DATE));\n    assertEquals(\"truncate hour-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:00:00.000\"), DateUtils.truncate(date1, Calendar.HOUR));\n    assertEquals(\"truncate hour-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"), DateUtils.truncate(date2, Calendar.HOUR));\n    assertEquals(\"truncate minute-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:34:00.000\"), DateUtils.truncate(date1, Calendar.MINUTE));\n    assertEquals(\"truncate minute-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"), DateUtils.truncate(date2, Calendar.MINUTE));\n    assertEquals(\"truncate second-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:34:56.000\"), DateUtils.truncate(date1, Calendar.SECOND));\n    assertEquals(\"truncate second-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.truncate(date2, Calendar.SECOND));\n    assertEquals(\"truncate ampm-1 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate(dateAmPm1, Calendar.AM_PM));\n    assertEquals(\"truncate ampm-2 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate(dateAmPm2, Calendar.AM_PM));\n    assertEquals(\"truncate ampm-3 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate(dateAmPm3, Calendar.AM_PM));\n    assertEquals(\"truncate ampm-4 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate(dateAmPm4, Calendar.AM_PM));\n    // tests public static Date truncate(Object date, int field)\n    assertEquals(\"truncate year-1 failed\", dateParser.parse(\"January 1, 2002\"), DateUtils.truncate((Object) date1, Calendar.YEAR));\n    assertEquals(\"truncate year-2 failed\", dateParser.parse(\"January 1, 2001\"), DateUtils.truncate((Object) date2, Calendar.YEAR));\n    assertEquals(\"truncate month-1 failed\", dateParser.parse(\"February 1, 2002\"), DateUtils.truncate((Object) date1, Calendar.MONTH));\n    assertEquals(\"truncate month-2 failed\", dateParser.parse(\"November 1, 2001\"), DateUtils.truncate((Object) date2, Calendar.MONTH));\n    assertEquals(\"truncate semimonth-1 failed\", dateParser.parse(\"February 1, 2002\"), DateUtils.truncate((Object) date1, DateUtils.SEMI_MONTH));\n    assertEquals(\"truncate semimonth-2 failed\", dateParser.parse(\"November 16, 2001\"), DateUtils.truncate((Object) date2, DateUtils.SEMI_MONTH));\n    assertEquals(\"truncate date-1 failed\", dateParser.parse(\"February 12, 2002\"), DateUtils.truncate((Object) date1, Calendar.DATE));\n    assertEquals(\"truncate date-2 failed\", dateParser.parse(\"November 18, 2001\"), DateUtils.truncate((Object) date2, Calendar.DATE));\n    assertEquals(\"truncate hour-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:00:00.000\"), DateUtils.truncate((Object) date1, Calendar.HOUR));\n    assertEquals(\"truncate hour-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:00:00.000\"), DateUtils.truncate((Object) date2, Calendar.HOUR));\n    assertEquals(\"truncate minute-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:34:00.000\"), DateUtils.truncate((Object) date1, Calendar.MINUTE));\n    assertEquals(\"truncate minute-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:00.000\"), DateUtils.truncate((Object) date2, Calendar.MINUTE));\n    assertEquals(\"truncate second-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:34:56.000\"), DateUtils.truncate((Object) date1, Calendar.SECOND));\n    assertEquals(\"truncate second-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.truncate((Object) date2, Calendar.SECOND));\n    assertEquals(\"truncate ampm-1 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate((Object) dateAmPm1, Calendar.AM_PM));\n    assertEquals(\"truncate ampm-2 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate((Object) dateAmPm2, Calendar.AM_PM));\n    assertEquals(\"truncate ampm-3 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate((Object) dateAmPm3, Calendar.AM_PM));\n    assertEquals(\"truncate ampm-4 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate((Object) dateAmPm4, Calendar.AM_PM));\n    assertEquals(\"truncate calendar second-1 failed\", dateTimeParser.parse(\"February 12, 2002 12:34:56.000\"), DateUtils.truncate((Object) cal1, Calendar.SECOND));\n    assertEquals(\"truncate calendar second-2 failed\", dateTimeParser.parse(\"November 18, 2001 1:23:11.000\"), DateUtils.truncate((Object) cal2, Calendar.SECOND));\n    assertEquals(\"truncate ampm-1 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate((Object) calAmPm1, Calendar.AM_PM));\n    assertEquals(\"truncate ampm-2 failed\", dateTimeParser.parse(\"February 3, 2002 00:00:00.000\"), DateUtils.truncate((Object) calAmPm2, Calendar.AM_PM));\n    assertEquals(\"truncate ampm-3 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate((Object) calAmPm3, Calendar.AM_PM));\n    assertEquals(\"truncate ampm-4 failed\", dateTimeParser.parse(\"February 3, 2002 12:00:00.000\"), DateUtils.truncate((Object) calAmPm4, Calendar.AM_PM));\n    try {\n        DateUtils.truncate((Date) null, Calendar.SECOND);\n        fail();\n    } catch (final IllegalArgumentException ex) {\n    }\n    try {\n        DateUtils.truncate((Calendar) null, Calendar.SECOND);\n        fail();\n    } catch (final IllegalArgumentException ex) {\n    }\n    try {\n        DateUtils.truncate((Object) null, Calendar.SECOND);\n        fail();\n    } catch (final IllegalArgumentException ex) {\n    }\n    try {\n        DateUtils.truncate(\"\", Calendar.SECOND);\n        fail();\n    } catch (final ClassCastException ex) {\n    }\n    // Fix for http://issues.apache.org/bugzilla/show_bug.cgi?id=25560\n    // Test truncate across beginning of daylight saving time\n    try {\n        TimeZone.setDefault(zone);\n        dateTimeParser.setTimeZone(zone);\n        assertEquals(\"truncate MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.truncate(date3, Calendar.DATE));\n        assertEquals(\"truncate MET date across DST change-over\", dateTimeParser.parse(\"March 30, 2003 00:00:00.000\"), DateUtils.truncate((Object) cal3, Calendar.DATE));\n        // Test truncate across end of daylight saving time\n        assertEquals(\"truncate MET date across DST change-over\", dateTimeParser.parse(\"October 26, 2003 00:00:00.000\"), DateUtils.truncate(date8, Calendar.DATE));\n        assertEquals(\"truncate MET date across DST change-over\", dateTimeParser.parse(\"October 26, 2003 00:00:00.000\"), DateUtils.truncate((Object) cal8, Calendar.DATE));\n    } finally {\n        TimeZone.setDefault(defaultZone);\n        dateTimeParser.setTimeZone(defaultZone);\n    }\n    // Bug 31395, large dates\n    // fyi: Sun Aug 17 07:12:55 CET 292278994 -- 807 millis\n    final Date endOfTime = new Date(Long.MAX_VALUE);\n    final GregorianCalendar endCal = new GregorianCalendar();\n    endCal.setTime(endOfTime);\n    try {\n        DateUtils.truncate(endCal, Calendar.DATE);\n        fail();\n    } catch (final ArithmeticException ex) {\n    }\n    endCal.set(Calendar.YEAR, 280000001);\n    try {\n        DateUtils.truncate(endCal, Calendar.DATE);\n        fail();\n    } catch (final ArithmeticException ex) {\n    }\n    endCal.set(Calendar.YEAR, 280000000);\n    final Calendar cal = DateUtils.truncate(endCal, Calendar.DATE);\n    assertEquals(0, cal.get(Calendar.HOUR));\n}",
      "Method_name": "testTruncate",
      "Class_declaration": "public class DateUtilsTest {\n",
      "constructors": "",
      "Class_name": "DateUtilsTest",
      "methodName_paraNum": "[parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), truncate(2), fail(0), truncate(2), fail(0), truncate(2), fail(0), truncate(2), fail(0), setDefault(1), setTimeZone(1), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), parse(1), truncate(2), setDefault(1), setTimeZone(1), setTime(1), truncate(2), fail(0), set(2), truncate(2), fail(0), set(2), truncate(2), get(1)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/time/DateUtilsTest###testTruncate",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/time/DateUtilsTest.java",
      "Signature": "public void testTruncate() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertNotSame;\n\nimport static org.junit.Assert.assertTrue;\n\nimport static org.junit.Assert.fail;\n\nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Modifier;\n\nimport java.text.DateFormat;\n\nimport java.text.ParseException;\n\nimport java.text.SimpleDateFormat;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n\nimport java.util.GregorianCalendar;\n\nimport java.util.Iterator;\n\nimport java.util.Locale;\n\nimport java.util.NoSuchElementException;\n\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang3.test.SystemDefaults;\n\nimport org.apache.commons.lang3.test.SystemDefaultsSwitch;\n\nimport org.junit.Before;\n\nimport org.junit.BeforeClass;\n\nimport org.junit.Rule;\n\nimport org.junit.Test;\n",
      "comment": "\n     * Tests various values with the trunc method\n     *\n     * @throws java.lang.Exception so we don't have to catch it\n     ",
      "packageName": "org.apache.commons.lang3.time",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic List<Reference> getReferences(String rawValue, Retriever retriever) {\n    if (rawValue == null) {\n        return Collections.emptyList();\n    }\n    Evaluation eval = new Evaluation(rawValue, retriever);\n    eval.parse();\n    return eval.getReferences(false);\n}",
      "all_field_declaration": "/**\n * The pattern used to detect property references in the style of Ant.\n */\nprivate static final Pattern PATTERN = Pattern.compile(\"\\\\$\\\\{(.+?)\\\\}\");",
      "sub_project_name": "syphr42_prom",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "String,Retriever",
      "Import_statements": "import java.util.Collections;\nimport java.util.List;\n",
      "public_method_signature": "public String evaluate(String rawValue, Retriever retriever);\npublic Reference referenceAt(String rawValue, int position, Retriever retriever);\npublic boolean isReferencing(String rawValue, String name, Retriever retriever);\npublic List<Reference> getReferences(String rawValue, Retriever retriever);",
      "public_field": "",
      "Method_statement": "getReferences(String rawValue, Retriever retriever)",
      "Method_name": "getReferences",
      "Class_declaration": "public class DefaultEvaluator {\n",
      "constructors": "",
      "all_method_signature": "public String evaluate(String rawValue, Retriever retriever);\npublic Reference referenceAt(String rawValue, int position, Retriever retriever);\npublic boolean isReferencing(String rawValue, String name, Retriever retriever);\npublic List<Reference> getReferences(String rawValue, Retriever retriever);",
      "Class_name": "DefaultEvaluator",
      "project_path": "syphr42_prom###syphr42_prom/src/main/java/org/syphr/prom/DefaultEvaluator###getReferences",
      "Parameter_num": "2",
      "all_Import_statements": "import java.util.ArrayList;\n\nimport java.util.Collections;\n\nimport java.util.Iterator;\n\nimport java.util.List;\n\nimport java.util.ListIterator;\n\nimport java.util.regex.Matcher;\n\nimport java.util.regex.Pattern;\n",
      "comment": "",
      "packageName": "org.syphr.prom",
      "method_signature": "public List<Reference> getReferences(String rawValue, Retriever retriever);",
      "Junit_version": "4",
      "returnType": "List<Reference>"
    },
    "Test_method": {
      "Method_body": "List<Reference> variablesNoRec = evaluator.getReferences(RAW_VALUE_4, retriever);\n\rAssert.assertEquals(\"Non-recursive variable lookup on \\\"\" + RAW_VALUE_4 + \"\\\" returned unexpected number of results\", 1, variablesNoRec.size());\n\rAssert.assertEquals(\"Non-recursive evaluation of \\\"\" + RAW_VALUE_4 + \"\\\" did not yield the expected value for the first variable found\", RAW_VALUE_3, variablesNoRec.get(0).getValue());",
      "sub_project_name": "syphr42_prom",
      "lineNumbers": "3",
      "Filed": "private static final String RAW_VALUE_3 = \"prefix \" + KEY_1_VAR + \" middle \" + KEY_2_VAR + \" suffix\";private static final String RAW_VALUE_4 = \"nested ${\" + KEY_3 + \"} variables\";private static Retriever retriever;private static DefaultEvaluator evaluator;",
      "Import_statements": "import java.util.List;\nimport junit.framework.Assert;\n",
      "allMethod_info": "@Test\npublic void testGetreferences() {\n    List<Reference> variablesNoRec = evaluator.getReferences(RAW_VALUE_4, retriever);\n    Assert.assertEquals(\"Non-recursive variable lookup on \\\"\" + RAW_VALUE_4 + \"\\\" returned unexpected number of results\", 1, variablesNoRec.size());\n    Assert.assertEquals(\"Non-recursive evaluation of \\\"\" + RAW_VALUE_4 + \"\\\" did not yield the expected value for the first variable found\", RAW_VALUE_3, variablesNoRec.get(0).getValue());\n}",
      "Method_name": "testGetreferences",
      "Class_declaration": "public class DefaultEvaluatorTest {\n",
      "constructors": "",
      "Class_name": "DefaultEvaluatorTest",
      "methodName_paraNum": "[getReferences(2), size(0), getValue(0), get(1)]",
      "project_path": "syphr42_prom###syphr42_prom/src/test/java/org/syphr/prom/DefaultEvaluatorTest###testGetreferences",
      "relativePath": "syphr42_prom/src/test/java/org/syphr/prom/DefaultEvaluatorTest.java",
      "Signature": "public void testGetreferences() {\n",
      "all_Import_statements": "import java.util.List;\n\nimport java.util.Properties;\n\nimport java.util.concurrent.ExecutorService;\n\nimport java.util.concurrent.Executors;\n\nimport junit.framework.Assert;\n\nimport org.junit.BeforeClass;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.syphr.prom",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic boolean isReferencing(String rawValue, String name, Retriever retriever) {\n    if (rawValue == null) {\n        return false;\n    }\n    Evaluation eval = new Evaluation(rawValue, retriever);\n    eval.parse();\n    List<Reference> references = eval.getReferences(true);\n    for (Reference ref : references) {\n        if (ref.getName().equals(name)) {\n            return true;\n        }\n    }\n    return false;\n}",
      "all_field_declaration": "/**\n * The pattern used to detect property references in the style of Ant.\n */\nprivate static final Pattern PATTERN = Pattern.compile(\"\\\\$\\\\{(.+?)\\\\}\");",
      "sub_project_name": "syphr42_prom",
      "lineNumbers": "6",
      "Filed": "",
      "Parameter_type": "String,String,Retriever",
      "Import_statements": "import java.util.List;\n",
      "public_method_signature": "public String evaluate(String rawValue, Retriever retriever);\npublic Reference referenceAt(String rawValue, int position, Retriever retriever);\npublic boolean isReferencing(String rawValue, String name, Retriever retriever);\npublic List<Reference> getReferences(String rawValue, Retriever retriever);",
      "public_field": "",
      "Method_statement": "isReferencing(String rawValue, String name, Retriever retriever)",
      "Method_name": "isReferencing",
      "Class_declaration": "public class DefaultEvaluator {\n",
      "constructors": "",
      "all_method_signature": "public String evaluate(String rawValue, Retriever retriever);\npublic Reference referenceAt(String rawValue, int position, Retriever retriever);\npublic boolean isReferencing(String rawValue, String name, Retriever retriever);\npublic List<Reference> getReferences(String rawValue, Retriever retriever);",
      "Class_name": "DefaultEvaluator",
      "project_path": "syphr42_prom###syphr42_prom/src/main/java/org/syphr/prom/DefaultEvaluator###isReferencing",
      "Parameter_num": "3",
      "all_Import_statements": "import java.util.ArrayList;\n\nimport java.util.Collections;\n\nimport java.util.Iterator;\n\nimport java.util.List;\n\nimport java.util.ListIterator;\n\nimport java.util.regex.Matcher;\n\nimport java.util.regex.Pattern;\n",
      "comment": "",
      "packageName": "org.syphr.prom",
      "method_signature": "public boolean isReferencing(String rawValue, String name, Retriever retriever);",
      "Junit_version": "4",
      "returnType": "boolean"
    },
    "Test_method": {
      "Method_body": "Assert.assertTrue(\"Raw value \\\"\" + RAW_VALUE_4 + \"\\\" should contain a nested reference to \\\"\" + KEY_2 + \"\\\"\", evaluator.isReferencing(RAW_VALUE_4, KEY_2, retriever));\n\rAssert.assertFalse(\"Raw value \\\"\" + RAW_VALUE_3 + \"\\\" should not contain a nested reference to \\\"\" + KEY_4 + \"\\\"\", evaluator.isReferencing(RAW_VALUE_3, KEY_4, retriever));",
      "sub_project_name": "syphr42_prom",
      "lineNumbers": "2",
      "Filed": "private static final String KEY_2 = \"test2\";private static final String RAW_VALUE_3 = \"prefix \" + KEY_1_VAR + \" middle \" + KEY_2_VAR + \" suffix\";/*\n     * Key4 contains a direct reference to Key3 and indirect references to Key1\n     * and Key2.\n     */\nprivate static final String KEY_4 = \"test4\";private static final String RAW_VALUE_4 = \"nested ${\" + KEY_3 + \"} variables\";private static Retriever retriever;private static DefaultEvaluator evaluator;",
      "Import_statements": "import junit.framework.Assert;\n",
      "allMethod_info": "@Test\npublic void testIsReferencing() {\n    Assert.assertTrue(\"Raw value \\\"\" + RAW_VALUE_4 + \"\\\" should contain a nested reference to \\\"\" + KEY_2 + \"\\\"\", evaluator.isReferencing(RAW_VALUE_4, KEY_2, retriever));\n    Assert.assertFalse(\"Raw value \\\"\" + RAW_VALUE_3 + \"\\\" should not contain a nested reference to \\\"\" + KEY_4 + \"\\\"\", evaluator.isReferencing(RAW_VALUE_3, KEY_4, retriever));\n}",
      "Method_name": "testIsReferencing",
      "Class_declaration": "public class DefaultEvaluatorTest {\n",
      "constructors": "",
      "Class_name": "DefaultEvaluatorTest",
      "methodName_paraNum": "[isReferencing(3), isReferencing(3)]",
      "project_path": "syphr42_prom###syphr42_prom/src/test/java/org/syphr/prom/DefaultEvaluatorTest###testIsReferencing",
      "relativePath": "syphr42_prom/src/test/java/org/syphr/prom/DefaultEvaluatorTest.java",
      "Signature": "public void testIsReferencing() {\n",
      "all_Import_statements": "import java.util.List;\n\nimport java.util.Properties;\n\nimport java.util.concurrent.ExecutorService;\n\nimport java.util.concurrent.Executors;\n\nimport junit.framework.Assert;\n\nimport org.junit.BeforeClass;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.syphr.prom",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic Reference referenceAt(String rawValue, int position, Retriever retriever) {\n    if (rawValue == null) {\n        return null;\n    }\n    Evaluation eval = new Evaluation(rawValue, retriever);\n    eval.parse();\n    return eval.referenceAt(position);\n}",
      "all_field_declaration": "/**\n * The pattern used to detect property references in the style of Ant.\n */\nprivate static final Pattern PATTERN = Pattern.compile(\"\\\\$\\\\{(.+?)\\\\}\");",
      "sub_project_name": "syphr42_prom",
      "lineNumbers": "4",
      "Filed": "",
      "Parameter_type": "String,int,Retriever",
      "Import_statements": "",
      "public_method_signature": "public String evaluate(String rawValue, Retriever retriever);\npublic Reference referenceAt(String rawValue, int position, Retriever retriever);\npublic boolean isReferencing(String rawValue, String name, Retriever retriever);\npublic List<Reference> getReferences(String rawValue, Retriever retriever);",
      "public_field": "",
      "Method_statement": "referenceAt(String rawValue, int position, Retriever retriever)",
      "Method_name": "referenceAt",
      "Class_declaration": "public class DefaultEvaluator {\n",
      "constructors": "",
      "all_method_signature": "public String evaluate(String rawValue, Retriever retriever);\npublic Reference referenceAt(String rawValue, int position, Retriever retriever);\npublic boolean isReferencing(String rawValue, String name, Retriever retriever);\npublic List<Reference> getReferences(String rawValue, Retriever retriever);",
      "Class_name": "DefaultEvaluator",
      "project_path": "syphr42_prom###syphr42_prom/src/main/java/org/syphr/prom/DefaultEvaluator###referenceAt",
      "Parameter_num": "3",
      "all_Import_statements": "import java.util.ArrayList;\n\nimport java.util.Collections;\n\nimport java.util.Iterator;\n\nimport java.util.List;\n\nimport java.util.ListIterator;\n\nimport java.util.regex.Matcher;\n\nimport java.util.regex.Pattern;\n",
      "comment": "",
      "packageName": "org.syphr.prom",
      "method_signature": "public Reference referenceAt(String rawValue, int position, Retriever retriever);",
      "Junit_version": "4",
      "returnType": "Reference"
    },
    "Test_method": {
      "Method_body": "final int position = 9;\n\rReference variable = evaluator.referenceAt(RAW_VALUE_3, position, retriever);\n\rAssert.assertNotNull(\"Variable was not found at position \" + position + \" in \\\"\" + RAW_VALUE_3 + \"\\\"\", variable);\n\rAssert.assertEquals(\"Substring of \\\"\" + RAW_VALUE_3 + \"\\\" using computed start/end positions does not match expected\", KEY_1_VAR, RAW_VALUE_3.substring(variable.getStartPosition(), variable.getEndPosition()));",
      "sub_project_name": "syphr42_prom",
      "lineNumbers": "4",
      "Filed": "private static final String KEY_1 = \"test1\";private static final String KEY_1_VAR = \"${\" + KEY_1 + \"}\";private static final String RAW_VALUE_3 = \"prefix \" + KEY_1_VAR + \" middle \" + KEY_2_VAR + \" suffix\";private static Retriever retriever;private static DefaultEvaluator evaluator;",
      "Import_statements": "import junit.framework.Assert;\n",
      "allMethod_info": "@Test\npublic void testReferenceAt() {\n    final int position = 9;\n    Reference variable = evaluator.referenceAt(RAW_VALUE_3, position, retriever);\n    Assert.assertNotNull(\"Variable was not found at position \" + position + \" in \\\"\" + RAW_VALUE_3 + \"\\\"\", variable);\n    Assert.assertEquals(\"Substring of \\\"\" + RAW_VALUE_3 + \"\\\" using computed start/end positions does not match expected\", KEY_1_VAR, RAW_VALUE_3.substring(variable.getStartPosition(), variable.getEndPosition()));\n}",
      "Method_name": "testReferenceAt",
      "Class_declaration": "public class DefaultEvaluatorTest {\n",
      "constructors": "",
      "Class_name": "DefaultEvaluatorTest",
      "methodName_paraNum": "[referenceAt(3), substring(2), getStartPosition(0), getEndPosition(0)]",
      "project_path": "syphr42_prom###syphr42_prom/src/test/java/org/syphr/prom/DefaultEvaluatorTest###testReferenceAt",
      "relativePath": "syphr42_prom/src/test/java/org/syphr/prom/DefaultEvaluatorTest.java",
      "Signature": "public void testReferenceAt() {\n",
      "all_Import_statements": "import java.util.List;\n\nimport java.util.Properties;\n\nimport java.util.concurrent.ExecutorService;\n\nimport java.util.concurrent.Executors;\n\nimport junit.framework.Assert;\n\nimport org.junit.BeforeClass;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.syphr.prom",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic boolean putObject(FedoraObject o, StoreConnector source, boolean overwrite, boolean copyExternal, boolean copyRedirect) {\n    boolean existed = hasObject(o.pid());\n    if (existed) {\n        if (!overwrite) {\n            return existed;\n        }\n    }\n    FOXMLWriter writer = new FOXMLWriter();\n    File tempFile = null;\n    DigestOutputStream out = null;\n    try {\n        for (Datastream ds : o.datastreams().values()) {\n            ControlGroup c = ds.controlGroup();\n            if ((c.equals(ControlGroup.EXTERNAL) && copyExternal) || (c.equals(ControlGroup.REDIRECT) && copyRedirect)) {\n                ds.controlGroup(ControlGroup.MANAGED);\n            }\n        }\n        tempFile = File.createTempFile(\"cloudsync\", null);\n        OutputStream fileOut = new FileOutputStream(tempFile);\n        MessageDigest digest = createMd5Digest();\n        out = new DigestOutputStream(fileOut, digest);\n        writer.writeObject(o, out);\n        out.close();\n        String md5 = ChecksumUtil.checksumBytesToString(digest.digest());\n        putObject(o, source, tempFile, md5);\n        return existed;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    } finally {\n        IOUtils.closeQuietly(out);\n        if (tempFile != null) {\n            tempFile.delete();\n        }\n        writer.close();\n    }\n}",
      "all_field_declaration": "private static final Logger logger = LoggerFactory.getLogger(DuraCloudConnector.class);\nprivate static final int CHUNKSIZE = 999;\n// one GB\nprivate long MAX_CONTENT_CHUNK_SIZE = 1073741824;\nprivate final URI spaceURI;\nprivate final String providerId;\nprivate final String prefix;\nprivate final MultiThreadedHttpClient httpClient;",
      "sub_project_name": "fcrepo-cloudsync-service",
      "lineNumbers": "6",
      "Filed": "",
      "Parameter_type": "FedoraObject,StoreConnector,boolean,boolean,boolean",
      "Import_statements": "import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport org.apache.commons.io.IOUtils;\nimport org.duracloud.common.util.ChecksumUtil;\nimport com.github.cwilper.fcrepo.dto.core.ControlGroup;\nimport com.github.cwilper.fcrepo.dto.core.Datastream;\nimport com.github.cwilper.fcrepo.dto.core.FedoraObject;\nimport com.github.cwilper.fcrepo.dto.foxml.FOXMLWriter;\n",
      "public_method_signature": "public DuraCloudConnector(ObjectStore store, HttpClientConfig httpClientConfig);\npublic DuraCloudConnector(URI spaceURI, String providerId, String prefix, MultiThreadedHttpClient httpClient, long contentChunkSize);\npublic void listObjects(ObjectQuery query, ObjectListHandler handler);\npublic FedoraObject getObject(String pid);\npublic boolean putObject(FedoraObject o, StoreConnector source, boolean overwrite, boolean copyExternal, boolean copyRedirect);\npublic InputStream getContent(FedoraObject o, Datastream ds, DatastreamVersion dsv);\npublic InputStream getStream(String contentId);\npublic void close();",
      "public_field": "",
      "Method_statement": "putObject(FedoraObject o, StoreConnector source, boolean overwrite, boolean copyExternal, boolean copyRedirect)",
      "Method_name": "putObject",
      "Class_declaration": "public class DuraCloudConnector {\n",
      "constructors": "public DuraCloudConnector(ObjectStore store, HttpClientConfig httpClientConfig) {\n    Map<String, String> map = JSON.getMap(JSON.parse(store.getData()));\n    providerId = StringUtil.validate(\"providerId\", map.get(\"providerId\"));\n    prefix = StringUtil.normalize(map.get(\"prefix\"));\n    String duraStoreUrl = StringUtil.validate(\"url\", map.get(\"url\"));\n    while (duraStoreUrl.endsWith(\"/\")) {\n        duraStoreUrl = duraStoreUrl.substring(0, duraStoreUrl.length() - 1);\n    }\n    String space = StringUtil.validate(\"space\", map.get(\"space\"));\n    spaceURI = URI.create(duraStoreUrl + \"/\" + space);\n    int port = spaceURI.getPort();\n    if (port <= 0) {\n        if (spaceURI.getScheme().equals(\"http\")) {\n            port = 80;\n        } else {\n            port = 443;\n        }\n    }\n    httpClient = new MultiThreadedHttpClient(httpClientConfig);\n    String username = StringUtil.validate(\"username\", map.get(\"username\"));\n    String password = StringUtil.validate(\"password\", map.get(\"password\"));\n    httpClient.getCredentialsProvider().setCredentials(new AuthScope(spaceURI.getHost(), port), new UsernamePasswordCredentials(username, password));\n}public DuraCloudConnector(URI spaceURI, String providerId, String prefix, MultiThreadedHttpClient httpClient, long contentChunkSize) {\n    this.spaceURI = spaceURI;\n    this.providerId = providerId;\n    this.prefix = prefix;\n    this.httpClient = httpClient;\n    this.MAX_CONTENT_CHUNK_SIZE = contentChunkSize;\n}",
      "all_method_signature": "public DuraCloudConnector(ObjectStore store, HttpClientConfig httpClientConfig);\npublic DuraCloudConnector(URI spaceURI, String providerId, String prefix, MultiThreadedHttpClient httpClient, long contentChunkSize);\npublic void listObjects(ObjectQuery query, ObjectListHandler handler);\nprotected boolean hasObject(String pid);\npublic FedoraObject getObject(String pid);\npublic boolean putObject(FedoraObject o, StoreConnector source, boolean overwrite, boolean copyExternal, boolean copyRedirect);\nprivate MessageDigest createMd5Digest();\nprivate void putObject(FedoraObject o, StoreConnector source, File foxmlFile, String md5) throws IOException;\nprivate void putVersions(FedoraObject o, Datastream ds, StoreConnector source, Set<String> urls) throws IOException;\nprivate void putChunks(File tempFile, String contentId, String mimeType, String md5, Set<String> urls) throws IOException;\nprivate void putFile(File file, String contentId, String mimeType, String md5, Set<String> urls);\nprivate void putStream(InputStream inputStream, String contentId, String mimeType, Set<String> urls) throws IOException;\nprivate String copyToTempFile(InputStream in, File tmpFile) throws IOException;\nprivate File copyToTempFile(InputStream in) throws IOException;\nprivate void copy(InputStream in, OutputStream out) throws IOException;\nprivate String getContentURI(String contentId);\npublic InputStream getContent(FedoraObject o, Datastream ds, DatastreamVersion dsv);\npublic InputStream getStream(String contentId);\npublic void close();\nprivate void listObjects(Filter<String> filter, ObjectListHandler handler);\nprivate List<String> getNextChunk(String marker, int maxResults);\nprivate static Document parseXML(String xmlString) throws ParserConfigurationException, IOException, SAXException;",
      "Class_name": "DuraCloudConnector",
      "project_path": "duraspace_fcrepo-cloudsync###duraspace_fcrepo-cloudsync/fcrepo-cloudsync-service/src/main/java/org/duraspace/fcrepo/cloudsync/service/backend/DuraCloudConnector###putObject",
      "Parameter_num": "5",
      "all_Import_statements": "import java.io.File;\n\nimport java.io.FileInputStream;\n\nimport java.io.FileOutputStream;\n\nimport java.io.IOException;\n\nimport java.io.InputStream;\n\nimport java.io.OutputStream;\n\nimport java.io.StringReader;\n\nimport java.net.URI;\n\nimport java.security.DigestInputStream;\n\nimport java.security.DigestOutputStream;\n\nimport java.security.MessageDigest;\n\nimport java.security.NoSuchAlgorithmException;\n\nimport java.util.ArrayList;\n\nimport java.util.HashSet;\n\nimport java.util.List;\n\nimport java.util.Map;\n\nimport java.util.Set;\n\nimport java.util.TreeMap;\n\nimport javax.xml.parsers.DocumentBuilder;\n\nimport javax.xml.parsers.DocumentBuilderFactory;\n\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.apache.commons.io.IOUtils;\n\nimport org.apache.http.auth.AuthScope;\n\nimport org.apache.http.auth.UsernamePasswordCredentials;\n\nimport org.duracloud.chunk.ChunkableContent;\n\nimport org.duracloud.chunk.manifest.ChunksManifest;\n\nimport org.duracloud.chunk.manifest.ChunksManifestBean;\n\nimport org.duracloud.chunk.manifest.xml.ManifestDocumentBinding;\n\nimport org.duracloud.chunk.stream.ChunkInputStream;\n\nimport org.duracloud.common.util.ChecksumUtil;\n\nimport org.duraspace.fcrepo.cloudsync.service.backend.chunk.MultiChunkInputStream;\n\nimport org.slf4j.Logger;\n\nimport org.slf4j.LoggerFactory;\n\nimport org.w3c.dom.Document;\n\nimport org.w3c.dom.Node;\n\nimport org.w3c.dom.NodeList;\n\nimport org.xml.sax.InputSource;\n\nimport org.xml.sax.SAXException;\n\nimport org.duraspace.fcrepo.cloudsync.api.ObjectInfo;\n\nimport org.duraspace.fcrepo.cloudsync.api.ObjectStore;\n\nimport org.duraspace.fcrepo.cloudsync.service.util.JSON;\n\nimport org.duraspace.fcrepo.cloudsync.service.util.StringUtil;\n\nimport com.github.cwilper.fcrepo.dto.core.ControlGroup;\n\nimport com.github.cwilper.fcrepo.dto.core.Datastream;\n\nimport com.github.cwilper.fcrepo.dto.core.DatastreamVersion;\n\nimport com.github.cwilper.fcrepo.dto.core.FedoraObject;\n\nimport com.github.cwilper.fcrepo.dto.foxml.FOXMLReader;\n\nimport com.github.cwilper.fcrepo.dto.foxml.FOXMLWriter;\n\nimport com.github.cwilper.fcrepo.httpclient.HttpClientConfig;\n\nimport com.github.cwilper.fcrepo.httpclient.MultiThreadedHttpClient;\n\nimport com.github.cwilper.ttff.Filter;\n",
      "comment": "",
      "packageName": "org.duraspace.fcrepo.cloudsync.service.backend",
      "method_signature": "public boolean putObject(FedoraObject o, StoreConnector source, boolean overwrite, boolean copyExternal, boolean copyRedirect);",
      "Junit_version": "4",
      "returnType": "boolean"
    },
    "Test_method": {
      "Method_body": "createMocksPutObject();\n\rreplayMocks();\n\rFedoraObject obj = createFedoraObject();\n\rboolean overwrite = true;\n\rboolean copyExternal = true;\n\rboolean copyRedirect = true;\n\rboolean existed = connector.putObject(obj, source, overwrite, copyExternal, copyRedirect);\n\rAssert.assertTrue(existed);",
      "sub_project_name": "fcrepo-cloudsync-service",
      "lineNumbers": "8",
      "Filed": "private DuraCloudConnector connector;private StoreConnector source;",
      "Import_statements": "import com.github.cwilper.fcrepo.dto.core.FedoraObject;\nimport junit.framework.Assert;\n",
      "allMethod_info": "@Test\npublic void testPutObject() throws Exception {\n    createMocksPutObject();\n    replayMocks();\n    FedoraObject obj = createFedoraObject();\n    boolean overwrite = true;\n    boolean copyExternal = true;\n    boolean copyRedirect = true;\n    boolean existed = connector.putObject(obj, source, overwrite, copyExternal, copyRedirect);\n    Assert.assertTrue(existed);\n}",
      "Method_name": "testPutObject",
      "Class_declaration": "public class DuraCloudConnectorTest {\n",
      "constructors": "",
      "Class_name": "DuraCloudConnectorTest",
      "methodName_paraNum": "[createMocksPutObject(0), replayMocks(0), createFedoraObject(0), putObject(5)]",
      "project_path": "duraspace_fcrepo-cloudsync###duraspace_fcrepo-cloudsync/fcrepo-cloudsync-service/src/test/java/org/duraspace/fcrepo/cloudsync/service/backend/DuraCloudConnectorTest###testPutObject",
      "relativePath": "duraspace_fcrepo-cloudsync/fcrepo-cloudsync-service/src/test/java/org/duraspace/fcrepo/cloudsync/service/backend/DuraCloudConnectorTest.java",
      "Signature": "public void testPutObject() {\n",
      "all_Import_statements": "import com.github.cwilper.fcrepo.dto.core.ControlGroup;\n\nimport com.github.cwilper.fcrepo.dto.core.Datastream;\n\nimport com.github.cwilper.fcrepo.dto.core.DatastreamVersion;\n\nimport com.github.cwilper.fcrepo.dto.core.FedoraObject;\n\nimport com.github.cwilper.fcrepo.httpclient.MultiThreadedHttpClient;\n\nimport junit.framework.Assert;\n\nimport org.apache.commons.io.IOUtils;\n\nimport org.apache.commons.io.input.AutoCloseInputStream;\n\nimport org.apache.http.HttpResponse;\n\nimport org.apache.http.StatusLine;\n\nimport org.apache.http.client.methods.HttpHead;\n\nimport org.apache.http.client.methods.HttpPut;\n\nimport org.easymock.EasyMock;\n\nimport org.junit.After;\n\nimport org.junit.Before;\n\nimport org.junit.BeforeClass;\n\nimport org.junit.Test;\n\nimport org.junit.runner.RunWith;\n\nimport org.powermock.api.easymock.PowerMock;\n\nimport org.powermock.core.classloader.annotations.PrepareForTest;\n\nimport org.powermock.modules.junit4.PowerMockRunner;\n\nimport java.io.BufferedWriter;\n\nimport java.io.ByteArrayInputStream;\n\nimport java.io.ByteArrayOutputStream;\n\nimport java.io.OutputStreamWriter;\n\nimport java.net.URI;\n\nimport java.util.Date;\n\nimport java.util.Random;\n",
      "comment": "",
      "packageName": "org.duraspace.fcrepo.cloudsync.service.backend",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "static Token[] lexx(final String format) {\n    final ArrayList<Token> list = new ArrayList<>(format.length());\n    boolean inLiteral = false;\n    StringBuilder buffer = null;\n    Token previous = null;\n    for (int i = 0; i < format.length(); i++) {\n        final char ch = format.charAt(i);\n        if (inLiteral && ch != '\\'') {\n            buffer.append(ch);\n            continue;\n        }\n        Object value = null;\n        switch(ch) {\n            case '\\'':\n                if (inLiteral) {\n                    buffer = null;\n                    inLiteral = false;\n                } else {\n                    buffer = new StringBuilder();\n                    list.add(new Token(buffer));\n                    inLiteral = true;\n                }\n                break;\n            case 'y':\n                value = y;\n                break;\n            case 'M':\n                value = M;\n                break;\n            case 'd':\n                value = d;\n                break;\n            case 'H':\n                value = H;\n                break;\n            case 'm':\n                value = m;\n                break;\n            case 's':\n                value = s;\n                break;\n            case 'S':\n                value = S;\n                break;\n            default:\n                if (buffer == null) {\n                    buffer = new StringBuilder();\n                    list.add(new Token(buffer));\n                }\n                buffer.append(ch);\n        }\n        if (value != null) {\n            if (previous != null && previous.getValue().equals(value)) {\n                previous.increment();\n            } else {\n                final Token token = new Token(value);\n                list.add(token);\n                previous = token;\n            }\n            buffer = null;\n        }\n    }\n    if (inLiteral) {\n        throw new IllegalArgumentException(\"Unmatched quote in format: \" + format);\n    }\n    return list.toArray(new Token[list.size()]);\n}",
      "all_field_declaration": "/**\n * <p>Pattern used with <code>FastDateFormat</code> and <code>SimpleDateFormat</code>\n * for the ISO 8601 period format used in durations.</p>\n *\n * @see org.apache.commons.lang3.time.FastDateFormat\n * @see java.text.SimpleDateFormat\n */\npublic static final String ISO_EXTENDED_FORMAT_PATTERN = \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.SSS'S'\";\nstatic final Object y = \"y\";\nstatic final Object M = \"M\";\nstatic final Object d = \"d\";\nstatic final Object H = \"H\";\nstatic final Object m = \"m\";\nstatic final Object s = \"s\";\nstatic final Object S = \"S\";",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "7",
      "Filed": "static final Object y = \"y\";static final Object M = \"M\";static final Object d = \"d\";static final Object H = \"H\";static final Object m = \"m\";static final Object s = \"s\";static final Object S = \"S\";",
      "Parameter_type": "String",
      "Import_statements": "import java.util.ArrayList;\n",
      "public_method_signature": "public DurationFormatUtils();\npublic static String formatDurationHMS(final long durationMillis);\npublic static String formatDurationISO(final long durationMillis);\npublic static String formatDuration(final long durationMillis, final String format);\npublic static String formatDuration(final long durationMillis, final String format, final boolean padWithZeros);\npublic static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements);\npublic static String formatPeriodISO(final long startMillis, final long endMillis);\npublic static String formatPeriod(final long startMillis, final long endMillis, final String format);\npublic static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone);",
      "public_field": "/**\n * <p>Pattern used with <code>FastDateFormat</code> and <code>SimpleDateFormat</code>\n * for the ISO 8601 period format used in durations.</p>\n *\n * @see org.apache.commons.lang3.time.FastDateFormat\n * @see java.text.SimpleDateFormat\n */\npublic static final String ISO_EXTENDED_FORMAT_PATTERN = \"'P'yyyy'Y'M'M'd'DT'H'H'm'M's.SSS'S'\";",
      "Method_statement": "lexx(final String format)",
      "Method_name": "lexx",
      "Class_declaration": "public class DurationFormatUtils {\n",
      "constructors": "public DurationFormatUtils() {\n    super();\n}",
      "all_method_signature": "public DurationFormatUtils();\npublic static String formatDurationHMS(final long durationMillis);\npublic static String formatDurationISO(final long durationMillis);\npublic static String formatDuration(final long durationMillis, final String format);\npublic static String formatDuration(final long durationMillis, final String format, final boolean padWithZeros);\npublic static String formatDurationWords(final long durationMillis, final boolean suppressLeadingZeroElements, final boolean suppressTrailingZeroElements);\npublic static String formatPeriodISO(final long startMillis, final long endMillis);\npublic static String formatPeriod(final long startMillis, final long endMillis, final String format);\npublic static String formatPeriod(final long startMillis, final long endMillis, final String format, final boolean padWithZeros, final TimeZone timezone);\n static String format(final Token[] tokens, final long years, final long months, final long days, final long hours, final long minutes, final long seconds, final long milliseconds, final boolean padWithZeros);\nprivate static String paddedValue(final long value, final boolean padWithZeros, final int count);\n static Token[] lexx(final String format);",
      "Class_name": "DurationFormatUtils",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/time/DurationFormatUtils###lexx",
      "Parameter_num": "1",
      "all_Import_statements": "import java.util.ArrayList;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n\nimport java.util.GregorianCalendar;\n\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang3.StringUtils;\n\nimport org.apache.commons.lang3.Validate;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * Parses a classic date format string into Tokens\n     *\n     * @param format  the format to parse, not null\n     * @return array of Token[]\n     ",
      "packageName": "org.apache.commons.lang3.time",
      "method_signature": " static Token[] lexx(final String format);",
      "Junit_version": "4",
      "returnType": "Token[]"
    },
    "Test_method": {
      "Method_body": "// tests each constant\nassertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1) }, DurationFormatUtils.lexx(\"yMdHmsS\"));\n\r// tests the ISO 8601-like\nassertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.H, 2), new DurationFormatUtils.Token(new StringBuilder(\":\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(\":\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 2), new DurationFormatUtils.Token(new StringBuilder(\".\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3) }, DurationFormatUtils.lexx(\"HH:mm:ss.SSS\"));\n\r// test the iso extended format\nassertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder(\"P\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.y, 4), new DurationFormatUtils.Token(new StringBuilder(\"Y\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(new StringBuilder(\"M\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(new StringBuilder(\"DT\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(new StringBuilder(\"H\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(new StringBuilder(\"M\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(new StringBuilder(\".\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3), new DurationFormatUtils.Token(new StringBuilder(\"S\"), 1) }, DurationFormatUtils.lexx(DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN));\n\r// test failures in equals\nfinal DurationFormatUtils.Token token = new DurationFormatUtils.Token(DurationFormatUtils.y, 4);\n\rassertFalse(\"Token equal to non-Token class. \", token.equals(new Object()));\n\rassertFalse(\"Token equal to Token with wrong value class. \", token.equals(new DurationFormatUtils.Token(new Object())));\n\rassertFalse(\"Token equal to Token with different count. \", token.equals(new DurationFormatUtils.Token(DurationFormatUtils.y, 1)));\n\rfinal DurationFormatUtils.Token numToken = new DurationFormatUtils.Token(Integer.valueOf(1), 4);\n\rassertTrue(\"Token with Number value not equal to itself. \", numToken.equals(numToken));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "9",
      "Filed": "",
      "Import_statements": "import static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n",
      "allMethod_info": "@Test\npublic void testLexx() {\n    // tests each constant\n    assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.y, 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 1) }, DurationFormatUtils.lexx(\"yMdHmsS\"));\n    // tests the ISO 8601-like\n    assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(DurationFormatUtils.H, 2), new DurationFormatUtils.Token(new StringBuilder(\":\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 2), new DurationFormatUtils.Token(new StringBuilder(\":\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 2), new DurationFormatUtils.Token(new StringBuilder(\".\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3) }, DurationFormatUtils.lexx(\"HH:mm:ss.SSS\"));\n    // test the iso extended format\n    assertArrayEquals(new DurationFormatUtils.Token[] { new DurationFormatUtils.Token(new StringBuilder(\"P\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.y, 4), new DurationFormatUtils.Token(new StringBuilder(\"Y\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.M, 1), new DurationFormatUtils.Token(new StringBuilder(\"M\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.d, 1), new DurationFormatUtils.Token(new StringBuilder(\"DT\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.H, 1), new DurationFormatUtils.Token(new StringBuilder(\"H\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.m, 1), new DurationFormatUtils.Token(new StringBuilder(\"M\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.s, 1), new DurationFormatUtils.Token(new StringBuilder(\".\"), 1), new DurationFormatUtils.Token(DurationFormatUtils.S, 3), new DurationFormatUtils.Token(new StringBuilder(\"S\"), 1) }, DurationFormatUtils.lexx(DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN));\n    // test failures in equals\n    final DurationFormatUtils.Token token = new DurationFormatUtils.Token(DurationFormatUtils.y, 4);\n    assertFalse(\"Token equal to non-Token class. \", token.equals(new Object()));\n    assertFalse(\"Token equal to Token with wrong value class. \", token.equals(new DurationFormatUtils.Token(new Object())));\n    assertFalse(\"Token equal to Token with different count. \", token.equals(new DurationFormatUtils.Token(DurationFormatUtils.y, 1)));\n    final DurationFormatUtils.Token numToken = new DurationFormatUtils.Token(Integer.valueOf(1), 4);\n    assertTrue(\"Token with Number value not equal to itself. \", numToken.equals(numToken));\n}",
      "Method_name": "testLexx",
      "Class_declaration": "public class DurationFormatUtilsTest {\n",
      "constructors": "",
      "Class_name": "DurationFormatUtilsTest",
      "methodName_paraNum": "[lexx(1), lexx(1), lexx(1), equals(1), equals(1), equals(1), valueOf(1), equals(1)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/time/DurationFormatUtilsTest###testLexx",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/time/DurationFormatUtilsTest.java",
      "Signature": "public void testLexx() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertArrayEquals;\n\nimport static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.lang.reflect.Constructor;\n\nimport java.lang.reflect.Modifier;\n\nimport java.util.Calendar;\n\nimport java.util.TimeZone;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3.time",
      "Junit_version": "4"
    }
  },
  {
    "Under_test_method": {
      "Method_body": "@Override\npublic boolean equals(final Object obj) {\n    if (!(obj instanceof FastDatePrinter)) {\n        return false;\n    }\n    final FastDatePrinter other = (FastDatePrinter) obj;\n    return mPattern.equals(other.mPattern) && mTimeZone.equals(other.mTimeZone) && mLocale.equals(other.mLocale);\n}",
      "all_field_declaration": "// A lot of the speed in this class comes from caching, but some comes\n// from the special int to StringBuffer conversion.\n// \n// The following produces a padded 2 digit number:\n// buffer.append((char)(value / 10 + '0'));\n// buffer.append((char)(value % 10 + '0'));\n// \n// Note that the fastest append to StringBuffer is a single char (used here).\n// Note that Integer.toString() is not called, the conversion is simply\n// taking the value and adding (mathematically) the ASCII value for '0'.\n// So, don't change this code! It works and is very fast.\n/**\n * Required for serialization support.\n *\n * @see java.io.Serializable\n */\nprivate static final long serialVersionUID = 1L;\n/**\n * FULL locale dependent date or time style.\n */\npublic static final int FULL = DateFormat.FULL;\n/**\n * LONG locale dependent date or time style.\n */\npublic static final int LONG = DateFormat.LONG;\n/**\n * MEDIUM locale dependent date or time style.\n */\npublic static final int MEDIUM = DateFormat.MEDIUM;\n/**\n * SHORT locale dependent date or time style.\n */\npublic static final int SHORT = DateFormat.SHORT;\n/**\n * The pattern.\n */\nprivate final String mPattern;\n/**\n * The time zone.\n */\nprivate final TimeZone mTimeZone;\n/**\n * The locale.\n */\nprivate final Locale mLocale;\n/**\n * The parsed rules.\n */\nprivate transient Rule[] mRules;\n/**\n * The estimated maximum length.\n */\nprivate transient int mMaxLengthEstimate;\nprivate static final int MAX_DIGITS = 10;\nprivate static final ConcurrentMap<TimeZoneDisplayKey, String> cTimeZoneDisplayCache = new ConcurrentHashMap<>(7);",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "3",
      "Filed": "private final String mPattern;private final TimeZone mTimeZone;private final Locale mLocale;",
      "Parameter_type": "Object",
      "Import_statements": "import java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\n",
      "public_method_signature": "public StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos);\npublic String format(final long millis);\npublic String format(final Date date);\npublic String format(final Calendar calendar);\npublic StringBuffer format(final long millis, final StringBuffer buf);\npublic StringBuffer format(final Date date, final StringBuffer buf);\npublic StringBuffer format(final Calendar calendar, final StringBuffer buf);\npublic B format(final long millis, final B buf);\npublic B format(final Date date, final B buf);\npublic B format(Calendar calendar, final B buf);\npublic String getPattern();\npublic TimeZone getTimeZone();\npublic Locale getLocale();\npublic int getMaxLengthEstimate();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();",
      "public_field": "/**\n * FULL locale dependent date or time style.\n */\npublic static final int FULL = DateFormat.FULL;\n/**\n * LONG locale dependent date or time style.\n */\npublic static final int LONG = DateFormat.LONG;\n/**\n * MEDIUM locale dependent date or time style.\n */\npublic static final int MEDIUM = DateFormat.MEDIUM;\n/**\n * SHORT locale dependent date or time style.\n */\npublic static final int SHORT = DateFormat.SHORT;",
      "Method_statement": "equals(final Object obj)",
      "Method_name": "equals",
      "Class_declaration": "public class FastDatePrinter {\n",
      "constructors": "protected FastDatePrinter(final String pattern, final TimeZone timeZone, final Locale locale) {\n    mPattern = pattern;\n    mTimeZone = timeZone;\n    mLocale = locale;\n    init();\n}",
      "all_method_signature": "protected FastDatePrinter(final String pattern, final TimeZone timeZone, final Locale locale);\nprivate void init();\nprotected List<Rule> parsePattern();\nprotected String parseToken(final String pattern, final int[] indexRef);\nprotected NumberRule selectNumberRule(final int field, final int padding);\npublic StringBuffer format(final Object obj, final StringBuffer toAppendTo, final FieldPosition pos);\n String format(final Object obj);\npublic String format(final long millis);\nprivate String applyRulesToString(final Calendar c);\nprivate Calendar newCalendar();\npublic String format(final Date date);\npublic String format(final Calendar calendar);\npublic StringBuffer format(final long millis, final StringBuffer buf);\npublic StringBuffer format(final Date date, final StringBuffer buf);\npublic StringBuffer format(final Calendar calendar, final StringBuffer buf);\npublic B format(final long millis, final B buf);\npublic B format(final Date date, final B buf);\npublic B format(Calendar calendar, final B buf);\nprotected StringBuffer applyRules(final Calendar calendar, final StringBuffer buf);\nprivate B applyRules(final Calendar calendar, final B buf);\npublic String getPattern();\npublic TimeZone getTimeZone();\npublic Locale getLocale();\npublic int getMaxLengthEstimate();\npublic boolean equals(final Object obj);\npublic int hashCode();\npublic String toString();\nprivate void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException;\nprivate static void appendDigits(final Appendable buffer, final int value) throws IOException;\nprivate static void appendFullDigits(final Appendable buffer, int value, int minFieldWidth) throws IOException;\n static String getTimeZoneDisplay(final TimeZone tz, final boolean daylight, final int style, final Locale locale);",
      "Class_name": "FastDatePrinter",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/main/java/org/apache/commons/lang3/time/FastDatePrinter###equals",
      "Parameter_num": "1",
      "all_Import_statements": "import java.io.IOException;\n\nimport java.io.ObjectInputStream;\n\nimport java.io.Serializable;\n\nimport java.text.DateFormat;\n\nimport java.text.DateFormatSymbols;\n\nimport java.text.FieldPosition;\n\nimport java.util.ArrayList;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n\nimport java.util.List;\n\nimport java.util.Locale;\n\nimport java.util.TimeZone;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.apache.commons.lang3.exception.ExceptionUtils;\n\nimport com.google.gwt.core.shared.GwtIncompatible;\n",
      "comment": "\n     * <p>Compares two objects for equality.</p>\n     *\n     * @param obj  the object to compare to\n     * @return {@code true} if equal\n     ",
      "packageName": "org.apache.commons.lang3.time",
      "method_signature": "public boolean equals(final Object obj);",
      "Junit_version": "4",
      "returnType": "boolean"
    },
    "Test_method": {
      "Method_body": "final DatePrinter printer1 = getInstance(YYYY_MM_DD);\n\rfinal DatePrinter printer2 = getInstance(YYYY_MM_DD);\n\rassertEquals(printer1, printer2);\n\rassertEquals(printer1.hashCode(), printer2.hashCode());\n\rassertFalse(printer1.equals(new Object()));",
      "sub_project_name": "ManfredTremmel_gwt-commons-lang3",
      "lineNumbers": "5",
      "Filed": "private static final String YYYY_MM_DD = \"yyyy/MM/dd\";",
      "Import_statements": "import static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport java.util.Date;\n",
      "allMethod_info": "@Test\npublic void testEquals() {\n    final DatePrinter printer1 = getInstance(YYYY_MM_DD);\n    final DatePrinter printer2 = getInstance(YYYY_MM_DD);\n    assertEquals(printer1, printer2);\n    assertEquals(printer1.hashCode(), printer2.hashCode());\n    assertFalse(printer1.equals(new Object()));\n}",
      "Method_name": "testEquals",
      "Class_declaration": "public class FastDatePrinterTest {\n",
      "constructors": "",
      "Class_name": "FastDatePrinterTest",
      "methodName_paraNum": "[getInstance(1), getInstance(1), hashCode(0), hashCode(0), equals(1)]",
      "project_path": "ManfredTremmel_gwt-commons-lang3###ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest###testEquals",
      "relativePath": "ManfredTremmel_gwt-commons-lang3/src/test/java/org/apache/commons/lang3/time/FastDatePrinterTest.java",
      "Signature": "public void testEquals() {\n",
      "all_Import_statements": "import static org.junit.Assert.assertEquals;\n\nimport static org.junit.Assert.assertFalse;\n\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.Serializable;\n\nimport java.text.FieldPosition;\n\nimport java.text.ParseException;\n\nimport java.text.SimpleDateFormat;\n\nimport java.util.Calendar;\n\nimport java.util.Date;\n\nimport java.util.GregorianCalendar;\n\nimport java.util.Locale;\n\nimport java.util.TimeZone;\n\nimport org.apache.commons.lang3.SerializationUtils;\n\nimport org.apache.commons.lang3.test.SystemDefaults;\n\nimport org.apache.commons.lang3.test.SystemDefaultsSwitch;\n\nimport org.junit.Rule;\n\nimport org.junit.Test;\n",
      "comment": "",
      "packageName": "org.apache.commons.lang3.time",
      "Junit_version": "4"
    }
  }
]

